define("emblem", ["exports", "./emblem/parser", "./emblem/compiler", "./emblem/bootstrap"], function (_exports, _parser, _compiler, _bootstrap) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  Object.defineProperty(_exports, "Parser", {
    enumerable: true,
    get: function () {
      return _parser.default;
    }
  });
  Object.defineProperty(_exports, "compile", {
    enumerable: true,
    get: function () {
      return _compiler.compile;
    }
  });
  _exports.default = _exports.VERSION = void 0;
  _parser = _interopRequireDefault(_parser);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const VERSION = "0.12.1"; // Real exports

  _exports.VERSION = VERSION;
  // Legacy support
  var _default = {
    Parser: _parser.default,
    compile: _compiler.compile,
    VERSION
  };
  _exports.default = _default;
});
define("emblem/ast-builder", ["exports", "./utils/void-elements"], function (_exports, _voidElements) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.generateBuilder = generateBuilder;
  _voidElements = _interopRequireDefault(_voidElements);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function generateBuilder() {
    reset(builder);
    return builder;
  }

  function reset(builder) {
    var programNode = {
      type: 'program',
      childNodes: []
    };
    builder.currentNode = programNode;
    builder.previousNodes = [];
    builder._ast = programNode;
  }

  var builder = {
    toAST: function () {
      return this._ast;
    },
    generateText: function (content) {
      return {
        type: 'text',
        content: content
      };
    },
    text: function (content) {
      var node = this.generateText(content);
      this.currentNode.childNodes.push(node);
      return node;
    },
    generateInTagText: function (content) {
      return {
        type: 'inTagText',
        content: content
      };
    },
    inTagText: function (content) {
      var node = this.generateInTagText(content);
      this.currentNode.inTagText.push(node);
      return node;
    },
    generateElement: function (tagName) {
      return {
        type: 'element',
        tagName: tagName,
        isVoid: (0, _voidElements.default)(tagName),
        inTagText: [],
        attrStaches: [],
        classNameBindings: [],
        childNodes: []
      };
    },
    element: function (tagName) {
      var node = this.generateElement(tagName);
      this.currentNode.childNodes.push(node);
      return node;
    },
    generateMustache: function (content, escaped) {
      return {
        type: 'mustache',
        escaped: escaped !== false,
        content: content
      };
    },
    generateAssignedMustache: function (content, key) {
      return {
        type: 'assignedMustache',
        content: content,
        key: key
      };
    },
    mustache: function (content, escaped) {
      var node = this.generateMustache(content, escaped);
      this.currentNode.childNodes.push(node);
      return node;
    },
    generateBlock: function (content) {
      return {
        type: 'block',
        content: content,
        childNodes: [],
        invertibleNodes: []
      };
    },
    block: function (content) {
      var node = this.generateBlock(content);
      this.currentNode.childNodes.push(node);
      return node;
    },
    attribute: function (attrName, attrContent) {
      var node = {
        type: 'attribute',
        name: attrName,
        content: attrContent
      };
      this.currentNode.attrStaches.push(node);
      return node;
    },
    generateClassNameBinding: function (classNameBinding) {
      return {
        type: 'classNameBinding',
        name: classNameBinding // could be "color", or could be "hasColor:red" or ":color"

      };
    },
    classNameBinding: function (classNameBinding) {
      var node = this.generateClassNameBinding(classNameBinding);
      this.currentNode.classNameBindings.push(node);
      return node;
    },
    enter: function (node) {
      this.previousNodes.push(this.currentNode);
      this.currentNode = node;
    },
    exit: function () {
      var lastNode = this.currentNode;
      this.currentNode = this.previousNodes.pop();
      return lastNode;
    },
    add: function (label, node) {
      if (Array.isArray(node)) {
        for (var i = 0, l = node.length; i < l; i++) {
          this.add(label, node[i]);
        }
      } else {
        this.currentNode[label].push(node);
      }
    }
  };
});
define("emblem/bootstrap", ["./compiler"], function (_compiler) {
  "use strict";

  function compileScriptTags(scope) {
    var Handlebars = scope.Handlebars;
    var Ember = scope.Ember;

    if (typeof Ember === "undefined" || Ember === null) {
      throw new Error("Can't run Emblem.enableEmber before Ember has been defined");
    }

    if (typeof document !== "undefined" && document !== null) {
      return Ember.$('script[type="text/x-emblem"], script[type="text/x-raw-emblem"]', Ember.$(document)).each(function () {
        var handlebarsVariant, script, templateName;
        script = Ember.$(this);
        handlebarsVariant = script.attr('type') === 'text/x-raw-handlebars' ? Handlebars : Ember.Handlebars;
        templateName = script.attr('data-template-name') || script.attr('id') || 'application';
        Ember.TEMPLATES[templateName] = (0, _compiler.compile)(handlebarsVariant, script.html());
        return script.remove();
      });
    }
  }

  if (typeof window !== "undefined" && window !== null) {
    var ENV = window.ENV || (window.ENV = {});
    ENV.EMBER_LOAD_HOOKS = ENV.EMBER_LOAD_HOOKS || {};
    ENV.EMBER_LOAD_HOOKS.application = ENV.EMBER_LOAD_HOOKS.application || [];
    ENV.EMBER_LOAD_HOOKS.application.push(compileScriptTags);
    ENV.EMBER_LOAD_HOOKS['Ember.Application'] = ENV.EMBER_LOAD_HOOKS['Ember.Application'] || [];
    ENV.EMBER_LOAD_HOOKS['Ember.Application'].push(function (Application) {
      if (Application.initializer) {
        return Application.initializer({
          name: 'emblemDomTemplates',
          before: 'registerComponentLookup',
          initialize: compileScriptTags
        });
      } else {
        return window.Ember.onLoad('application', compileScriptTags);
      }
    });
  }
});
define("emblem/build/emblem-tree", [], function () {
  "use strict";

  const appPackage = require('../../package.json');

  const Funnel = require('broccoli-funnel');

  const replace = require('broccoli-replace');

  const broccoliStew = require('broccoli-stew');

  const pegBuilder = require('./pegjs-builder');

  const pegjsImport = require('@invisible/pegjs-import');

  const mergeTrees = require('broccoli-merge-trees');

  const concat = require('broccoli-concat');
  /**
   *  This will generate a tree of all of the transpilation needed to build an instance
   *  of Emblem.
   */


  const outputDir = '/';

  function replaceVersion(tree, files) {
    return replace(tree, {
      files: files,
      patterns: [{
        match: /VERSION_STRING_PLACEHOLDER/,
        replacement: appPackage.version
      }]
    });
  }
  /**
   *  Build the initial tree of Javascript files and move them to the emblem namespace
   */


  function buildSrcTree() {
    let lib = new Funnel('lib', {
      exclude: ['**/*.rb', '**/*.pegjs'],
      destDir: outputDir + 'emblem'
    });
    lib = replaceVersion(lib, ['emblem/main.js']);
    lib = broccoliStew.mv(lib, 'emblem/main.js', 'emblem.js');
    return lib;
  }
  /**
   * Build the pegjs tree and run it through the pegjs parser
   *
   * Note that the generated JS file has some shared imports / exports added to the file.
   */


  function buildPegTree() {
    const pegFunnel = new Funnel('lib', {
      include: ['**/*.pegjs'],
      destDir: outputDir + 'emblem'
    });
    const pegTree = pegBuilder(pegFunnel, {
      peg: pegjsImport,
      wrapper: function (src, parser) {
        return ['/*jshint newcap: false, laxbreak: true */', "import { generateBuilder } from './ast-builder';", "import { INDENT_SYMBOL, DEDENT_SYMBOL, UNMATCHED_DEDENT_SYMBOL, TERM_SYMBOL } from './preprocessor';", "import { HTML_EVENTS, ALIAS_EVENTS } from './html/events';", "import KNOWN_TAGS from './html/tags';", 'var Parser = ' + parser + ';', 'var parse = Parser.parse, ParserSyntaxError = Parser.SyntaxError;', 'export {ParserSyntaxError, parse};', 'export default parse;'].join('\n');
      }
    });
    return pegTree;
  }
  /**
   *  Build StringScanner tree
   */


  function buildStringScannerTree() {
    const stringScannerTree = new Funnel('node_modules/StringScanner/lib', {
      include: ['StringScanner.js']
    });
    const header = 'var module = {};\n(function() {';
    const footer = '})(); export default module.exports;';
    return concat(stringScannerTree, {
      inputFiles: ['StringScanner.js'],
      outputFile: outputDir + 'string-scanner.js',
      header: header,
      footer: footer,
      wrapInFunction: false
    });
  }

  module.exports = mergeTrees([buildSrcTree(), buildPegTree(), buildStringScannerTree()]);
});
define("emblem/build/main-bundle", [], function () {
  "use strict";

  /* eslint-env node */
  const emblemTree = require('./emblem-tree');

  const testBundle = require('./test-bundle');

  const Rollup = require('broccoli-rollup');

  const babel = require('rollup-plugin-babel');

  const mergeTrees = require('broccoli-merge-trees');

  const EmberApp = require('ember-cli/lib/broccoli/ember-app');

  const environment = EmberApp.env();
  const production = environment === 'production';
  const includeTests = !production;
  const babelOptions = {
    plugins: [],
    presets: []
  };

  if (production) {
    babelOptions.presets.push('minify');
  }
  /**
   * Use rollup + babel to combine everything into a single bundle, as well as build CJS / AMD versions
   */


  const appBundle = new Rollup(emblemTree, {
    rollup: {
      input: 'emblem.js',
      output: [{
        file: 'cjs/emblem.js',
        sourceMap: false,
        exports: 'named',
        name: 'emblem',
        format: 'cjs'
      }, {
        file: 'emblem.amd.js',
        sourceMap: false,
        exports: 'named',
        format: 'amd',
        amd: {
          id: 'emblem'
        }
      }],
      plugins: [babel(babelOptions)]
    }
  }); // If we are building test assets, then we need to include the non-rolled up code as well so that unit tests work

  if (includeTests) {
    module.exports = mergeTrees([appBundle, testBundle]);
  } else {
    module.exports = appBundle;
  }
});
define("emblem/build/pegjs-builder", [], function () {
  "use strict";

  /**
   * This is a cheap fork of https://github.com/201-created/broccoli-pegjs-import
   *
   * The only reason for this is because that addon has an older version of broccoli-filter
   */
  var Filter = require('broccoli-filter');

  var fs = require('fs');

  var Promise = require('rsvp').Promise;

  module.exports = PegFilter;
  PegFilter.prototype = Object.create(Filter.prototype);
  PegFilter.prototype.constructor = PegFilter;

  function PegFilter(inputTree, options) {
    if (!(this instanceof PegFilter)) return new PegFilter(inputTree, options);
    Filter.call(this, inputTree, options);
    options = options || {};

    if (!options.output) {
      options.output = "source";
    }

    if (!options.wrapper) {
      options.wrapper = function (src, parser) {
        if (typeof options.exportVar === 'function') {
          return options.exportVar(src) + ' = ' + parser + ';';
        } else {
          return (typeof options.exportVar === 'string' ? options.exportVar : 'module.exports') + ' = ' + parser + ';';
        }
      };
    }

    this.peg = options.peg || require('pegjs-import');
    delete options.peg;
    this.options = options;
  }

  PegFilter.prototype.extensions = ['pegjs'];
  PegFilter.prototype.targetExtension = 'js';

  PegFilter.prototype.processFile = function (srcDir, destDir, relativePath) {
    var self = this;
    var inputEncoding = this.inputEncoding === undefined ? 'utf8' : this.inputEncoding;
    var outputEncoding = this.outputEncoding === undefined ? 'utf8' : this.outputEncoding;
    var parser = this.peg.buildParser(srcDir + '/' + relativePath, this.options);
    var src = fs.readFileSync(srcDir + '/' + relativePath, {
      encoding: inputEncoding
    });
    var output = this.options.wrapper(src, parser);
    return Promise.resolve(output).then(function (outputString) {
      var outputPath = self.getDestFilePath(relativePath);
      fs.writeFileSync(destDir + '/' + outputPath, outputString, {
        encoding: outputEncoding
      });
    });
  };
});
define("emblem/build/qunit-shim", [], function () {
  "use strict";

  /* globals QUnit */
  define('qunit', ['exports'], function (_exports) {
    'use strict';

    Object.defineProperty(_exports, '__esModule', {
      value: true
    });
    _exports.default = QUnit;
    _exports.module = QUnit.module;
    _exports.test = QUnit.test;
    _exports.skip = QUnit.skip;
    _exports.only = QUnit.only;
    _exports.todo = QUnit.todo;
  });
});
define("emblem/build/test-bundle", [], function () {
  "use strict";

  const Funnel = require('broccoli-funnel');

  const mergeTrees = require('broccoli-merge-trees');

  const broccoliStew = require('broccoli-stew');

  const babel = require('broccoli-babel-transpiler');

  const concat = require('broccoli-concat');

  const emblemTree = require('./emblem-tree');

  const outputDir = '/';
  const currentDir = process.cwd();
  /**
   * This is a copy of all of the emblem files, but not rolled up into a single file.
   * This allows for unit tests to run against pieces of the final app.
   */

  function buildEmblemFiles() {
    const appFiles = new Funnel(emblemTree, {
      include: ['**/*.js']
    });
    const transpiledAppFiles = babel(appFiles, {
      plugins: ['@babel/plugin-transform-modules-amd'],
      moduleIds: true,
      // Transforms /index.js files to use their containing directory name
      getModuleId: name => {
        const shortenedName = name.replace(currentDir + '/', '');
        return shortenedName;
      }
    });
    const testAppBundle = concat(transpiledAppFiles, {
      inputFiles: '**/*.js',
      outputFile: outputDir + 'emblem.js',
      sourceMapConfig: {
        enabled: false
      }
    });
    return broccoliStew.mv(testAppBundle, outputDir + 'test-app');
  }
  /**
   *  Generate a tree of all test files
   *
   *  This also builds a single file for all tests that will evaluate those tests and initiate Testem
   */


  function buildTestTree() {
    const qUnitShim = new Funnel('lib/build', {
      files: ['qunit-shim.js']
    });
    const testFiles = new Funnel('tests', {
      include: ['**/*.js']
    });
    const transpiledTestFiles = babel(testFiles, {
      plugins: ['@babel/plugin-transform-modules-amd'],
      moduleIds: true,
      // Transforms /index.js files to use their containing directory name
      getModuleId: name => {
        const shortenedName = name.replace(currentDir, 'tests');
        return shortenedName;
      }
    });
    const testBundle = concat(mergeTrees([transpiledTestFiles, qUnitShim]), {
      inputFiles: '**/*.js',
      outputFile: outputDir + 'tests.js',
      sourceMapConfig: {
        enabled: false
      }
    });
    const nonJsTree = new Funnel('tests', {
      exclude: ['**/*.js']
    });
    return mergeTrees([qUnitShim, testBundle, nonJsTree]);
  }
  /**
   *  Generate a tree for all test support imports
   */


  function buildTestSupportTree() {
    const qUnitTree = new Funnel('node_modules/qunit', {
      srcDir: 'qunit',
      destDir: 'qunit'
    });
    const loaderTree = new Funnel('node_modules/loader.js/dist', {
      srcDir: 'loader',
      destDir: 'loader.js'
    });
    const handlebarsTree = new Funnel('node_modules/handlebars/dist', {
      include: ['handlebars.js'],
      destDir: 'handlebars'
    });
    const jQueryTree = new Funnel('node_modules/jquery/dist', {
      include: ['jquery.js'],
      destDir: 'jquery'
    });
    return mergeTrees([qUnitTree, loaderTree, handlebarsTree, jQueryTree]);
  }

  const fullTestBundle = mergeTrees([buildTestTree(), buildEmblemFiles(), buildTestSupportTree()]);
  module.exports = broccoliStew.mv(fullTestBundle, outputDir + 'tests');
});
define("emblem/compiler", ["exports", "./parser", "./preprocessor", "./template-compiler", "./ast-builder"], function (_exports, _parser, _preprocessor, _templateCompiler, _astBuilder) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.compile = compile;

  /**
    options can include:
      quite: disable deprecation notices
      debugging: show output handlebars in console
  */
  function compile(emblem, customOptions) {
    var builder = (0, _astBuilder.generateBuilder)();
    var options = customOptions || {};
    var processedEmblem = (0, _preprocessor.processSync)(emblem);
    options['builder'] = builder;
    (0, _parser.parse)(processedEmblem, options);
    var ast = builder.toAST();
    var result = (0, _templateCompiler.compile)(ast, options);

    if (options.debugging) {
      console.log(result);
    }

    return result;
  }
});
define("emblem/html/events", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ALIAS_EVENTS = _exports.HTML_EVENTS = void 0;
  var eventAliases = ['blur', 'change', 'click', 'contextMenu', 'dblclick', 'drag', 'dragEnd', 'dragEnter', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'focus', 'focusIn', 'focusOut', 'input', 'keyDown', 'keyPress', 'keyUp', 'mouseDown', 'mouseEnter', 'mouseLeave', 'mouseMove', 'mouseUp', 'resize', 'scroll', 'select', 'submit', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart'];

  function toObject(objects) {
    return objects.reduce((results, event) => {
      results[event] = true;
      return results;
    }, {});
  }

  var HTML_EVENTS = toObject(eventAliases.map(function (name) {
    return 'on' + name;
  }));
  _exports.HTML_EVENTS = HTML_EVENTS;
  var ALIAS_EVENTS = toObject(eventAliases);
  _exports.ALIAS_EVENTS = ALIAS_EVENTS;
});
define("emblem/html/tags", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  var _default = {
    figcaption: true,
    blockquote: true,
    plaintext: true,
    textarea: true,
    progress: true,
    optgroup: true,
    noscript: true,
    noframes: true,
    frameset: true,
    fieldset: true,
    datalist: true,
    colgroup: true,
    basefont: true,
    summary: true,
    section: true,
    marquee: true,
    listing: true,
    isindex: true,
    details: true,
    command: true,
    caption: true,
    bgsound: true,
    article: true,
    address: true,
    acronym: true,
    strong: true,
    strike: true,
    spacer: true,
    source: true,
    select: true,
    script: true,
    output: true,
    option: true,
    object: true,
    legend: true,
    keygen: true,
    iframe: true,
    hgroup: true,
    header: true,
    footer: true,
    figure: true,
    center: true,
    canvas: true,
    button: true,
    applet: true,
    video: true,
    track: true,
    title: true,
    thead: true,
    tfoot: true,
    tbody: true,
    table: true,
    style: true,
    small: true,
    param: true,
    meter: true,
    label: true,
    input: true,
    frame: true,
    embed: true,
    blink: true,
    audio: true,
    aside: true,
    time: true,
    span: true,
    samp: true,
    ruby: true,
    nobr: true,
    meta: true,
    menu: true,
    mark: true,
    main: true,
    link: true,
    html: true,
    head: true,
    form: true,
    font: true,
    data: true,
    code: true,
    cite: true,
    body: true,
    base: true,
    area: true,
    abbr: true,
    xmp: true,
    wbr: true,
    'var': true,
    sup: true,
    sub: true,
    pre: true,
    nav: true,
    map: true,
    kbd: true,
    ins: true,
    img: true,
    div: true,
    dir: true,
    dfn: true,
    del: true,
    col: true,
    big: true,
    bdo: true,
    bdi: true,
    ul: true,
    tt: true,
    tr: true,
    th: true,
    td: true,
    rt: true,
    rp: true,
    ol: true,
    li: true,
    hr: true,
    h6: true,
    h5: true,
    h4: true,
    h3: true,
    h2: true,
    h1: true,
    em: true,
    dt: true,
    dl: true,
    dd: true,
    br: true,
    u: true,
    s: true,
    q: true,
    p: true,
    i: true,
    b: true,
    a: true,
    menuitem: true
  };
  _exports.default = _default;
});
define("emblem/parser", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _54start: peg$parse_54start
      },
          peg$startRuleFunction = peg$parse_54start,
          peg$c0 = /^[ \t]/,
          peg$c1 = peg$classExpectation([" ", "\t"], false, false),
          peg$c2 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c3 = function () {
        return [];
      },
          peg$c4 = peg$otherExpectation("_2LineEnd"),
          peg$c5 = "\r",
          peg$c6 = peg$literalExpectation("\r", false),
          peg$c7 = peg$anyExpectation(),
          peg$c8 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c9 = "\n",
          peg$c10 = peg$literalExpectation("\n", false),
          peg$c11 = function (t) {
        return false;
      },
          peg$c12 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c13 = peg$otherExpectation("_3DEDENT"),
          peg$c14 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c15 = function (t) {
        return '';
      },
          peg$c16 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c17 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c18 = peg$otherExpectation("_4RequiredWhitespace"),
          peg$c19 = function (s) {
        return s;
      },
          peg$c20 = peg$otherExpectation("_5INDENT"),
          peg$c21 = function (t) {
        return _preprocessor.INDENT_SYMBOL === t;
      },
          peg$c22 = function (c) {
        return c;
      },
          peg$c23 = peg$otherExpectation("_6INDENT"),
          peg$c24 = peg$otherExpectation("_6DEDENT"),
          peg$c25 = peg$otherExpectation("_6LineEnd"),
          peg$c26 = peg$otherExpectation("_7Comment"),
          peg$c27 = "/",
          peg$c28 = peg$literalExpectation("/", false),
          peg$c29 = peg$otherExpectation("_7LineEnd"),
          peg$c30 = "=",
          peg$c31 = peg$literalExpectation("=", false),
          peg$c32 = "else",
          peg$c33 = peg$literalExpectation("else", false),
          peg$c34 = "if",
          peg$c35 = peg$literalExpectation("if", false),
          peg$c36 = function (e) {
        return e.join('');
      },
          peg$c37 = "==",
          peg$c38 = peg$literalExpectation("==", false),
          peg$c39 = " ",
          peg$c40 = peg$literalExpectation(" ", false),
          peg$c41 = function () {
        return false;
      },
          peg$c42 = function () {
        return true;
      },
          peg$c43 = peg$otherExpectation("_11mustache expression"),
          peg$c44 = "{",
          peg$c45 = peg$literalExpectation("{", false),
          peg$c46 = /^[^}]/,
          peg$c47 = peg$classExpectation(["}"], true, false),
          peg$c48 = function (text) {
        return text;
      },
          peg$c49 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), false);
      },
          peg$c50 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), true);
      },
          peg$c51 = peg$otherExpectation("_12Double Mustache Open"),
          peg$c52 = "{{",
          peg$c53 = peg$literalExpectation("{{", false),
          peg$c54 = peg$otherExpectation("_12Triple Mustache Open"),
          peg$c55 = "{{{",
          peg$c56 = peg$literalExpectation("{{{", false),
          peg$c57 = peg$otherExpectation("_12Double Mustache Close"),
          peg$c58 = "}}",
          peg$c59 = peg$literalExpectation("}}", false),
          peg$c60 = peg$otherExpectation("_12Triple Mustache Close"),
          peg$c61 = "}}}",
          peg$c62 = peg$literalExpectation("}}}", false),
          peg$c63 = peg$otherExpectation("_12String Interpolation Open"),
          peg$c64 = "#{",
          peg$c65 = peg$literalExpectation("#{", false),
          peg$c66 = peg$otherExpectation("_12String Interpolation Close"),
          peg$c67 = "}",
          peg$c68 = peg$literalExpectation("}", false),
          peg$c69 = peg$otherExpectation("_13Single Mustache Open"),
          peg$c70 = peg$otherExpectation("_13Double Mustache Open"),
          peg$c71 = peg$otherExpectation("_13Triple Mustache Open"),
          peg$c72 = peg$otherExpectation("_13String Interpolation Open"),
          peg$c73 = peg$otherExpectation("_13LineEnd"),
          peg$c74 = function (first, tail) {
        return flattenArray(first, tail);
      },
          peg$c75 = peg$otherExpectation("_14LineEnd"),
          peg$c76 = function (nodes) {
        return nodes;
      },
          peg$c77 = function (s, nodes, w) {
        return w;
      },
          peg$c78 = function (s, nodes, indentedNodes) {
        var i, l;
        var hasNodes = nodes && nodes.length,
            hasIndentedNodes = indentedNodes && indentedNodes.length; // add a space after the first line if it had content and
        // there are indented nodes to follow

        if (hasNodes && hasIndentedNodes) {
          nodes.push(' ');
        } // concat indented nodes


        if (indentedNodes) {
          for (i = 0, l = indentedNodes.length; i < l; i++) {
            nodes = nodes.concat(indentedNodes[i]); // connect logical lines with a space, skipping the next-to-last line

            if (i < l - 1) {
              nodes.push(' ');
            }
          }
        } // add trailing space to non-indented nodes if special modifier


        if (s === LINE_SPACE_MODIFIERS.SPACE_AFTER) {
          nodes.push(' ');
        } else if (s === LINE_SPACE_MODIFIERS.NEWLINE) {
          nodes.push('\n');
        } else if (s === LINE_SPACE_MODIFIERS.SPACE_BOTH) {
          nodes.push(' ');
          nodes.unshift(' ');
        } else if (s === LINE_SPACE_MODIFIERS.SPACE_BEFORE) {
          nodes.unshift(' ');
        }

        return castStringsToTextNodes(nodes);
      },
          peg$c79 = /^[|`'+"]/,
          peg$c80 = peg$classExpectation(["|", "`", "'", "+", "\""], false, false),
          peg$c81 = "<",
          peg$c82 = peg$literalExpectation("<", false),
          peg$c83 = function () {
        return '<';
      },
          peg$c84 = peg$otherExpectation("_16DEDENT"),
          peg$c85 = function (v) {
        var last = v[v.length - 1];
        var idNode; // Support for data keywords that are prefixed with @ in the each
        // block helper such as @index, @key, @first, @last

        if (last.part.charAt(0) === '@') {
          last.part = last.part.slice(1);
          idNode = new AST.IdNode(v);
          var dataNode = new AST.DataNode(idNode);
          return dataNode;
        }

        var match;
        var suffixModifier; // FIXME probably need to handle this better?

        if (match = last.part.match(/!$/)) {
          last.part = 'unbound ' + last.part.slice(0, -1);
        }

        if (match = last.part.match(/[\?\^]$/)) {
          suffixModifier = match[0];
          throw "unhandled path terminated: " + suffixModifier;
        }

        return last.part;
      },
          peg$c86 = function (first, s, p) {
        return {
          part: p,
          separator: s
        };
      },
          peg$c87 = function (first, tail) {
        var ret = [{
          part: first
        }];

        for (var i = 0; i < tail.length; ++i) {
          ret.push(tail[i]);
        }

        return ret;
      },
          peg$c88 = peg$otherExpectation("_17PathIdent"),
          peg$c89 = "..",
          peg$c90 = peg$literalExpectation("..", false),
          peg$c91 = ".",
          peg$c92 = peg$literalExpectation(".", false),
          peg$c93 = /^[a-zA-Z0-9_$\-!?\^@]/,
          peg$c94 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "$", "-", "!", "?", "^", "@"], false, false),
          peg$c95 = "[",
          peg$c96 = peg$literalExpectation("[", false),
          peg$c97 = /^[^\]]/,
          peg$c98 = peg$classExpectation(["]"], true, false),
          peg$c99 = "]",
          peg$c100 = peg$literalExpectation("]", false),
          peg$c101 = function (segmentLiteral) {
        return segmentLiteral;
      },
          peg$c102 = peg$otherExpectation("_17PathSeparator"),
          peg$c103 = /^[\/.]/,
          peg$c104 = peg$classExpectation(["/", "."], false, false),
          peg$c105 = ":",
          peg$c106 = peg$literalExpectation(":", false),
          peg$c107 = peg$otherExpectation("_19valid tag string"),
          peg$c108 = /^[_a-zA-Z0-9\-]/,
          peg$c109 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c110 = "@",
          peg$c111 = peg$literalExpectation("@", false),
          peg$c112 = function (p) {
        return p;
      },
          peg$c113 = "'",
          peg$c114 = peg$literalExpectation("'", false),
          peg$c115 = "\"",
          peg$c116 = peg$literalExpectation("\"", false),
          peg$c117 = peg$otherExpectation("_20Closing single quote"),
          peg$c118 = peg$otherExpectation("_20Closing double quote"),
          peg$c119 = peg$otherExpectation("_20string action attributes"),
          peg$c120 = /^[^"}]/,
          peg$c121 = peg$classExpectation(["\"", "}"], true, false),
          peg$c122 = /^[^'}]/,
          peg$c123 = peg$classExpectation(["'", "}"], true, false),
          peg$c124 = peg$otherExpectation("_20LineEnd"),
          peg$c125 = function (value) {
        return value;
      },
          peg$c126 = peg$otherExpectation("_21closing mustache"),
          peg$c127 = function (event, mustacheNode) {
        var actionBody, parts;

        if (typeof mustacheNode === 'string') {
          actionBody = mustacheNode;
        } else {
          parts = mustacheNode[1].split(' ');

          if (parts.length === 1) {
            actionBody = '"' + parts[0] + '"';
          } else {
            actionBody = mustacheNode[1];
          }
        }

        var actionContent = [actionBody];

        if (actionBody.indexOf('action ') !== 0) {
          actionContent.unshift('action');
        }

        return buildActionEvent(event, actionContent);
      },
          peg$c128 = peg$otherExpectation("_22a valid JS event"),
          peg$c129 = function (event) {
        return isAliasEvent(event);
      },
          peg$c130 = function (event) {
        return event;
      },
          peg$c131 = function (id) {
        return id;
      },
          peg$c132 = function (value) {
        return value;
      },
          peg$c133 = /^[\x80-\xFF]/,
          peg$c134 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c135 = peg$otherExpectation("_24Key"),
          peg$c136 = "true",
          peg$c137 = peg$literalExpectation("true", false),
          peg$c138 = "false",
          peg$c139 = peg$literalExpectation("false", false),
          peg$c140 = function (key, boolValue) {
        if (boolValue === 'true') {
          return [key];
        }
      },
          peg$c141 = peg$otherExpectation("_26Attribute Key"),
          peg$c142 = "$",
          peg$c143 = peg$literalExpectation("$", false),
          peg$c144 = function (key, digits) {
        var value = parseInt(digits.join(""), 10);
        return [key, value];
      },
          peg$c145 = peg$otherExpectation("_27Valid numbers"),
          peg$c146 = /^[0-9]/,
          peg$c147 = peg$classExpectation([["0", "9"]], false, false),
          peg$c148 = function (key, value) {
        value = value.trim(); // Class logic needs to be coalesced, except for conditional statements

        if (key === 'class') {
          if (value.indexOf('if') === 0 || value.indexOf('unless') === 0) {
            return builder.generateClassNameBinding(value);
          } else {
            return splitValueIntoClassBindings(value);
          }
        } else {
          return [builder.generateAssignedMustache(value, key)];
        }
      },
          peg$c149 = /^[\-_\/A-Za-z0-9]/,
          peg$c150 = peg$classExpectation(["-", "_", "/", ["A", "Z"], ["a", "z"], ["0", "9"]], false, false),
          peg$c151 = "::",
          peg$c152 = peg$literalExpectation("::", false),
          peg$c153 = ".[",
          peg$c154 = peg$literalExpectation(".[", false),
          peg$c155 = "!",
          peg$c156 = peg$literalExpectation("!", false),
          peg$c157 = function (key, value) {
        if (key === 'class') {
          return splitValueIntoClassBindings(value);
        } else {
          return [builder.generateAssignedMustache(value, key)];
        }
      },
          peg$c158 = function (value) {
        return value.replace(/ *$/, '');
      },
          peg$c159 = peg$otherExpectation("_30valid attribute value"),
          peg$c160 = peg$otherExpectation("_30closing mustache"),
          peg$c161 = function (key, nodes) {
        var strings = [];
        nodes.forEach(function (node) {
          if (typeof node === 'string') {
            strings.push(node);
          } else {
            // FIXME here we transform a mustache attribute
            // This should be handled higher up instead, not here.
            // This happens when the attribute is something like:
            // src="{{unbound post.showLogoUrl}}".
            // key = "src", nodes[0] = "unbound post.showLogoUrl"
            if (node.escaped) {
              strings.push('{{' + node.content + '}}');
            } else {
              strings.push('{{{' + node.content + '}}}');
            }
          }
        });
        var result = [key, strings.join('')];
        return result;
      },
          peg$c162 = function (a) {
        return a;
      },
          peg$c163 = peg$otherExpectation("_31Closing Single Quote"),
          peg$c164 = peg$otherExpectation("_31Closing Double Quote"),
          peg$c165 = peg$otherExpectation("_31Valid quoted attribute value"),
          peg$c166 = function (key, value) {
        return [key, '{{' + value + '}}'];
      },
          peg$c167 = "...attributes",
          peg$c168 = peg$literalExpectation("...attributes", false),
          peg$c169 = function (spread) {
        return [spread];
      },
          peg$c170 = function (a) {
        if (!a) return [];else if (!a.length) return [a];else return a;
      },
          peg$c171 = function (a) {
        return a;
      },
          peg$c172 = peg$otherExpectation("_35LineEnd"),
          peg$c173 = peg$otherExpectation("_35INDENT"),
          peg$c174 = peg$otherExpectation("_36CSS class"),
          peg$c175 = peg$otherExpectation("_37HTML ID"),
          peg$c176 = "#",
          peg$c177 = peg$literalExpectation("#", false),
          peg$c178 = function (c) {
        return c;
      },
          peg$c179 = function (s) {
        return {
          shorthand: s,
          id: true
        };
      },
          peg$c180 = function (s) {
        return {
          shorthand: s
        };
      },
          peg$c181 = function (shorthands) {
        var id,
            classes = [];

        for (var i = 0, len = shorthands.length; i < len; ++i) {
          var shorthand = shorthands[i];

          if (shorthand.id) {
            id = shorthand.shorthand;
          } else {
            classes.push(shorthand.shorthand);
          }
        }

        return [id, classes];
      },
          peg$c182 = function (m) {
        return builder.generateMustache(m, true);
      },
          peg$c183 = function (h, startingInTagMustaches, inTagMustaches, fullAttributes) {
        return parseInHtml(h, startingInTagMustaches.concat(inTagMustaches), fullAttributes);
      },
          peg$c184 = function (h, inTagMustaches, fullAttributes) {
        return parseInHtml(h, inTagMustaches, fullAttributes);
      },
          peg$c185 = function (h, s) {
        return h || s;
      },
          peg$c186 = function (tag) {
        return isKnownTag(tag);
      },
          peg$c187 = function (tag) {
        return tag;
      },
          peg$c188 = peg$otherExpectation("_41LineEnd"),
          peg$c189 = peg$otherExpectation("_41INDENT"),
          peg$c190 = "as",
          peg$c191 = peg$literalExpectation("as", false),
          peg$c192 = peg$otherExpectation("_42block param starting pipe"),
          peg$c193 = "|",
          peg$c194 = peg$literalExpectation("|", false),
          peg$c195 = peg$otherExpectation("_43Quoted string"),
          peg$c196 = /^[^'"]/,
          peg$c197 = peg$classExpectation(["'", "\""], true, false),
          peg$c198 = function (v) {
        return v;
      },
          peg$c199 = /^[\/(]/,
          peg$c200 = peg$classExpectation(["/", "("], false, false),
          peg$c201 = peg$otherExpectation("_45block params closing pipe"),
          peg$c202 = function (params) {
        return params;
      },
          peg$c203 = peg$otherExpectation("_46block param"),
          peg$c204 = function (h, blockParams, inTagMustaches, fullAttributes) {
        return parseInHtml(h, inTagMustaches, fullAttributes, blockParams);
      },
          peg$c205 = function (h, inTagMustaches, fullAttributes, blockParams) {
        return parseInHtml(h, inTagMustaches, fullAttributes, blockParams);
      },
          peg$c206 = function (h, s) {
        return h || s;
      },
          peg$c207 = "%",
          peg$c208 = peg$literalExpectation("%", false),
          peg$c209 = function (s) {
        return s;
      },
          peg$c210 = peg$otherExpectation("_47LineEnd"),
          peg$c211 = peg$otherExpectation("_47INDENT"),
          peg$c212 = function (ret, multilineContent) {
        if (multilineContent) {
          multilineContent = multilineContent[1];

          for (var i = 0, len = multilineContent.length; i < len; ++i) {
            ret.push(' ');
            ret = ret.concat(multilineContent[i]);
          }
        }

        return ret;
      },
          peg$c213 = peg$otherExpectation("_49DEDENT"),
          peg$c214 = function (initialAttr, attrs) {
        if (initialAttr) attrs.unshift(initialAttr); // Filter out comments

        return attrs.filter(function (attr) {
          return attr && attr.length > 0;
        });
      },
          peg$c215 = function (attr) {
        return attr;
      },
          peg$c216 = peg$otherExpectation("_50Closing bracket"),
          peg$c217 = function (key, value) {
        return key + '=' + value;
      },
          peg$c218 = "(",
          peg$c219 = peg$literalExpectation("(", false),
          peg$c220 = function (helper, attrs) {
        var firstHalf = '(' + helper;
        if (attrs) return firstHalf + ' ' + attrs.join(' ') + ')';else return firstHalf + ')';
      },
          peg$c221 = peg$otherExpectation("_50Closing ) for Subexpression"),
          peg$c222 = ")",
          peg$c223 = peg$literalExpectation(")", false),
          peg$c224 = peg$otherExpectation("_50Subexpression bracketed attribute"),
          peg$c225 = function (attrs) {
        return attrs;
      },
          peg$c226 = peg$otherExpectation("_50INDENT"),
          peg$c227 = peg$otherExpectation("_50DEDENT"),
          peg$c228 = peg$otherExpectation("_50LineEnd"),
          peg$c229 = peg$otherExpectation("_51tagName shorthand"),
          peg$c230 = function (tagName) {
        return 'tagName="' + tagName + '"';
      },
          peg$c231 = peg$otherExpectation("_51elementId shorthand"),
          peg$c232 = function (idName) {
        return 'elementId="' + idName + '"';
      },
          peg$c233 = peg$otherExpectation("_51class shorthand"),
          peg$c234 = function (className) {
        return 'class="' + className + '"';
      },
          peg$c235 = /^[A-Za-z0-9\-_]/,
          peg$c236 = peg$classExpectation([["A", "Z"], ["a", "z"], ["0", "9"], "-", "_"], false, false),
          peg$c237 = peg$otherExpectation("_52Unbound modifier !"),
          peg$c238 = peg$otherExpectation("_52Conditional modifier ?"),
          peg$c239 = "?",
          peg$c240 = peg$literalExpectation("?", false),
          peg$c241 = function (mustacheStart, attrs, blockParams) {
        attrs = attrs.concat(mustacheStart.shorthands);
        mustacheStart['attrs'] = attrs;
        mustacheStart['blockParams'] = blockParams;
        return mustacheStart;
      },
          peg$c242 = function (nameAst, shorthands) {
        var component = nameAst.name.indexOf('-') > -1;
        nameAst['component'] = component;
        nameAst['shorthands'] = shorthands;
        return nameAst;
      },
          peg$c243 = function (name, modifier) {
        return {
          name: name,
          modifier: modifier
        };
      },
          peg$c244 = peg$otherExpectation("_53Invalid mustache starting character"),
          peg$c245 = "-",
          peg$c246 = peg$literalExpectation("-", false),
          peg$c247 = function (c) {
        builder.add('childNodes', c);
      },
          peg$c248 = function (statements) {
        return statements;
      },
          peg$c249 = ": ",
          peg$c250 = peg$literalExpectation(": ", false),
          peg$c251 = function (h, nested) {
        if (nested && nested.length > 0) {
          nested = castStringsToTextNodes(nested);
          builder.add('childNodes', nested);
        }

        return [builder.exit()];
      },
          peg$c252 = function (mustacheTuple) {
        var blockOrMustache = createBlockOrMustache(mustacheTuple);
        return [blockOrMustache];
      },
          peg$c253 = function (c) {
        return c;
      },
          peg$c254 = function (h) {
        return h;
      },
          peg$c255 = function (mustacheTuple) {
        var parsedMustacheOrBlock = createBlockOrMustache(mustacheTuple);
        return [parsedMustacheOrBlock];
      },
          peg$c256 = function (e, mustacheTuple) {
        var mustache = mustacheTuple[0];
        var block = mustacheTuple[1];
        mustache.isEscaped = e;
        mustache.explicit = !e;
        return [mustache, block];
      },
          peg$c257 = function (mustacheTuple) {
        var mustacheAst = mustacheTuple[0];

        if (mustacheAst.isViewHelper) {
          logDeprecation('View syntax detected: ' + mustacheAst.name);
        }

        if (mustacheAst.component) {
          logDeprecation('Explicit component declarations will be interpreted as angle-bracket components in a later release: ' + mustacheAst.name);
        }

        return mustacheTuple;
      },
          peg$c258 = /^[A-Z]/,
          peg$c259 = peg$classExpectation([["A", "Z"]], false, false),
          peg$c260 = function (mustacheTuple) {
        var mustache = mustacheTuple[0];
        var block = mustacheTuple[1];
        mustache.isViewHelper = true;
        return [mustache, block];
      },
          peg$c261 = function (mustacheContent, blockTuple) {
        if (blockTuple) {
          return [mustacheContent, blockTuple];
        } else {
          return [mustacheContent];
        }
      },
          peg$c262 = function (mustache) {
        return mustache;
      },
          peg$c263 = function (statements) {
        return {
          blockTuple: statements
        };
      },
          peg$c264 = function (i) {
        return i;
      },
          peg$c265 = function (block) {
        return {
          blockTuple: block
        };
      },
          peg$c266 = function (mustache) {
        return mustache;
      },
          peg$c267 = function (blockParams, block) {
        return {
          blockParams: blockParams,
          blockTuple: block
        };
      },
          peg$c268 = function () {
        return;
      },
          peg$c269 = function (c, i) {
        return [c, i];
      },
          peg$c270 = function (b, a, c, i) {
        return {
          content: c,
          name: [b, a].join(' '),
          isInvertible: true,
          invertibleNodes: i
        };
      },
          peg$c271 = function (p) {
        return p.join(' ');
      },
          peg$c272 = peg$otherExpectation("_54INDENT"),
          peg$c273 = peg$otherExpectation("_54DEDENT"),
          peg$c274 = peg$otherExpectation("_54LineEnd"),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        return s0;
      }

      function peg$parse_2blankLine() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_2TERM();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c3();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_2TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c8(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        return s0;
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c14(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c15(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c17(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c15(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        return s0;
      }

      function peg$parse_4start() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_0start();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_0start();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c18);
          }
        }

        return s0;
      }

      function peg$parse_5indentation() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_5INDENT();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_4start();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c19(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_5INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c21(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c15(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_6lineContent() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_6lineChar();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_6lineChar();
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_6lineChar() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_6INDENT();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_6DEDENT();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_6TERM();
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c22(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_6INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c21(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c15(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c23);
          }
        }

        return s0;
      }

      function peg$parse_6DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c14(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c15(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        return s0;
      }

      function peg$parse_6TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c8(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        return s0;
      }

      function peg$parse_7comment() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c27;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_7commentContent();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c3();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }

        return s0;
      }

      function peg$parse_7commentContent() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parse_6lineContent();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_7TERM();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$currPos;
            s5 = peg$parse_5indentation();

            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$parse_7commentContent();

              if (s7 !== peg$FAILED) {
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parse_7commentContent();
                }
              } else {
                s6 = peg$FAILED;
              }

              if (s6 !== peg$FAILED) {
                s7 = peg$parse_3anyDedent();

                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$currPos;
              s5 = peg$parse_5indentation();

              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parse_7commentContent();

                if (s7 !== peg$FAILED) {
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parse_7commentContent();
                  }
                } else {
                  s6 = peg$FAILED;
                }

                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_3anyDedent();

                  if (s7 !== peg$FAILED) {
                    s5 = [s5, s6, s7];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c3();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_7TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c8(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c29);
          }
        }

        return s0;
      }

      function peg$parse_8else() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 61) {
          s2 = peg$c30;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c31);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_1start();

          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;

          if (input.substr(peg$currPos, 4) === peg$c32) {
            s3 = peg$c32;
            peg$currPos += 4;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c33);
            }
          }

          if (s3 !== peg$FAILED) {
            s4 = peg$parse_1start();

            if (s4 !== peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c34) {
                s5 = peg$c34;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c35);
                }
              }

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s3 = [s3, s4, s5];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c36(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_9equalSign() {
        var s0, s1, s2;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c37) {
          s1 = peg$c37;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 32) {
            s2 = peg$c39;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c40);
            }
          }

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c41();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 61) {
            s1 = peg$c30;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 32) {
              s2 = peg$c39;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c40);
              }
            }

            if (s2 === peg$FAILED) {
              s2 = null;
            }

            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c42();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_10inlineComment() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 47) {
            s2 = peg$c27;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_6lineContent();

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c44;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c46.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c47);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c46.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c47);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c48(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c43);
          }
        }

        return s0;
      }

      function peg$parse_12rawMustache() {
        var s0;
        s0 = peg$parse_12rawMustacheUnescaped();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustacheEscaped();
        }

        return s0;
      }

      function peg$parse_12rawMustacheUnescaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12tripleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12tripleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c49(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_12rawMustacheEscaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12doubleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12doubleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c50(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_12hashStacheOpen();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_1start();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_11nonMustache();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_1start();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_12hashStacheClose();

                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c50(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_12doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c52) {
          s0 = peg$c52;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c53);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c51);
          }
        }

        return s0;
      }

      function peg$parse_12tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c55) {
          s0 = peg$c55;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c56);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c54);
          }
        }

        return s0;
      }

      function peg$parse_12doubleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c58) {
          s0 = peg$c58;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c59);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c57);
          }
        }

        return s0;
      }

      function peg$parse_12tripleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c61) {
          s0 = peg$c61;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c62);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c60);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c64) {
          s0 = peg$c64;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c63);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c67;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c68);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c66);
          }
        }

        return s0;
      }

      function peg$parse_13nonMustacheUnit() {
        var s0;
        s0 = peg$parse_13tripleOpen();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_13doubleOpen();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_13hashStacheOpen();

            if (s0 === peg$FAILED) {
              s0 = peg$parse_3anyDedent();

              if (s0 === peg$FAILED) {
                s0 = peg$parse_13TERM();
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_13singleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s0 = peg$c44;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c69);
          }
        }

        return s0;
      }

      function peg$parse_13doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c52) {
          s0 = peg$c52;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c53);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c70);
          }
        }

        return s0;
      }

      function peg$parse_13tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c55) {
          s0 = peg$c55;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c56);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c71);
          }
        }

        return s0;
      }

      function peg$parse_13hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c64) {
          s0 = peg$c64;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c72);
          }
        }

        return s0;
      }

      function peg$parse_13TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c8(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c73);
          }
        }

        return s0;
      }

      function peg$parse_14textNodes() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_14preMustacheText();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_14preMustacheText();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_14preMustacheText();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_14TERM();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c74(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_14preMustacheText() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_14preMustacheUnit();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_14preMustacheUnit();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_14preMustacheUnit() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();
        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c22(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_14TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c8(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c75);
          }
        }

        return s0;
      }

      function peg$parse_15whitespaceableTextNodes() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_5indentation();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_14textNodes();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_15whitespaceableTextNodes();

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_15whitespaceableTextNodes();
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_3anyDedent();

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c76(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_14textNodes();
        }

        return s0;
      }

      function peg$parse_16textLine() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parse_16textLineStart();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_14textNodes();

          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parse_5indentation();

            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parse_15whitespaceableTextNodes();

              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parse_15whitespaceableTextNodes();
              }

              if (s5 !== peg$FAILED) {
                s6 = peg$parse_16DEDENT();

                if (s6 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c77(s1, s2, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c78(s1, s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_16textLineStart() {
        var s0, s1, s2;
        s0 = peg$currPos;

        if (peg$c79.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c80);
          }
        }

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 32) {
            s2 = peg$c39;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c40);
            }
          }

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c19(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;

          if (input.charCodeAt(peg$currPos) === 60) {
            s2 = peg$c81;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }

          peg$silentFails--;

          if (s2 !== peg$FAILED) {
            peg$currPos = s1;
            s1 = void 0;
          } else {
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c83();
          }

          s0 = s1;
        }

        return s0;
      }

      function peg$parse_16DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c14(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c15(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c84);
          }
        }

        return s0;
      }

      function peg$parse_17pathIdNode() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_17path();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c85(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_17path() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_17pathIdent();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_17separator();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_17pathIdent();

            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c86(s1, s4, s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_17separator();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_17pathIdent();

              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c86(s1, s4, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c87(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_17pathIdent() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c89) {
          s0 = peg$c89;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c90);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s0 = peg$c91;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c92);
            }
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];

            if (peg$c93.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c94);
              }
            }

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c93.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c94);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s1 = input.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }

            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c30;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c31);
                }
              }

              peg$silentFails--;

              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }

              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c19(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c95;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c96);
                }
              }

              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];

                if (peg$c97.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c98);
                  }
                }

                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c97.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c98);
                    }
                  }
                }

                if (s3 !== peg$FAILED) {
                  s2 = input.substring(s2, peg$currPos);
                } else {
                  s2 = s3;
                }

                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c99;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c100);
                    }
                  }

                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c101(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c88);
          }
        }

        return s0;
      }

      function peg$parse_17separator() {
        var s0, s1;
        peg$silentFails++;

        if (peg$c103.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c104);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c102);
          }
        }

        return s0;
      }

      function peg$parse_18nonSeparatorColon() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 58) {
          s1 = peg$c105;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c106);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;

          if (input.charCodeAt(peg$currPos) === 32) {
            s3 = peg$c39;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c40);
            }
          }

          peg$silentFails--;

          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c22(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_19tagString() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_19tagChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_19tagChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c107);
          }
        }

        return s0;
      }

      function peg$parse_19tagChar() {
        var s0;

        if (peg$c108.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c109);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 64) {
              s0 = peg$c110;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c111);
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_20stringWithQuotes() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_20singleQuoteString();

        if (s1 === peg$FAILED) {
          s1 = peg$parse_20doubleQuoteString();
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c112(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_20singleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c113;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c114);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashSingleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c113;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c114);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20doubleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c115;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c116);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashDoubleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c115;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c116);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c113;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c114);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c117);
          }
        }

        return s0;
      }

      function peg$parse_20closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c113;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c114);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c118);
          }
        }

        return s0;
      }

      function peg$parse_20hashDoubleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c120.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c121);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c120.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c121);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c119);
          }
        }

        return s0;
      }

      function peg$parse_20hashSingleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c122.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c123);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c122.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c123);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c119);
          }
        }

        return s0;
      }

      function peg$parse_20TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c8(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c124);
          }
        }

        return s0;
      }

      function peg$parse_21singleMustacheValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c44;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_21mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c125(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_21mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c67;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c68);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c126);
          }
        }

        return s0;
      }

      function peg$parse_22actionAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_22knownAliasEvent();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c30;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_22actionValue();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c127(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_22knownAliasEvent() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_19tagString();

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c129(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c130(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c128);
          }
        }

        return s0;
      }

      function peg$parse_22actionValue() {
        var s0, s1;
        s0 = peg$parse_20stringWithQuotes();

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_17pathIdNode();

          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c131(s1);
          }

          s0 = s1;

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_21singleMustacheValue();

            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c132(s1);
            }

            s0 = s1;
          }
        }

        return s0;
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c108.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c109);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c133.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c134);
          }
        }

        return s0;
      }

      function peg$parse_24key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c105;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c106);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c91;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c92);
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c105;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c106);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c91;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c92);
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c135);
          }
        }

        return s0;
      }

      function peg$parse_25booleanAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_24key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c30;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c136) {
              s3 = peg$c136;
              peg$currPos += 4;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c137);
              }
            }

            if (s3 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c138) {
                s3 = peg$c138;
                peg$currPos += 5;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c139);
                }
              }
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c140(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_26key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c105;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c106);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c91;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c92);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s2 = peg$c110;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c111);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 36) {
                  s2 = peg$c142;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c143);
                  }
                }
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c105;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c106);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c91;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c92);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 64) {
                  s2 = peg$c110;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c111);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s2 = peg$c142;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c143);
                    }
                  }
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c141);
          }
        }

        return s0;
      }

      function peg$parse_27booleanAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c30;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_27digits();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c144(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_27digits() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];

        if (peg$c146.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c147);
          }
        }

        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);

            if (peg$c146.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c147);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c145);
          }
        }

        return s0;
      }

      function peg$parse_28boundAttributeWithSingleMustache() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c30;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_21singleMustacheValue();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c148(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_29newMustacheNameChar() {
        var s0;

        if (peg$c149.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c150);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_29arrayIndex();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s0 = peg$c91;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c92);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s0 = peg$c110;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c111);
                }
              }

              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c151) {
                  s0 = peg$c151;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c152);
                  }
                }

                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s0 = peg$c142;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c143);
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_29arrayIndex() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c153) {
          s1 = peg$c153;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c154);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_29newMustacheNameChar();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_29newMustacheNameChar();
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c99;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c100);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_30boundAttribute() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c30;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_30boundAttributeValue();

            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 33) {
                s5 = peg$c155;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c156);
                }
              }

              peg$silentFails--;

              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c157(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_30boundAttributeValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c44;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parse_30boundAttributeValueChar();

            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 32) {
                s5 = peg$c39;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c40);
                }
              }
            }

            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parse_30boundAttributeValueChar();

                if (s5 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 32) {
                    s5 = peg$c39;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c40);
                    }
                  }
                }
              }
            } else {
              s4 = peg$FAILED;
            }

            if (s4 !== peg$FAILED) {
              s3 = input.substring(s3, peg$currPos);
            } else {
              s3 = s4;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_30mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c158(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_30boundAttributeValueChar();

          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parse_30boundAttributeValueChar();
            }
          } else {
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        return s0;
      }

      function peg$parse_30boundAttributeValueChar() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_29newMustacheNameChar();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c159);
          }
        }

        return s0;
      }

      function peg$parse_30mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c67;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c68);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c160);
          }
        }

        return s0;
      }

      function peg$parse_31normalAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c30;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_31attributeTextNodes();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c161(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31attributeTextNodes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c115;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c116);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_31attributeTextNodesInner();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_31closingDoubleQuote();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c162(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c113;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c114);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_31attributeTextNodesInnerSingle();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_31closingSingleQuote();

              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c162(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_31closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c113;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c114);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c163);
          }
        }

        return s0;
      }

      function peg$parse_31closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 34) {
          s0 = peg$c115;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c116);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c164);
          }
        }

        return s0;
      }

      function peg$parse_31attributeTextNodesInner() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_31preAttrMustacheText();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_31preAttrMustacheText();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_31preAttrMustacheText();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c74(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31attributeTextNodesInnerSingle() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_31preAttrMustacheTextSingle();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_31preAttrMustacheTextSingle();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_31preAttrMustacheTextSingle();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c74(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheText() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_31preAttrMustacheUnit();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_31preAttrMustacheUnit();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheTextSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_31preAttrMustacheUnitSingle();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_31preAttrMustacheUnitSingle();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheUnit() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c115;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c116);
            }
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c22(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c165);
          }
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheUnitSingle() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c113;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c114);
            }
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c22(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c165);
          }
        }

        return s0;
      }

      function peg$parse_32simpleMustacheAttr() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c30;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_17pathIdNode();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c166(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_33spreadAttribute() {
        var s0, s1;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 13) === peg$c167) {
          s1 = peg$c167;
          peg$currPos += 13;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c168);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c169(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_34attribute() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_22actionAttribute();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_25booleanAttribute();

            if (s2 === peg$FAILED) {
              s2 = peg$parse_27booleanAttribute();

              if (s2 === peg$FAILED) {
                s2 = peg$parse_28boundAttributeWithSingleMustache();

                if (s2 === peg$FAILED) {
                  s2 = peg$parse_30boundAttribute();

                  if (s2 === peg$FAILED) {
                    s2 = peg$parse_31normalAttribute();

                    if (s2 === peg$FAILED) {
                      s2 = peg$parse_32simpleMustacheAttr();

                      if (s2 === peg$FAILED) {
                        s2 = peg$parse_33spreadAttribute();
                      }
                    }
                  }
                }
              }
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c170(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_35bracketedAttribute() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_35INDENT();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_35INDENT();
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_34attribute();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_35TERM();

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_35TERM();
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c171(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_35TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c8(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c172);
          }
        }

        return s0;
      }

      function peg$parse_35INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c21(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c15(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c173);
          }
        }

        return s0;
      }

      function peg$parse_36cssIdentifier() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_36ident();
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c174);
          }
        }

        return s0;
      }

      function peg$parse_36ident() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_23nmchar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_37idShorthand() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c176;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c177);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_36cssIdentifier();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c178(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c175);
          }
        }

        return s0;
      }

      function peg$parse_38classShorthand() {
        var s0, s1, s2;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c91;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c92);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_36cssIdentifier();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c22(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_39shorthandAttributes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parse_37idShorthand();

        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c179(s3);
        }

        s2 = s3;

        if (s2 === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parse_38classShorthand();

          if (s3 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c180(s3);
          }

          s2 = s3;
        }

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parse_37idShorthand();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c179(s3);
            }

            s2 = s3;

            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parse_38classShorthand();

              if (s3 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c180(s3);
              }

              s2 = s3;
            }
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c181(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_40inTagMustache() {
        var s0;
        s0 = peg$parse_40builtSingle();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustache();
        }

        return s0;
      }

      function peg$parse_40builtSingle() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_21singleMustacheValue();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c182(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_41tagHtml() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
        s0 = peg$currPos;
        s1 = peg$parse_41htmlStart();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_40inTagMustache();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_40inTagMustache();
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_4start();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 91) {
                s4 = peg$c95;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c96);
                }
              }

              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parse_41TERM();

                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parse_41TERM();
                }

                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parse_40inTagMustache();

                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parse_40inTagMustache();
                  }

                  if (s6 !== peg$FAILED) {
                    s7 = [];
                    s8 = peg$parse_35bracketedAttribute();

                    if (s8 !== peg$FAILED) {
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        s8 = peg$parse_35bracketedAttribute();
                      }
                    } else {
                      s7 = peg$FAILED;
                    }

                    if (s7 !== peg$FAILED) {
                      s8 = [];
                      s9 = peg$currPos;
                      s10 = peg$parse_1start();

                      if (s10 !== peg$FAILED) {
                        s11 = peg$parse_10inlineComment();

                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_1start();

                          if (s12 !== peg$FAILED) {
                            s13 = peg$parse_41TERM();

                            if (s13 !== peg$FAILED) {
                              s10 = [s10, s11, s12, s13];
                              s9 = s10;
                            } else {
                              peg$currPos = s9;
                              s9 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }

                      while (s9 !== peg$FAILED) {
                        s8.push(s9);
                        s9 = peg$currPos;
                        s10 = peg$parse_1start();

                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_10inlineComment();

                          if (s11 !== peg$FAILED) {
                            s12 = peg$parse_1start();

                            if (s12 !== peg$FAILED) {
                              s13 = peg$parse_41TERM();

                              if (s13 !== peg$FAILED) {
                                s10 = [s10, s11, s12, s13];
                                s9 = s10;
                              } else {
                                peg$currPos = s9;
                                s9 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s9;
                              s9 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      }

                      if (s8 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c183(s1, s2, s6, s7);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_41htmlStart();

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parse_40inTagMustache();

            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parse_40inTagMustache();
            }

            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parse_34attribute();

              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_34attribute();
              }

              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c184(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_41htmlStart() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_41knownTagName();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_39shorthandAttributes();

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s3 = peg$c27;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = peg$currPos;
              s4 = peg$c185(s1, s2);

              if (s4) {
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                s1 = [s1, s2, s3, s4];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_41knownTagName() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_19tagString();

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c186(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c187(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_41TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c8(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c188);
          }
        }

        return s0;
      }

      function peg$parse_41INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c21(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c15(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c189);
          }
        }

        return s0;
      }

      function peg$parse_42blockStart() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c190) {
          s1 = peg$c190;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c191);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_42blockStartPipe();

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_42blockStartPipe() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c193;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c194);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c192);
          }
        }

        return s0;
      }

      function peg$parse_43quotedString() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s2 = peg$c115;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c116);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_43stringWithoutDouble();

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s4 = peg$c115;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c116);
              }
            }

            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c113;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c114);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_43stringWithoutSingle();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s4 = peg$c113;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c114);
                }
              }

              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c195);
          }
        }

        return s0;
      }

      function peg$parse_43stringWithoutDouble() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c113;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c114);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c113;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c114);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43stringWithoutSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c115;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c116);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s2 = peg$c115;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c116);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43inStringChar() {
        var s0;

        if (peg$c196.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c197);
          }
        }

        return s0;
      }

      function peg$parse_44newMustacheAttrValue() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_44invalidValueStartChar();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_42blockStart();
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_43quotedString();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_44valuePath();
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_1start();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c198(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_44valuePath() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_29newMustacheNameChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_29newMustacheNameChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_44invalidValueStartChar() {
        var s0;

        if (peg$c199.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c200);
          }
        }

        return s0;
      }

      function peg$parse_45blockEnd() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c193;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c194);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c201);
          }
        }

        return s0;
      }

      function peg$parse_46blockParams() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_42blockStart();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_46blockParamName();

            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_46blockParamName();
              }
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_45blockEnd();

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c202(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_46blockParamName() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_44newMustacheAttrValue();
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c203);
          }
        }

        return s0;
      }

      function peg$parse_47inHtmlTag() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parse_47htmlStart();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_47blockParams();

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_4start();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 91) {
                s4 = peg$c95;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c96);
                }
              }

              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parse_47TERM();

                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parse_47TERM();
                }

                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parse_40inTagMustache();

                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parse_40inTagMustache();
                  }

                  if (s6 !== peg$FAILED) {
                    s7 = [];
                    s8 = peg$parse_35bracketedAttribute();

                    while (s8 !== peg$FAILED) {
                      s7.push(s8);
                      s8 = peg$parse_35bracketedAttribute();
                    }

                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c204(s1, s2, s6, s7);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_47htmlStart();

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parse_40inTagMustache();

            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parse_40inTagMustache();
            }

            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parse_34attribute();

              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_34attribute();
              }

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_47blockParams();

                if (s4 === peg$FAILED) {
                  s4 = null;
                }

                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c205(s1, s2, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_47htmlStart() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_47componentTag();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_39shorthandAttributes();

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s3 = peg$c27;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = peg$currPos;
              s4 = peg$c206(s1, s2);

              if (s4) {
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                s1 = [s1, s2, s3, s4];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_47componentTag() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 37) {
          s1 = peg$c207;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c208);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_19tagString();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c209(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_47blockParams() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_46blockParams();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c202(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_47TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c8(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c210);
          }
        }

        return s0;
      }

      function peg$parse_47INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c21(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c15(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c211);
          }
        }

        return s0;
      }

      function peg$parse_48start() {
        var s0;
        s0 = peg$parse_41tagHtml();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_47inHtmlTag();
        }

        return s0;
      }

      function peg$parse_49htmlNestedTextNodes() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 32) {
          s1 = peg$c39;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_14textNodes();

          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parse_5indentation();

            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parse_15whitespaceableTextNodes();

              if (s6 !== peg$FAILED) {
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parse_15whitespaceableTextNodes();
                }
              } else {
                s5 = peg$FAILED;
              }

              if (s5 !== peg$FAILED) {
                s6 = peg$parse_49DEDENT();

                if (s6 !== peg$FAILED) {
                  s4 = [s4, s5, s6];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c212(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_49DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c14(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c15(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c213);
          }
        }

        return s0;
      }

      function peg$parse_50mustacheAttrs() {
        var s0, s1;
        s0 = peg$parse_50bracketedAttrs();

        if (s0 === peg$FAILED) {
          s0 = [];
          s1 = peg$parse_50mustacheAttr();

          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parse_50mustacheAttr();
          }
        }

        return s0;
      }

      function peg$parse_50bracketedAttrs() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_44newMustacheAttrValue();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_50openBracket();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_50bracketedAttr();

            if (s4 === peg$FAILED) {
              s4 = peg$parse_50commentWithSpace();

              if (s4 === peg$FAILED) {
                s4 = peg$parse_2blankLine();
              }
            }

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_50bracketedAttr();

              if (s4 === peg$FAILED) {
                s4 = peg$parse_50commentWithSpace();

                if (s4 === peg$FAILED) {
                  s4 = peg$parse_2blankLine();
                }
              }
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parse_50closeBracket();
              peg$silentFails--;

              if (s5 !== peg$FAILED) {
                peg$currPos = s4;
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c214(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50commentWithSpace() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parse_1start();

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_7comment();

          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c3();
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_50bracketedAttr() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_50mustacheAttr();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_50TERM();

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c215(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50openBracket() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c95;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c96);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_10inlineComment();

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parse_50TERM();

              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parse_50TERM();
                }
              } else {
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_50INDENT();

                if (s5 !== peg$FAILED) {
                  s1 = [s1, s2, s3, s4, s5];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50closeBracket() {
        var s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_50DEDENT();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c99;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c100);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c216);
          }
        }

        return s0;
      }

      function peg$parse_50mustacheAttr() {
        var s0;
        s0 = peg$parse_50mustacheKeyValue();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_50subexpression();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_44newMustacheAttrValue();
          }
        }

        return s0;
      }

      function peg$parse_50mustacheKeyValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c30;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c31);
              }
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_50subexpression();

                if (s5 === peg$FAILED) {
                  s5 = peg$parse_44newMustacheAttrValue();
                }

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c217(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50subexpression() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s2 = peg$c218;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c219);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_1start();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_44newMustacheAttrValue();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_1start();

                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_50subexpressionBracketAttrs();

                  if (s6 === peg$FAILED) {
                    s6 = [];
                    s7 = peg$parse_50subexpressionAttrs();

                    if (s7 !== peg$FAILED) {
                      while (s7 !== peg$FAILED) {
                        s6.push(s7);
                        s7 = peg$parse_50subexpressionAttrs();
                      }
                    } else {
                      s6 = peg$FAILED;
                    }
                  }

                  if (s6 === peg$FAILED) {
                    s6 = null;
                  }

                  if (s6 !== peg$FAILED) {
                    s7 = peg$parse_50subexpressionClose();

                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse_1start();

                      if (s8 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c220(s4, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50subexpressionClose() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s2 = peg$c222;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c223);
            }
          }

          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c221);
          }
        }

        return s0;
      }

      function peg$parse_50subexpressionBracketAttrs() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_50bracketedAttrs();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_50closeBracket();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c225(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c224);
          }
        }

        return s0;
      }

      function peg$parse_50subexpressionAttrs() {
        var s0;
        s0 = peg$parse_50mustacheKeyValue();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_50subexpression();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_44newMustacheAttrValue();
          }
        }

        return s0;
      }

      function peg$parse_50INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c21(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c15(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c226);
          }
        }

        return s0;
      }

      function peg$parse_50DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c14(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c15(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c227);
          }
        }

        return s0;
      }

      function peg$parse_50TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c8(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c228);
          }
        }

        return s0;
      }

      function peg$parse_51newMustacheShortHand() {
        var s0;
        s0 = peg$parse_51shortHandTagName();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_51shortHandIdName();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_51shortHandClassName();
          }
        }

        return s0;
      }

      function peg$parse_51shortHandTagName() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 37) {
          s1 = peg$c207;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c208);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_51newMustacheShortHandName();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c230(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c229);
          }
        }

        return s0;
      }

      function peg$parse_51shortHandIdName() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c176;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c177);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_51newMustacheShortHandName();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c232(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c231);
          }
        }

        return s0;
      }

      function peg$parse_51shortHandClassName() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c91;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c92);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_51newMustacheShortHandName();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c234(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c233);
          }
        }

        return s0;
      }

      function peg$parse_51newMustacheShortHandName() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];

        if (peg$c235.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c236);
          }
        }

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);

            if (peg$c235.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c236);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_52modifierChar() {
        var s0;
        s0 = peg$parse_52unboundChar();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_52conditionalChar();
        }

        return s0;
      }

      function peg$parse_52unboundChar() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 33) {
          s0 = peg$c155;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c156);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c237);
          }
        }

        return s0;
      }

      function peg$parse_52conditionalChar() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 63) {
          s0 = peg$c239;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c240);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c238);
          }
        }

        return s0;
      }

      function peg$parse_53newMustache() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_53newMustacheStart();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_50mustacheAttrs();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_46blockParams();

              if (s4 === peg$FAILED) {
                s4 = null;
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c241(s1, s3, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_53newMustacheStart() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_53newMustacheName();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_51newMustacheShortHand();

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_51newMustacheShortHand();
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c242(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_53newMustacheName() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_53invalidNameStartChar();
        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];
          s4 = peg$parse_29newMustacheNameChar();

          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_29newMustacheNameChar();
            }
          } else {
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_52modifierChar();

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c243(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_53invalidNameStartChar() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 46) {
          s0 = peg$c91;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c92);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s0 = peg$c245;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c246);
            }
          }

          if (s0 === peg$FAILED) {
            if (peg$c146.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c147);
              }
            }
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c244);
          }
        }

        return s0;
      }

      function peg$parse_54start() {
        var s0;
        s0 = peg$parse_54program();
        return s0;
      }

      function peg$parse_54program() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_54content();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c247(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_54content() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_54statement();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_54statement();
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c248(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_54statement() {
        var s0;
        s0 = peg$parse_2blankLine();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_7comment();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_54contentStatement();
          }
        }

        return s0;
      }

      function peg$parse_54contentStatement() {
        var s0;
        s0 = peg$parse_54htmlElement();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_16textLine();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_54mustache();
          }
        }

        return s0;
      }

      function peg$parse_54colonContent() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c249) {
          s1 = peg$c249;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c250);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_54contentStatement();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c22(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_54htmlElement() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_48start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_54htmlTerminator();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c251(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_54htmlTerminator() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$parse_54colonContent();

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_1start();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_54explicitMustache();

            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c252(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_1start();

            if (s1 !== peg$FAILED) {
              s2 = peg$parse_10inlineComment();

              if (s2 === peg$FAILED) {
                s2 = null;
              }

              if (s2 !== peg$FAILED) {
                s3 = peg$parse_54TERM();

                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_54indentedContent();

                  if (s4 === peg$FAILED) {
                    s4 = null;
                  }

                  if (s4 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c253(s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parse_1start();

              if (s1 !== peg$FAILED) {
                s2 = peg$parse_10inlineComment();

                if (s2 === peg$FAILED) {
                  s2 = null;
                }

                if (s2 !== peg$FAILED) {
                  s3 = peg$parse_54DEDENT();

                  if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s4 = peg$c99;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;

                      if (peg$silentFails === 0) {
                        peg$fail(peg$c100);
                      }
                    }

                    if (s4 !== peg$FAILED) {
                      s5 = peg$parse_54TERM();

                      if (s5 !== peg$FAILED) {
                        s6 = peg$parse_54indentedContent();

                        if (s6 === peg$FAILED) {
                          s6 = null;
                        }

                        if (s6 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c253(s6);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parse_1start();

                if (s1 !== peg$FAILED) {
                  s2 = peg$parse_10inlineComment();

                  if (s2 === peg$FAILED) {
                    s2 = null;
                  }

                  if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s3 = peg$c99;
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;

                      if (peg$silentFails === 0) {
                        peg$fail(peg$c100);
                      }
                    }

                    if (s3 !== peg$FAILED) {
                      s4 = peg$parse_54TERM();

                      if (s4 !== peg$FAILED) {
                        s5 = peg$parse_54unindentedContent();

                        if (s5 === peg$FAILED) {
                          s5 = null;
                        }

                        if (s5 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c253(s5);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }

                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parse_1start();

                  if (s1 !== peg$FAILED) {
                    s2 = peg$parse_10inlineComment();

                    if (s2 === peg$FAILED) {
                      s2 = null;
                    }

                    if (s2 !== peg$FAILED) {
                      s3 = peg$parse_54DEDENT();

                      if (s3 === peg$FAILED) {
                        s3 = null;
                      }

                      if (s3 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                          s4 = peg$c99;
                          peg$currPos++;
                        } else {
                          s4 = peg$FAILED;

                          if (peg$silentFails === 0) {
                            peg$fail(peg$c100);
                          }
                        }

                        if (s4 !== peg$FAILED) {
                          s5 = peg$parse_54TERM();

                          if (s5 !== peg$FAILED) {
                            s1 = [s1, s2, s3, s4, s5];
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }

                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parse_49htmlNestedTextNodes();

                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c254(s1);
                    }

                    s0 = s1;
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_54indentedContent() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_2blankLine();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_2blankLine();
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_5indentation();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_54content();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_54DEDENT();

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c22(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_54unindentedContent() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_2blankLine();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_2blankLine();
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_54content();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_54DEDENT();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c22(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_54mustache() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_54explicitMustache();

        if (s1 === peg$FAILED) {
          s1 = peg$parse_54lineStartingMustache();
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c255(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_54explicitMustache() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_9equalSign();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_54mustacheOrBlock();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c256(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_54lineStartingMustache() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_54capitalizedLineStarterMustache();

        if (s1 === peg$FAILED) {
          s1 = peg$parse_54mustacheOrBlock();
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c257(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_54capitalizedLineStarterMustache() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (peg$c258.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c259);
          }
        }

        peg$silentFails--;

        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_54mustacheOrBlock();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c260(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_54mustacheOrBlock() {
        var s0;
        s0 = peg$parse_54mustacheWithBlock();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_54mustacheWithBracketsAndBlock();
        }

        return s0;
      }

      function peg$parse_54mustacheWithBlock() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_54mustacheContent();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_10inlineComment();

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_54mustacheBasicNested();

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c261(s1, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_54mustacheContent() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_53newMustache();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_10inlineComment();

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c262(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_54mustacheBasicNested() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parse_54colonContent();

        if (s1 === peg$FAILED) {
          s1 = peg$parse_16textLine();
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c263(s1);
        }

        s0 = s1;

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_54TERM();

          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = [];
            s4 = peg$parse_2blankLine();

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_2blankLine();
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_5indentation();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_54contentWithElse();

                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_54DEDENT();

                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c264(s5);
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }

            if (s2 === peg$FAILED) {
              s2 = null;
            }

            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c265(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_54mustacheWithBracketsAndBlock() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_54mustacheContentWithBracketStart();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_10inlineComment();

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_54mustacheEndBracketAndNested();

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c261(s1, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_54mustacheContentWithBracketStart() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 91) {
          s3 = peg$c95;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c96);
          }
        }

        if (s3 !== peg$FAILED) {
          s4 = peg$parse_54TERM();

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_53newMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_10inlineComment();

              if (s4 === peg$FAILED) {
                s4 = null;
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c266(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_54mustacheEndBracketAndNested() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s2 = peg$c99;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c100);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_1start();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_46blockParams();

              if (s4 === peg$FAILED) {
                s4 = null;
              }

              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parse_54TERM();

                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parse_54TERM();
                  }
                } else {
                  s5 = peg$FAILED;
                }

                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_54contentWithElse();

                  if (s6 !== peg$FAILED) {
                    s7 = peg$parse_54DEDENT();

                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c267(s4, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_1start();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_54DEDENT();

            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c99;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c100);
                }
              }

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_1start();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_46blockParams();

                  if (s5 === peg$FAILED) {
                    s5 = null;
                  }

                  if (s5 !== peg$FAILED) {
                    s6 = [];
                    s7 = peg$parse_54TERM();

                    if (s7 !== peg$FAILED) {
                      while (s7 !== peg$FAILED) {
                        s6.push(s7);
                        s7 = peg$parse_54TERM();
                      }
                    } else {
                      s6 = peg$FAILED;
                    }

                    if (s6 !== peg$FAILED) {
                      s7 = peg$parse_54INDENT();

                      if (s7 !== peg$FAILED) {
                        s8 = peg$parse_1start();

                        if (s8 !== peg$FAILED) {
                          s9 = peg$parse_54contentWithElse();

                          if (s9 !== peg$FAILED) {
                            s10 = peg$parse_54DEDENT();

                            if (s10 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c267(s5, s9);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_1start();

            if (s1 !== peg$FAILED) {
              s2 = peg$parse_54DEDENT();

              if (s2 === peg$FAILED) {
                s2 = null;
              }

              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c99;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c100);
                  }
                }

                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_54TERM();

                  if (s4 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c268();
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }

        return s0;
      }

      function peg$parse_54contentWithElse() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_54content();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_54invertibleObject();

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c269(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_54invertibleObject() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parse_54DEDENT();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_7comment();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_7comment();
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_8else();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_54invertibleParam();

                if (s5 === peg$FAILED) {
                  s5 = null;
                }

                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_54TERM();

                  if (s6 !== peg$FAILED) {
                    s7 = peg$parse_54invertibleBlock();

                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse_54invertibleObject();

                      if (s8 === peg$FAILED) {
                        s8 = null;
                      }

                      if (s8 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c270(s3, s5, s7, s8);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_54invertibleParam() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_50mustacheAttrs();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_10inlineComment();

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c271(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_54invertibleBlock() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_2blankLine();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_2blankLine();
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_5indentation();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_54content();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c22(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_54INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c21(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c15(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c272);
          }
        }

        return s0;
      }

      function peg$parse_54DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c14(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c15(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c273);
          }
        }

        return s0;
      }

      function peg$parse_54TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c8(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c274);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      function parseInHtml(h, inTagMustaches, fullAttributes, blockParams) {
        var tagName = h[0] || 'div',
            shorthandAttributes = h[1] || [],
            id = shorthandAttributes[0],
            classes = shorthandAttributes[1] || [];
        var i, l;
        var elementNode = builder.generateElement(tagName);
        builder.enter(elementNode);

        for (i = 0, l = classes.length; i < l; i++) {
          if (classes[i].type === 'classNameBinding') {
            builder.add('classNameBindings', classes[i]);
          } else {
            builder.classNameBinding(':' + classes[i]);
          }
        }

        if (id) {
          builder.attribute('id', id);
        }

        for (i = 0; i < inTagMustaches.length; ++i) {
          builder.add('attrStaches', inTagMustaches[i]);
        }

        for (i = 0; i < fullAttributes.length; ++i) {
          var currentAttr = fullAttributes[i];

          if (Array.isArray(currentAttr) && typeof currentAttr[0] === 'string') {
            // a "normalAttribute", [attrName, attrContent]
            if (currentAttr.length) {
              // a boolean false attribute will be []
              // skip classes now, coalesce them later
              if (currentAttr[0] === 'class') {
                builder.classNameBinding(':' + currentAttr[1]);
              } else {
                builder.attribute(currentAttr[0], currentAttr[1]);
              }
            }
          } else if (Array.isArray(currentAttr)) {
            currentAttr.forEach(function (attrNode) {
              builder.add(attrNode.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', attrNode);
            });
          } else {
            builder.add(currentAttr.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', currentAttr);
          }
        }

        if (blockParams && blockParams.length > 0) {
          var joinedParams = blockParams.join(' ');
          var tagString = 'as |' + joinedParams + '|';
          builder.inTagText(tagString);
        }
      }

      function isKnownTag(tag) {
        return !!_tags.default[tag];
      }

      var builder = options.builder;
      var UNBOUND_MODIFIER = '!';
      var CONDITIONAL_MODIFIER = '?';

      function logDeprecation(message) {
        if (!options.quiet) {
          var output = 'DEPRECATION: ' + message;

          if (options.file) {
            output += '\nFile: ' + options.file;
          }

          console.log(output);
        }
      }

      function flattenArray(first, tail) {
        var ret = [];

        if (first) {
          ret.push(first);
        }

        for (var i = 0; i < tail.length; ++i) {
          var t = tail[i];
          ret.push(t[0]);

          if (t[1]) {
            ret.push(t[1]);
          }
        }

        return ret;
      }
      /**
        Splits a value string into separate parts,
        then generates a classBinding for each part.
      */


      function splitValueIntoClassBindings(value) {
        return value.split(' ').map(function (v) {
          return builder.generateClassNameBinding(v);
        });
      }

      function isArray(obj) {
        return obj && obj.constructor === Array;
      } // Receives an array object and verifies it has content
      // Useful for checking blocks to make sure there is actual data in the payload


      function isArrayWithContent(obj) {
        if (!isArray(obj)) return;
        var hasItems = false;
        var length = obj.length;

        for (var i = 0; i < length; i++) {
          var item = obj[i];

          if (isArray(item)) {
            if (item.length > 0) hasItems = true;
          } else if (!!item) {
            hasItems = true;
          }
        }

        return hasItems;
      }
      /**
        @param [<<>, {}>] mustacheTuple
        @return
      */


      function createBlockOrMustache(mustacheTuple) {
        var mustache = mustacheTuple[0];
        var block = mustacheTuple[1] || {};
        var escaped = mustache.isEscaped;
        var mustacheContent = mustache.name;
        var mustacheAttrs = mustache.attrs;
        var mustacheBlockParams = mustache.blockParams || block.blockParams;
        var blockTuple = block.blockTuple;

        if (mustacheAttrs.length) {
          var attrs = coalesceAttrs(mustacheAttrs);
          mustacheContent += ' ' + attrs.join(' ');
        }

        if (mustacheBlockParams) {
          mustacheContent += ' as |' + mustacheBlockParams.join(' ') + '|';
        }

        if (mustache.isViewHelper) {
          mustacheContent = 'view ' + mustacheContent;
        }

        if (mustache.modifier === UNBOUND_MODIFIER) {
          logDeprecation('Unbound modifier is deprecated');
          mustacheContent = 'unbound ' + mustacheContent;
        } else if (mustache.modifier === CONDITIONAL_MODIFIER) {
          mustacheContent = 'if ' + mustacheContent;
        }

        if (isArrayWithContent(blockTuple)) {
          var block = builder.generateBlock(mustacheContent, escaped);
          builder.enter(block); // Iterate on each tuple and either add it as a child node or an invertible node

          blockTuple.forEach(function (tuple) {
            if (!tuple) return;
            if (tuple.isInvertible) builder.add('invertibleNodes', tuple);else builder.add('childNodes', tuple);
          });
          return builder.exit();
        } else {
          return builder.generateMustache(mustacheContent, escaped);
        }
      } // attrs are simple strings,
      // combine all the ones that start with 'class='


      function coalesceAttrs(attrs) {
        var classes = [];
        var newAttrs = [];
        var classRegex = /^class="(.*)"$/;
        var match;

        for (var i = 0, l = attrs.length; i < l; i++) {
          var attr = attrs[i];

          if (match = attr.match(classRegex)) {
            classes.push(match[1]);
          } else {
            newAttrs.push(attr);
          }
        }

        if (classes.length) {
          newAttrs.push('class="' + classes.join(' ') + '"');
        }

        return newAttrs;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/any-dedent", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _3start: peg$parse_3start
      },
          peg$startRuleFunction = peg$parse_3start,
          peg$c0 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c1 = peg$otherExpectation("_3DEDENT"),
          peg$c2 = peg$anyExpectation(),
          peg$c3 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c4 = function (t) {
        return '';
      },
          peg$c5 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c6 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_3start() {
        var s0;
        s0 = peg$parse_3anyDedent();
        return s0;
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c3(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c6(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/blank-line", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _2start: peg$parse_2start
      },
          peg$startRuleFunction = peg$parse_2start,
          peg$c0 = /^[ \t]/,
          peg$c1 = peg$classExpectation([" ", "\t"], false, false),
          peg$c2 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c3 = function () {
        return [];
      },
          peg$c4 = peg$otherExpectation("_2LineEnd"),
          peg$c5 = "\r",
          peg$c6 = peg$literalExpectation("\r", false),
          peg$c7 = peg$anyExpectation(),
          peg$c8 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c9 = "\n",
          peg$c10 = peg$literalExpectation("\n", false),
          peg$c11 = function (t) {
        return false;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        return s0;
      }

      function peg$parse_2start() {
        var s0;
        s0 = peg$parse_2blankLine();
        return s0;
      }

      function peg$parse_2blankLine() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_2TERM();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c3();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_2TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c8(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/comment", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _7start: peg$parse_7start
      },
          peg$startRuleFunction = peg$parse_7start,
          peg$c0 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c1 = peg$otherExpectation("_3DEDENT"),
          peg$c2 = peg$anyExpectation(),
          peg$c3 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c4 = function (t) {
        return '';
      },
          peg$c5 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c6 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c7 = /^[ \t]/,
          peg$c8 = peg$classExpectation([" ", "\t"], false, false),
          peg$c9 = peg$otherExpectation("_4RequiredWhitespace"),
          peg$c10 = function (s) {
        return s;
      },
          peg$c11 = peg$otherExpectation("_5INDENT"),
          peg$c12 = function (t) {
        return _preprocessor.INDENT_SYMBOL === t;
      },
          peg$c13 = function (c) {
        return c;
      },
          peg$c14 = peg$otherExpectation("_6INDENT"),
          peg$c15 = peg$otherExpectation("_6DEDENT"),
          peg$c16 = peg$otherExpectation("_6LineEnd"),
          peg$c17 = "\r",
          peg$c18 = peg$literalExpectation("\r", false),
          peg$c19 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c20 = "\n",
          peg$c21 = peg$literalExpectation("\n", false),
          peg$c22 = function (t) {
        return false;
      },
          peg$c23 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c24 = peg$otherExpectation("_7Comment"),
          peg$c25 = "/",
          peg$c26 = peg$literalExpectation("/", false),
          peg$c27 = function () {
        return [];
      },
          peg$c28 = peg$otherExpectation("_7LineEnd"),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c3(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c6(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c7.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }

        return s0;
      }

      function peg$parse_4start() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_0start();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_0start();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c9);
          }
        }

        return s0;
      }

      function peg$parse_5indentation() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_5INDENT();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_4start();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c10(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_5INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c12(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c11);
          }
        }

        return s0;
      }

      function peg$parse_6lineContent() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_6lineChar();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_6lineChar();
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_6lineChar() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_6INDENT();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_6DEDENT();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_6TERM();
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c2);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c13(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_6INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c12(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c14);
          }
        }

        return s0;
      }

      function peg$parse_6DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c3(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }

        return s0;
      }

      function peg$parse_6TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c17;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c18);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c2);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c19(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c20;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c21);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c22(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c23);
          }
        }

        return s0;
      }

      function peg$parse_7start() {
        var s0;
        s0 = peg$parse_7comment();
        return s0;
      }

      function peg$parse_7comment() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c25;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_7commentContent();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        return s0;
      }

      function peg$parse_7commentContent() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parse_6lineContent();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_7TERM();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$currPos;
            s5 = peg$parse_5indentation();

            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$parse_7commentContent();

              if (s7 !== peg$FAILED) {
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parse_7commentContent();
                }
              } else {
                s6 = peg$FAILED;
              }

              if (s6 !== peg$FAILED) {
                s7 = peg$parse_3anyDedent();

                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$currPos;
              s5 = peg$parse_5indentation();

              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parse_7commentContent();

                if (s7 !== peg$FAILED) {
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parse_7commentContent();
                  }
                } else {
                  s6 = peg$FAILED;
                }

                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_3anyDedent();

                  if (s7 !== peg$FAILED) {
                    s5 = [s5, s6, s7];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c27();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_7TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c17;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c18);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c2);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c19(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c20;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c21);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c22(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/else", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _8start: peg$parse_8start
      },
          peg$startRuleFunction = peg$parse_8start,
          peg$c0 = /^[ \t]/,
          peg$c1 = peg$classExpectation([" ", "\t"], false, false),
          peg$c2 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c3 = "=",
          peg$c4 = peg$literalExpectation("=", false),
          peg$c5 = "else",
          peg$c6 = peg$literalExpectation("else", false),
          peg$c7 = "if",
          peg$c8 = peg$literalExpectation("if", false),
          peg$c9 = function (e) {
        return e.join('');
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        return s0;
      }

      function peg$parse_8start() {
        var s0;
        s0 = peg$parse_8else();
        return s0;
      }

      function peg$parse_8else() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 61) {
          s2 = peg$c3;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_1start();

          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;

          if (input.substr(peg$currPos, 4) === peg$c5) {
            s3 = peg$c5;
            peg$currPos += 4;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }

          if (s3 !== peg$FAILED) {
            s4 = peg$parse_1start();

            if (s4 !== peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c7) {
                s5 = peg$c7;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s3 = [s3, s4, s5];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c9(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/equal-sign", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _9start: peg$parse_9start
      },
          peg$startRuleFunction = peg$parse_9start,
          peg$c0 = "==",
          peg$c1 = peg$literalExpectation("==", false),
          peg$c2 = " ",
          peg$c3 = peg$literalExpectation(" ", false),
          peg$c4 = function () {
        return false;
      },
          peg$c5 = "=",
          peg$c6 = peg$literalExpectation("=", false),
          peg$c7 = function () {
        return true;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_9start() {
        var s0;
        s0 = peg$parse_9equalSign();
        return s0;
      }

      function peg$parse_9equalSign() {
        var s0, s1, s2;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c0) {
          s1 = peg$c0;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 32) {
            s2 = peg$c2;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c3);
            }
          }

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 61) {
            s1 = peg$c5;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }

          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 32) {
              s2 = peg$c2;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c3);
              }
            }

            if (s2 === peg$FAILED) {
              s2 = null;
            }

            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c7();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/alias-action", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _22start: peg$parse_22start
      },
          peg$startRuleFunction = peg$parse_22start,
          peg$c0 = function (v) {
        var last = v[v.length - 1];
        var idNode; // Support for data keywords that are prefixed with @ in the each
        // block helper such as @index, @key, @first, @last

        if (last.part.charAt(0) === '@') {
          last.part = last.part.slice(1);
          idNode = new AST.IdNode(v);
          var dataNode = new AST.DataNode(idNode);
          return dataNode;
        }

        var match;
        var suffixModifier; // FIXME probably need to handle this better?

        if (match = last.part.match(/!$/)) {
          last.part = 'unbound ' + last.part.slice(0, -1);
        }

        if (match = last.part.match(/[\?\^]$/)) {
          suffixModifier = match[0];
          throw "unhandled path terminated: " + suffixModifier;
        }

        return last.part;
      },
          peg$c1 = function (first, s, p) {
        return {
          part: p,
          separator: s
        };
      },
          peg$c2 = function (first, tail) {
        var ret = [{
          part: first
        }];

        for (var i = 0; i < tail.length; ++i) {
          ret.push(tail[i]);
        }

        return ret;
      },
          peg$c3 = peg$otherExpectation("_17PathIdent"),
          peg$c4 = "..",
          peg$c5 = peg$literalExpectation("..", false),
          peg$c6 = ".",
          peg$c7 = peg$literalExpectation(".", false),
          peg$c8 = /^[a-zA-Z0-9_$\-!?\^@]/,
          peg$c9 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "$", "-", "!", "?", "^", "@"], false, false),
          peg$c10 = "=",
          peg$c11 = peg$literalExpectation("=", false),
          peg$c12 = function (s) {
        return s;
      },
          peg$c13 = "[",
          peg$c14 = peg$literalExpectation("[", false),
          peg$c15 = /^[^\]]/,
          peg$c16 = peg$classExpectation(["]"], true, false),
          peg$c17 = "]",
          peg$c18 = peg$literalExpectation("]", false),
          peg$c19 = function (segmentLiteral) {
        return segmentLiteral;
      },
          peg$c20 = peg$otherExpectation("_17PathSeparator"),
          peg$c21 = /^[\/.]/,
          peg$c22 = peg$classExpectation(["/", "."], false, false),
          peg$c23 = ":",
          peg$c24 = peg$literalExpectation(":", false),
          peg$c25 = " ",
          peg$c26 = peg$literalExpectation(" ", false),
          peg$c27 = function (c) {
        return c;
      },
          peg$c28 = peg$otherExpectation("_19valid tag string"),
          peg$c29 = /^[_a-zA-Z0-9\-]/,
          peg$c30 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c31 = "@",
          peg$c32 = peg$literalExpectation("@", false),
          peg$c33 = function (p) {
        return p;
      },
          peg$c34 = "'",
          peg$c35 = peg$literalExpectation("'", false),
          peg$c36 = "\"",
          peg$c37 = peg$literalExpectation("\"", false),
          peg$c38 = peg$otherExpectation("_20Closing single quote"),
          peg$c39 = peg$otherExpectation("_20Closing double quote"),
          peg$c40 = peg$otherExpectation("_20string action attributes"),
          peg$c41 = /^[^"}]/,
          peg$c42 = peg$classExpectation(["\"", "}"], true, false),
          peg$c43 = /^[^'}]/,
          peg$c44 = peg$classExpectation(["'", "}"], true, false),
          peg$c45 = peg$otherExpectation("_20LineEnd"),
          peg$c46 = "\r",
          peg$c47 = peg$literalExpectation("\r", false),
          peg$c48 = peg$anyExpectation(),
          peg$c49 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c50 = "\n",
          peg$c51 = peg$literalExpectation("\n", false),
          peg$c52 = function (t) {
        return false;
      },
          peg$c53 = peg$otherExpectation("_11mustache expression"),
          peg$c54 = "{",
          peg$c55 = peg$literalExpectation("{", false),
          peg$c56 = /^[^}]/,
          peg$c57 = peg$classExpectation(["}"], true, false),
          peg$c58 = function (text) {
        return text;
      },
          peg$c59 = /^[ \t]/,
          peg$c60 = peg$classExpectation([" ", "\t"], false, false),
          peg$c61 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c62 = function (value) {
        return value;
      },
          peg$c63 = peg$otherExpectation("_21closing mustache"),
          peg$c64 = "}",
          peg$c65 = peg$literalExpectation("}", false),
          peg$c66 = function (event, mustacheNode) {
        var actionBody, parts;

        if (typeof mustacheNode === 'string') {
          actionBody = mustacheNode;
        } else {
          parts = mustacheNode[1].split(' ');

          if (parts.length === 1) {
            actionBody = '"' + parts[0] + '"';
          } else {
            actionBody = mustacheNode[1];
          }
        }

        var actionContent = [actionBody];

        if (actionBody.indexOf('action ') !== 0) {
          actionContent.unshift('action');
        }

        return buildActionEvent(event, actionContent);
      },
          peg$c67 = peg$otherExpectation("_22a valid JS event"),
          peg$c68 = function (event) {
        return isAliasEvent(event);
      },
          peg$c69 = function (event) {
        return event;
      },
          peg$c70 = function (id) {
        return id;
      },
          peg$c71 = function (value) {
        return value;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_17pathIdNode() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_17path();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_17path() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_17pathIdent();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_17separator();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_17pathIdent();

            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c1(s1, s4, s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_17separator();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_17pathIdent();

              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c1(s1, s4, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c2(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_17pathIdent() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s0 = peg$c6;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];

            if (peg$c8.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c8.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c9);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s1 = input.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }

            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c10;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c11);
                }
              }

              peg$silentFails--;

              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }

              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c13;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];

                if (peg$c15.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c16);
                  }
                }

                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c15.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c16);
                    }
                  }
                }

                if (s3 !== peg$FAILED) {
                  s2 = input.substring(s2, peg$currPos);
                } else {
                  s2 = s3;
                }

                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c17;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c18);
                    }
                  }

                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c19(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_17separator() {
        var s0, s1;
        peg$silentFails++;

        if (peg$c21.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_18nonSeparatorColon() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 58) {
          s1 = peg$c23;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;

          if (input.charCodeAt(peg$currPos) === 32) {
            s3 = peg$c25;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c26);
            }
          }

          peg$silentFails--;

          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_19tagString() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_19tagChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_19tagChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        return s0;
      }

      function peg$parse_19tagChar() {
        var s0;

        if (peg$c29.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 64) {
              s0 = peg$c31;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_20stringWithQuotes() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_20singleQuoteString();

        if (s1 === peg$FAILED) {
          s1 = peg$parse_20doubleQuoteString();
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_20singleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c34;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashSingleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c34;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c35);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20doubleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c36;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashDoubleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c36;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }

        return s0;
      }

      function peg$parse_20closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }

        return s0;
      }

      function peg$parse_20hashDoubleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c41.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c42);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c41.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c42);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_20hashSingleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c43.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c44);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c43.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c44);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_20TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }

        return s0;
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c54;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c56.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c57);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c56.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c57);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c58(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c53);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c59.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c60);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }

        return s0;
      }

      function peg$parse_21singleMustacheValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c54;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_21mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c62(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_21mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c63);
          }
        }

        return s0;
      }

      function peg$parse_22start() {
        var s0;
        s0 = peg$parse_22actionAttribute();
        return s0;
      }

      function peg$parse_22actionAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_22knownAliasEvent();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_22actionValue();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_22knownAliasEvent() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_19tagString();

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c68(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c69(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c67);
          }
        }

        return s0;
      }

      function peg$parse_22actionValue() {
        var s0, s1;
        s0 = peg$parse_20stringWithQuotes();

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_17pathIdNode();

          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c70(s1);
          }

          s0 = s1;

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_21singleMustacheValue();

            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c71(s1);
            }

            s0 = s1;
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/attribute-bracketed", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _35bracketedAttribute: peg$parse_35bracketedAttribute
      },
          peg$startRuleFunction = peg$parse_35bracketedAttribute,
          peg$c0 = function (v) {
        var last = v[v.length - 1];
        var idNode; // Support for data keywords that are prefixed with @ in the each
        // block helper such as @index, @key, @first, @last

        if (last.part.charAt(0) === '@') {
          last.part = last.part.slice(1);
          idNode = new AST.IdNode(v);
          var dataNode = new AST.DataNode(idNode);
          return dataNode;
        }

        var match;
        var suffixModifier; // FIXME probably need to handle this better?

        if (match = last.part.match(/!$/)) {
          last.part = 'unbound ' + last.part.slice(0, -1);
        }

        if (match = last.part.match(/[\?\^]$/)) {
          suffixModifier = match[0];
          throw "unhandled path terminated: " + suffixModifier;
        }

        return last.part;
      },
          peg$c1 = function (first, s, p) {
        return {
          part: p,
          separator: s
        };
      },
          peg$c2 = function (first, tail) {
        var ret = [{
          part: first
        }];

        for (var i = 0; i < tail.length; ++i) {
          ret.push(tail[i]);
        }

        return ret;
      },
          peg$c3 = peg$otherExpectation("_17PathIdent"),
          peg$c4 = "..",
          peg$c5 = peg$literalExpectation("..", false),
          peg$c6 = ".",
          peg$c7 = peg$literalExpectation(".", false),
          peg$c8 = /^[a-zA-Z0-9_$\-!?\^@]/,
          peg$c9 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "$", "-", "!", "?", "^", "@"], false, false),
          peg$c10 = "=",
          peg$c11 = peg$literalExpectation("=", false),
          peg$c12 = function (s) {
        return s;
      },
          peg$c13 = "[",
          peg$c14 = peg$literalExpectation("[", false),
          peg$c15 = /^[^\]]/,
          peg$c16 = peg$classExpectation(["]"], true, false),
          peg$c17 = "]",
          peg$c18 = peg$literalExpectation("]", false),
          peg$c19 = function (segmentLiteral) {
        return segmentLiteral;
      },
          peg$c20 = peg$otherExpectation("_17PathSeparator"),
          peg$c21 = /^[\/.]/,
          peg$c22 = peg$classExpectation(["/", "."], false, false),
          peg$c23 = ":",
          peg$c24 = peg$literalExpectation(":", false),
          peg$c25 = " ",
          peg$c26 = peg$literalExpectation(" ", false),
          peg$c27 = function (c) {
        return c;
      },
          peg$c28 = peg$otherExpectation("_19valid tag string"),
          peg$c29 = /^[_a-zA-Z0-9\-]/,
          peg$c30 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c31 = "@",
          peg$c32 = peg$literalExpectation("@", false),
          peg$c33 = function (p) {
        return p;
      },
          peg$c34 = "'",
          peg$c35 = peg$literalExpectation("'", false),
          peg$c36 = "\"",
          peg$c37 = peg$literalExpectation("\"", false),
          peg$c38 = peg$otherExpectation("_20Closing single quote"),
          peg$c39 = peg$otherExpectation("_20Closing double quote"),
          peg$c40 = peg$otherExpectation("_20string action attributes"),
          peg$c41 = /^[^"}]/,
          peg$c42 = peg$classExpectation(["\"", "}"], true, false),
          peg$c43 = /^[^'}]/,
          peg$c44 = peg$classExpectation(["'", "}"], true, false),
          peg$c45 = peg$otherExpectation("_20LineEnd"),
          peg$c46 = "\r",
          peg$c47 = peg$literalExpectation("\r", false),
          peg$c48 = peg$anyExpectation(),
          peg$c49 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c50 = "\n",
          peg$c51 = peg$literalExpectation("\n", false),
          peg$c52 = function (t) {
        return false;
      },
          peg$c53 = peg$otherExpectation("_11mustache expression"),
          peg$c54 = "{",
          peg$c55 = peg$literalExpectation("{", false),
          peg$c56 = /^[^}]/,
          peg$c57 = peg$classExpectation(["}"], true, false),
          peg$c58 = function (text) {
        return text;
      },
          peg$c59 = /^[ \t]/,
          peg$c60 = peg$classExpectation([" ", "\t"], false, false),
          peg$c61 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c62 = function (value) {
        return value;
      },
          peg$c63 = peg$otherExpectation("_21closing mustache"),
          peg$c64 = "}",
          peg$c65 = peg$literalExpectation("}", false),
          peg$c66 = function (event, mustacheNode) {
        var actionBody, parts;

        if (typeof mustacheNode === 'string') {
          actionBody = mustacheNode;
        } else {
          parts = mustacheNode[1].split(' ');

          if (parts.length === 1) {
            actionBody = '"' + parts[0] + '"';
          } else {
            actionBody = mustacheNode[1];
          }
        }

        var actionContent = [actionBody];

        if (actionBody.indexOf('action ') !== 0) {
          actionContent.unshift('action');
        }

        return buildActionEvent(event, actionContent);
      },
          peg$c67 = peg$otherExpectation("_22a valid JS event"),
          peg$c68 = function (event) {
        return isAliasEvent(event);
      },
          peg$c69 = function (event) {
        return event;
      },
          peg$c70 = function (id) {
        return id;
      },
          peg$c71 = function (value) {
        return value;
      },
          peg$c72 = /^[\x80-\xFF]/,
          peg$c73 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c74 = peg$otherExpectation("_24Key"),
          peg$c75 = "true",
          peg$c76 = peg$literalExpectation("true", false),
          peg$c77 = "false",
          peg$c78 = peg$literalExpectation("false", false),
          peg$c79 = function (key, boolValue) {
        if (boolValue === 'true') {
          return [key];
        }
      },
          peg$c80 = peg$otherExpectation("_26Attribute Key"),
          peg$c81 = "$",
          peg$c82 = peg$literalExpectation("$", false),
          peg$c83 = function (key, digits) {
        var value = parseInt(digits.join(""), 10);
        return [key, value];
      },
          peg$c84 = peg$otherExpectation("_27Valid numbers"),
          peg$c85 = /^[0-9]/,
          peg$c86 = peg$classExpectation([["0", "9"]], false, false),
          peg$c87 = function (key, value) {
        value = value.trim(); // Class logic needs to be coalesced, except for conditional statements

        if (key === 'class') {
          if (value.indexOf('if') === 0 || value.indexOf('unless') === 0) {
            return builder.generateClassNameBinding(value);
          } else {
            return splitValueIntoClassBindings(value);
          }
        } else {
          return [builder.generateAssignedMustache(value, key)];
        }
      },
          peg$c88 = /^[\-_\/A-Za-z0-9]/,
          peg$c89 = peg$classExpectation(["-", "_", "/", ["A", "Z"], ["a", "z"], ["0", "9"]], false, false),
          peg$c90 = "::",
          peg$c91 = peg$literalExpectation("::", false),
          peg$c92 = ".[",
          peg$c93 = peg$literalExpectation(".[", false),
          peg$c94 = "!",
          peg$c95 = peg$literalExpectation("!", false),
          peg$c96 = function (key, value) {
        if (key === 'class') {
          return splitValueIntoClassBindings(value);
        } else {
          return [builder.generateAssignedMustache(value, key)];
        }
      },
          peg$c97 = function (value) {
        return value.replace(/ *$/, '');
      },
          peg$c98 = peg$otherExpectation("_30valid attribute value"),
          peg$c99 = peg$otherExpectation("_30closing mustache"),
          peg$c100 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), false);
      },
          peg$c101 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), true);
      },
          peg$c102 = peg$otherExpectation("_12Double Mustache Open"),
          peg$c103 = "{{",
          peg$c104 = peg$literalExpectation("{{", false),
          peg$c105 = peg$otherExpectation("_12Triple Mustache Open"),
          peg$c106 = "{{{",
          peg$c107 = peg$literalExpectation("{{{", false),
          peg$c108 = peg$otherExpectation("_12Double Mustache Close"),
          peg$c109 = "}}",
          peg$c110 = peg$literalExpectation("}}", false),
          peg$c111 = peg$otherExpectation("_12Triple Mustache Close"),
          peg$c112 = "}}}",
          peg$c113 = peg$literalExpectation("}}}", false),
          peg$c114 = peg$otherExpectation("_12String Interpolation Open"),
          peg$c115 = "#{",
          peg$c116 = peg$literalExpectation("#{", false),
          peg$c117 = peg$otherExpectation("_12String Interpolation Close"),
          peg$c118 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c119 = peg$otherExpectation("_3DEDENT"),
          peg$c120 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c121 = function (t) {
        return '';
      },
          peg$c122 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c123 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c124 = peg$otherExpectation("_13Single Mustache Open"),
          peg$c125 = peg$otherExpectation("_13Double Mustache Open"),
          peg$c126 = peg$otherExpectation("_13Triple Mustache Open"),
          peg$c127 = peg$otherExpectation("_13String Interpolation Open"),
          peg$c128 = peg$otherExpectation("_13LineEnd"),
          peg$c129 = function (key, nodes) {
        var strings = [];
        nodes.forEach(function (node) {
          if (typeof node === 'string') {
            strings.push(node);
          } else {
            // FIXME here we transform a mustache attribute
            // This should be handled higher up instead, not here.
            // This happens when the attribute is something like:
            // src="{{unbound post.showLogoUrl}}".
            // key = "src", nodes[0] = "unbound post.showLogoUrl"
            if (node.escaped) {
              strings.push('{{' + node.content + '}}');
            } else {
              strings.push('{{{' + node.content + '}}}');
            }
          }
        });
        var result = [key, strings.join('')];
        return result;
      },
          peg$c130 = function (a) {
        return a;
      },
          peg$c131 = peg$otherExpectation("_31Closing Single Quote"),
          peg$c132 = peg$otherExpectation("_31Closing Double Quote"),
          peg$c133 = function (first, tail) {
        return flattenArray(first, tail);
      },
          peg$c134 = peg$otherExpectation("_31Valid quoted attribute value"),
          peg$c135 = function (key, value) {
        return [key, '{{' + value + '}}'];
      },
          peg$c136 = "...attributes",
          peg$c137 = peg$literalExpectation("...attributes", false),
          peg$c138 = function (spread) {
        return [spread];
      },
          peg$c139 = function (a) {
        if (!a) return [];else if (!a.length) return [a];else return a;
      },
          peg$c140 = function (a) {
        return a;
      },
          peg$c141 = peg$otherExpectation("_35LineEnd"),
          peg$c142 = peg$otherExpectation("_35INDENT"),
          peg$c143 = function (t) {
        return _preprocessor.INDENT_SYMBOL === t;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_17pathIdNode() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_17path();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_17path() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_17pathIdent();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_17separator();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_17pathIdent();

            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c1(s1, s4, s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_17separator();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_17pathIdent();

              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c1(s1, s4, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c2(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_17pathIdent() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s0 = peg$c6;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];

            if (peg$c8.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c8.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c9);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s1 = input.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }

            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c10;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c11);
                }
              }

              peg$silentFails--;

              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }

              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c13;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];

                if (peg$c15.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c16);
                  }
                }

                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c15.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c16);
                    }
                  }
                }

                if (s3 !== peg$FAILED) {
                  s2 = input.substring(s2, peg$currPos);
                } else {
                  s2 = s3;
                }

                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c17;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c18);
                    }
                  }

                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c19(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_17separator() {
        var s0, s1;
        peg$silentFails++;

        if (peg$c21.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_18nonSeparatorColon() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 58) {
          s1 = peg$c23;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;

          if (input.charCodeAt(peg$currPos) === 32) {
            s3 = peg$c25;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c26);
            }
          }

          peg$silentFails--;

          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_19tagString() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_19tagChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_19tagChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        return s0;
      }

      function peg$parse_19tagChar() {
        var s0;

        if (peg$c29.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 64) {
              s0 = peg$c31;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_20stringWithQuotes() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_20singleQuoteString();

        if (s1 === peg$FAILED) {
          s1 = peg$parse_20doubleQuoteString();
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_20singleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c34;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashSingleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c34;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c35);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20doubleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c36;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashDoubleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c36;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }

        return s0;
      }

      function peg$parse_20closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }

        return s0;
      }

      function peg$parse_20hashDoubleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c41.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c42);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c41.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c42);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_20hashSingleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c43.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c44);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c43.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c44);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_20TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }

        return s0;
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c54;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c56.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c57);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c56.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c57);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c58(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c53);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c59.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c60);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }

        return s0;
      }

      function peg$parse_21singleMustacheValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c54;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_21mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c62(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_21mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c63);
          }
        }

        return s0;
      }

      function peg$parse_22actionAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_22knownAliasEvent();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_22actionValue();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_22knownAliasEvent() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_19tagString();

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c68(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c69(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c67);
          }
        }

        return s0;
      }

      function peg$parse_22actionValue() {
        var s0, s1;
        s0 = peg$parse_20stringWithQuotes();

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_17pathIdNode();

          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c70(s1);
          }

          s0 = s1;

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_21singleMustacheValue();

            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c71(s1);
            }

            s0 = s1;
          }
        }

        return s0;
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c29.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c72.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c73);
          }
        }

        return s0;
      }

      function peg$parse_24key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c23;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c6;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c23;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c6;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c7);
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c74);
          }
        }

        return s0;
      }

      function peg$parse_25booleanAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_24key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c75) {
              s3 = peg$c75;
              peg$currPos += 4;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }

            if (s3 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c77) {
                s3 = peg$c77;
                peg$currPos += 5;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c78);
                }
              }
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c79(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_26key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c23;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c6;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s2 = peg$c31;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 36) {
                  s2 = peg$c81;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c82);
                  }
                }
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c23;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c6;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c7);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 64) {
                  s2 = peg$c31;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c32);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s2 = peg$c81;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c82);
                    }
                  }
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c80);
          }
        }

        return s0;
      }

      function peg$parse_27booleanAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_27digits();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c83(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_27digits() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];

        if (peg$c85.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c86);
          }
        }

        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);

            if (peg$c85.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c86);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c84);
          }
        }

        return s0;
      }

      function peg$parse_28boundAttributeWithSingleMustache() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_21singleMustacheValue();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c87(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_29newMustacheNameChar() {
        var s0;

        if (peg$c88.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c89);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_29arrayIndex();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s0 = peg$c6;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s0 = peg$c31;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }

              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c90) {
                  s0 = peg$c90;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c91);
                  }
                }

                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s0 = peg$c81;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c82);
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_29arrayIndex() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c92) {
          s1 = peg$c92;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c93);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_29newMustacheNameChar();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_29newMustacheNameChar();
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c17;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c18);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_30boundAttribute() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_30boundAttributeValue();

            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 33) {
                s5 = peg$c94;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c95);
                }
              }

              peg$silentFails--;

              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c96(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_30boundAttributeValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c54;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parse_30boundAttributeValueChar();

            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 32) {
                s5 = peg$c25;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c26);
                }
              }
            }

            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parse_30boundAttributeValueChar();

                if (s5 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 32) {
                    s5 = peg$c25;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c26);
                    }
                  }
                }
              }
            } else {
              s4 = peg$FAILED;
            }

            if (s4 !== peg$FAILED) {
              s3 = input.substring(s3, peg$currPos);
            } else {
              s3 = s4;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_30mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c97(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_30boundAttributeValueChar();

          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parse_30boundAttributeValueChar();
            }
          } else {
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        return s0;
      }

      function peg$parse_30boundAttributeValueChar() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_29newMustacheNameChar();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c98);
          }
        }

        return s0;
      }

      function peg$parse_30mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c99);
          }
        }

        return s0;
      }

      function peg$parse_12rawMustache() {
        var s0;
        s0 = peg$parse_12rawMustacheUnescaped();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustacheEscaped();
        }

        return s0;
      }

      function peg$parse_12rawMustacheUnescaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12tripleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12tripleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c100(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_12rawMustacheEscaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12doubleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12doubleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c101(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_12hashStacheOpen();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_1start();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_11nonMustache();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_1start();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_12hashStacheClose();

                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c101(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_12doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c103) {
          s0 = peg$c103;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c104);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c102);
          }
        }

        return s0;
      }

      function peg$parse_12tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c106) {
          s0 = peg$c106;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c107);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c105);
          }
        }

        return s0;
      }

      function peg$parse_12doubleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c109) {
          s0 = peg$c109;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c110);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c108);
          }
        }

        return s0;
      }

      function peg$parse_12tripleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c112) {
          s0 = peg$c112;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c113);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c111);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c115) {
          s0 = peg$c115;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c116);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c114);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c117);
          }
        }

        return s0;
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c118);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c120(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c119);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c123(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c122);
          }
        }

        return s0;
      }

      function peg$parse_13nonMustacheUnit() {
        var s0;
        s0 = peg$parse_13tripleOpen();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_13doubleOpen();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_13hashStacheOpen();

            if (s0 === peg$FAILED) {
              s0 = peg$parse_3anyDedent();

              if (s0 === peg$FAILED) {
                s0 = peg$parse_13TERM();
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_13singleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s0 = peg$c54;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c124);
          }
        }

        return s0;
      }

      function peg$parse_13doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c103) {
          s0 = peg$c103;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c104);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c125);
          }
        }

        return s0;
      }

      function peg$parse_13tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c106) {
          s0 = peg$c106;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c107);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c126);
          }
        }

        return s0;
      }

      function peg$parse_13hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c115) {
          s0 = peg$c115;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c116);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c127);
          }
        }

        return s0;
      }

      function peg$parse_13TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c128);
          }
        }

        return s0;
      }

      function peg$parse_31normalAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_31attributeTextNodes();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c129(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31attributeTextNodes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c36;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_31attributeTextNodesInner();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_31closingDoubleQuote();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c130(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c34;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_31attributeTextNodesInnerSingle();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_31closingSingleQuote();

              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c130(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_31closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c131);
          }
        }

        return s0;
      }

      function peg$parse_31closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 34) {
          s0 = peg$c36;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c132);
          }
        }

        return s0;
      }

      function peg$parse_31attributeTextNodesInner() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_31preAttrMustacheText();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_31preAttrMustacheText();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_31preAttrMustacheText();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c133(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31attributeTextNodesInnerSingle() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_31preAttrMustacheTextSingle();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_31preAttrMustacheTextSingle();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_31preAttrMustacheTextSingle();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c133(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheText() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_31preAttrMustacheUnit();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_31preAttrMustacheUnit();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheTextSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_31preAttrMustacheUnitSingle();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_31preAttrMustacheUnitSingle();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheUnit() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c36;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c37);
            }
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c134);
          }
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheUnitSingle() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c34;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c134);
          }
        }

        return s0;
      }

      function peg$parse_32simpleMustacheAttr() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_17pathIdNode();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c135(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_33spreadAttribute() {
        var s0, s1;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 13) === peg$c136) {
          s1 = peg$c136;
          peg$currPos += 13;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c137);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c138(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_34attribute() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_22actionAttribute();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_25booleanAttribute();

            if (s2 === peg$FAILED) {
              s2 = peg$parse_27booleanAttribute();

              if (s2 === peg$FAILED) {
                s2 = peg$parse_28boundAttributeWithSingleMustache();

                if (s2 === peg$FAILED) {
                  s2 = peg$parse_30boundAttribute();

                  if (s2 === peg$FAILED) {
                    s2 = peg$parse_31normalAttribute();

                    if (s2 === peg$FAILED) {
                      s2 = peg$parse_32simpleMustacheAttr();

                      if (s2 === peg$FAILED) {
                        s2 = peg$parse_33spreadAttribute();
                      }
                    }
                  }
                }
              }
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c139(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_35bracketedAttribute() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_35INDENT();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_35INDENT();
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_34attribute();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_35TERM();

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_35TERM();
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c140(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_35TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c141);
          }
        }

        return s0;
      }

      function peg$parse_35INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c143(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c142);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/attribute-shorthand", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _39start: peg$parse_39start
      },
          peg$startRuleFunction = peg$parse_39start,
          peg$c0 = /^[_a-zA-Z0-9\-]/,
          peg$c1 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c2 = /^[\x80-\xFF]/,
          peg$c3 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c4 = peg$otherExpectation("_36CSS class"),
          peg$c5 = peg$otherExpectation("_37HTML ID"),
          peg$c6 = "#",
          peg$c7 = peg$literalExpectation("#", false),
          peg$c8 = function (c) {
        return c;
      },
          peg$c9 = ".",
          peg$c10 = peg$literalExpectation(".", false),
          peg$c11 = function (c) {
        return c;
      },
          peg$c12 = function (s) {
        return {
          shorthand: s,
          id: true
        };
      },
          peg$c13 = function (s) {
        return {
          shorthand: s
        };
      },
          peg$c14 = function (shorthands) {
        var id,
            classes = [];

        for (var i = 0, len = shorthands.length; i < len; ++i) {
          var shorthand = shorthands[i];

          if (shorthand.id) {
            id = shorthand.shorthand;
          } else {
            classes.push(shorthand.shorthand);
          }
        }

        return [id, classes];
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_36cssIdentifier() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_36ident();
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        return s0;
      }

      function peg$parse_36ident() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_23nmchar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_37idShorthand() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c6;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_36cssIdentifier();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c8(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        return s0;
      }

      function peg$parse_38classShorthand() {
        var s0, s1, s2;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c9;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c10);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_36cssIdentifier();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c11(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_39start() {
        var s0;
        s0 = peg$parse_39shorthandAttributes();
        return s0;
      }

      function peg$parse_39shorthandAttributes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parse_37idShorthand();

        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c12(s3);
        }

        s2 = s3;

        if (s2 === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parse_38classShorthand();

          if (s3 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c13(s3);
          }

          s2 = s3;
        }

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parse_37idShorthand();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c12(s3);
            }

            s2 = s3;

            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parse_38classShorthand();

              if (s3 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c13(s3);
              }

              s2 = s3;
            }
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c14(s1);
        }

        s0 = s1;
        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/attribute", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _34attribute: peg$parse_34attribute
      },
          peg$startRuleFunction = peg$parse_34attribute,
          peg$c0 = function (v) {
        var last = v[v.length - 1];
        var idNode; // Support for data keywords that are prefixed with @ in the each
        // block helper such as @index, @key, @first, @last

        if (last.part.charAt(0) === '@') {
          last.part = last.part.slice(1);
          idNode = new AST.IdNode(v);
          var dataNode = new AST.DataNode(idNode);
          return dataNode;
        }

        var match;
        var suffixModifier; // FIXME probably need to handle this better?

        if (match = last.part.match(/!$/)) {
          last.part = 'unbound ' + last.part.slice(0, -1);
        }

        if (match = last.part.match(/[\?\^]$/)) {
          suffixModifier = match[0];
          throw "unhandled path terminated: " + suffixModifier;
        }

        return last.part;
      },
          peg$c1 = function (first, s, p) {
        return {
          part: p,
          separator: s
        };
      },
          peg$c2 = function (first, tail) {
        var ret = [{
          part: first
        }];

        for (var i = 0; i < tail.length; ++i) {
          ret.push(tail[i]);
        }

        return ret;
      },
          peg$c3 = peg$otherExpectation("_17PathIdent"),
          peg$c4 = "..",
          peg$c5 = peg$literalExpectation("..", false),
          peg$c6 = ".",
          peg$c7 = peg$literalExpectation(".", false),
          peg$c8 = /^[a-zA-Z0-9_$\-!?\^@]/,
          peg$c9 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "$", "-", "!", "?", "^", "@"], false, false),
          peg$c10 = "=",
          peg$c11 = peg$literalExpectation("=", false),
          peg$c12 = function (s) {
        return s;
      },
          peg$c13 = "[",
          peg$c14 = peg$literalExpectation("[", false),
          peg$c15 = /^[^\]]/,
          peg$c16 = peg$classExpectation(["]"], true, false),
          peg$c17 = "]",
          peg$c18 = peg$literalExpectation("]", false),
          peg$c19 = function (segmentLiteral) {
        return segmentLiteral;
      },
          peg$c20 = peg$otherExpectation("_17PathSeparator"),
          peg$c21 = /^[\/.]/,
          peg$c22 = peg$classExpectation(["/", "."], false, false),
          peg$c23 = ":",
          peg$c24 = peg$literalExpectation(":", false),
          peg$c25 = " ",
          peg$c26 = peg$literalExpectation(" ", false),
          peg$c27 = function (c) {
        return c;
      },
          peg$c28 = peg$otherExpectation("_19valid tag string"),
          peg$c29 = /^[_a-zA-Z0-9\-]/,
          peg$c30 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c31 = "@",
          peg$c32 = peg$literalExpectation("@", false),
          peg$c33 = function (p) {
        return p;
      },
          peg$c34 = "'",
          peg$c35 = peg$literalExpectation("'", false),
          peg$c36 = "\"",
          peg$c37 = peg$literalExpectation("\"", false),
          peg$c38 = peg$otherExpectation("_20Closing single quote"),
          peg$c39 = peg$otherExpectation("_20Closing double quote"),
          peg$c40 = peg$otherExpectation("_20string action attributes"),
          peg$c41 = /^[^"}]/,
          peg$c42 = peg$classExpectation(["\"", "}"], true, false),
          peg$c43 = /^[^'}]/,
          peg$c44 = peg$classExpectation(["'", "}"], true, false),
          peg$c45 = peg$otherExpectation("_20LineEnd"),
          peg$c46 = "\r",
          peg$c47 = peg$literalExpectation("\r", false),
          peg$c48 = peg$anyExpectation(),
          peg$c49 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c50 = "\n",
          peg$c51 = peg$literalExpectation("\n", false),
          peg$c52 = function (t) {
        return false;
      },
          peg$c53 = peg$otherExpectation("_11mustache expression"),
          peg$c54 = "{",
          peg$c55 = peg$literalExpectation("{", false),
          peg$c56 = /^[^}]/,
          peg$c57 = peg$classExpectation(["}"], true, false),
          peg$c58 = function (text) {
        return text;
      },
          peg$c59 = /^[ \t]/,
          peg$c60 = peg$classExpectation([" ", "\t"], false, false),
          peg$c61 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c62 = function (value) {
        return value;
      },
          peg$c63 = peg$otherExpectation("_21closing mustache"),
          peg$c64 = "}",
          peg$c65 = peg$literalExpectation("}", false),
          peg$c66 = function (event, mustacheNode) {
        var actionBody, parts;

        if (typeof mustacheNode === 'string') {
          actionBody = mustacheNode;
        } else {
          parts = mustacheNode[1].split(' ');

          if (parts.length === 1) {
            actionBody = '"' + parts[0] + '"';
          } else {
            actionBody = mustacheNode[1];
          }
        }

        var actionContent = [actionBody];

        if (actionBody.indexOf('action ') !== 0) {
          actionContent.unshift('action');
        }

        return buildActionEvent(event, actionContent);
      },
          peg$c67 = peg$otherExpectation("_22a valid JS event"),
          peg$c68 = function (event) {
        return isAliasEvent(event);
      },
          peg$c69 = function (event) {
        return event;
      },
          peg$c70 = function (id) {
        return id;
      },
          peg$c71 = function (value) {
        return value;
      },
          peg$c72 = /^[\x80-\xFF]/,
          peg$c73 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c74 = peg$otherExpectation("_24Key"),
          peg$c75 = "true",
          peg$c76 = peg$literalExpectation("true", false),
          peg$c77 = "false",
          peg$c78 = peg$literalExpectation("false", false),
          peg$c79 = function (key, boolValue) {
        if (boolValue === 'true') {
          return [key];
        }
      },
          peg$c80 = peg$otherExpectation("_26Attribute Key"),
          peg$c81 = "$",
          peg$c82 = peg$literalExpectation("$", false),
          peg$c83 = function (key, digits) {
        var value = parseInt(digits.join(""), 10);
        return [key, value];
      },
          peg$c84 = peg$otherExpectation("_27Valid numbers"),
          peg$c85 = /^[0-9]/,
          peg$c86 = peg$classExpectation([["0", "9"]], false, false),
          peg$c87 = function (key, value) {
        value = value.trim(); // Class logic needs to be coalesced, except for conditional statements

        if (key === 'class') {
          if (value.indexOf('if') === 0 || value.indexOf('unless') === 0) {
            return builder.generateClassNameBinding(value);
          } else {
            return splitValueIntoClassBindings(value);
          }
        } else {
          return [builder.generateAssignedMustache(value, key)];
        }
      },
          peg$c88 = /^[\-_\/A-Za-z0-9]/,
          peg$c89 = peg$classExpectation(["-", "_", "/", ["A", "Z"], ["a", "z"], ["0", "9"]], false, false),
          peg$c90 = "::",
          peg$c91 = peg$literalExpectation("::", false),
          peg$c92 = ".[",
          peg$c93 = peg$literalExpectation(".[", false),
          peg$c94 = "!",
          peg$c95 = peg$literalExpectation("!", false),
          peg$c96 = function (key, value) {
        if (key === 'class') {
          return splitValueIntoClassBindings(value);
        } else {
          return [builder.generateAssignedMustache(value, key)];
        }
      },
          peg$c97 = function (value) {
        return value.replace(/ *$/, '');
      },
          peg$c98 = peg$otherExpectation("_30valid attribute value"),
          peg$c99 = peg$otherExpectation("_30closing mustache"),
          peg$c100 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), false);
      },
          peg$c101 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), true);
      },
          peg$c102 = peg$otherExpectation("_12Double Mustache Open"),
          peg$c103 = "{{",
          peg$c104 = peg$literalExpectation("{{", false),
          peg$c105 = peg$otherExpectation("_12Triple Mustache Open"),
          peg$c106 = "{{{",
          peg$c107 = peg$literalExpectation("{{{", false),
          peg$c108 = peg$otherExpectation("_12Double Mustache Close"),
          peg$c109 = "}}",
          peg$c110 = peg$literalExpectation("}}", false),
          peg$c111 = peg$otherExpectation("_12Triple Mustache Close"),
          peg$c112 = "}}}",
          peg$c113 = peg$literalExpectation("}}}", false),
          peg$c114 = peg$otherExpectation("_12String Interpolation Open"),
          peg$c115 = "#{",
          peg$c116 = peg$literalExpectation("#{", false),
          peg$c117 = peg$otherExpectation("_12String Interpolation Close"),
          peg$c118 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c119 = peg$otherExpectation("_3DEDENT"),
          peg$c120 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c121 = function (t) {
        return '';
      },
          peg$c122 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c123 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c124 = peg$otherExpectation("_13Single Mustache Open"),
          peg$c125 = peg$otherExpectation("_13Double Mustache Open"),
          peg$c126 = peg$otherExpectation("_13Triple Mustache Open"),
          peg$c127 = peg$otherExpectation("_13String Interpolation Open"),
          peg$c128 = peg$otherExpectation("_13LineEnd"),
          peg$c129 = function (key, nodes) {
        var strings = [];
        nodes.forEach(function (node) {
          if (typeof node === 'string') {
            strings.push(node);
          } else {
            // FIXME here we transform a mustache attribute
            // This should be handled higher up instead, not here.
            // This happens when the attribute is something like:
            // src="{{unbound post.showLogoUrl}}".
            // key = "src", nodes[0] = "unbound post.showLogoUrl"
            if (node.escaped) {
              strings.push('{{' + node.content + '}}');
            } else {
              strings.push('{{{' + node.content + '}}}');
            }
          }
        });
        var result = [key, strings.join('')];
        return result;
      },
          peg$c130 = function (a) {
        return a;
      },
          peg$c131 = peg$otherExpectation("_31Closing Single Quote"),
          peg$c132 = peg$otherExpectation("_31Closing Double Quote"),
          peg$c133 = function (first, tail) {
        return flattenArray(first, tail);
      },
          peg$c134 = peg$otherExpectation("_31Valid quoted attribute value"),
          peg$c135 = function (key, value) {
        return [key, '{{' + value + '}}'];
      },
          peg$c136 = "...attributes",
          peg$c137 = peg$literalExpectation("...attributes", false),
          peg$c138 = function (spread) {
        return [spread];
      },
          peg$c139 = function (a) {
        if (!a) return [];else if (!a.length) return [a];else return a;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_17pathIdNode() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_17path();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_17path() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_17pathIdent();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_17separator();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_17pathIdent();

            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c1(s1, s4, s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_17separator();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_17pathIdent();

              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c1(s1, s4, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c2(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_17pathIdent() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s0 = peg$c6;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];

            if (peg$c8.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c8.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c9);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s1 = input.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }

            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c10;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c11);
                }
              }

              peg$silentFails--;

              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }

              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c13;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];

                if (peg$c15.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c16);
                  }
                }

                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c15.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c16);
                    }
                  }
                }

                if (s3 !== peg$FAILED) {
                  s2 = input.substring(s2, peg$currPos);
                } else {
                  s2 = s3;
                }

                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c17;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c18);
                    }
                  }

                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c19(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_17separator() {
        var s0, s1;
        peg$silentFails++;

        if (peg$c21.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_18nonSeparatorColon() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 58) {
          s1 = peg$c23;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;

          if (input.charCodeAt(peg$currPos) === 32) {
            s3 = peg$c25;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c26);
            }
          }

          peg$silentFails--;

          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_19tagString() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_19tagChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_19tagChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        return s0;
      }

      function peg$parse_19tagChar() {
        var s0;

        if (peg$c29.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 64) {
              s0 = peg$c31;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_20stringWithQuotes() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_20singleQuoteString();

        if (s1 === peg$FAILED) {
          s1 = peg$parse_20doubleQuoteString();
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_20singleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c34;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashSingleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c34;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c35);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20doubleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c36;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashDoubleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c36;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }

        return s0;
      }

      function peg$parse_20closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }

        return s0;
      }

      function peg$parse_20hashDoubleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c41.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c42);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c41.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c42);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_20hashSingleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c43.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c44);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c43.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c44);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_20TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }

        return s0;
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c54;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c56.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c57);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c56.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c57);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c58(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c53);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c59.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c60);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }

        return s0;
      }

      function peg$parse_21singleMustacheValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c54;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_21mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c62(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_21mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c63);
          }
        }

        return s0;
      }

      function peg$parse_22actionAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_22knownAliasEvent();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_22actionValue();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_22knownAliasEvent() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_19tagString();

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c68(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c69(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c67);
          }
        }

        return s0;
      }

      function peg$parse_22actionValue() {
        var s0, s1;
        s0 = peg$parse_20stringWithQuotes();

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_17pathIdNode();

          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c70(s1);
          }

          s0 = s1;

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_21singleMustacheValue();

            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c71(s1);
            }

            s0 = s1;
          }
        }

        return s0;
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c29.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c72.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c73);
          }
        }

        return s0;
      }

      function peg$parse_24key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c23;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c6;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c23;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c6;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c7);
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c74);
          }
        }

        return s0;
      }

      function peg$parse_25booleanAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_24key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c75) {
              s3 = peg$c75;
              peg$currPos += 4;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }

            if (s3 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c77) {
                s3 = peg$c77;
                peg$currPos += 5;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c78);
                }
              }
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c79(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_26key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c23;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c6;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s2 = peg$c31;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 36) {
                  s2 = peg$c81;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c82);
                  }
                }
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c23;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c6;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c7);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 64) {
                  s2 = peg$c31;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c32);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s2 = peg$c81;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c82);
                    }
                  }
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c80);
          }
        }

        return s0;
      }

      function peg$parse_27booleanAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_27digits();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c83(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_27digits() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];

        if (peg$c85.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c86);
          }
        }

        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);

            if (peg$c85.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c86);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c84);
          }
        }

        return s0;
      }

      function peg$parse_28boundAttributeWithSingleMustache() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_21singleMustacheValue();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c87(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_29newMustacheNameChar() {
        var s0;

        if (peg$c88.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c89);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_29arrayIndex();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s0 = peg$c6;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s0 = peg$c31;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }

              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c90) {
                  s0 = peg$c90;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c91);
                  }
                }

                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s0 = peg$c81;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c82);
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_29arrayIndex() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c92) {
          s1 = peg$c92;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c93);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_29newMustacheNameChar();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_29newMustacheNameChar();
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c17;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c18);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_30boundAttribute() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_30boundAttributeValue();

            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 33) {
                s5 = peg$c94;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c95);
                }
              }

              peg$silentFails--;

              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c96(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_30boundAttributeValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c54;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parse_30boundAttributeValueChar();

            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 32) {
                s5 = peg$c25;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c26);
                }
              }
            }

            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parse_30boundAttributeValueChar();

                if (s5 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 32) {
                    s5 = peg$c25;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c26);
                    }
                  }
                }
              }
            } else {
              s4 = peg$FAILED;
            }

            if (s4 !== peg$FAILED) {
              s3 = input.substring(s3, peg$currPos);
            } else {
              s3 = s4;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_30mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c97(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_30boundAttributeValueChar();

          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parse_30boundAttributeValueChar();
            }
          } else {
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        return s0;
      }

      function peg$parse_30boundAttributeValueChar() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_29newMustacheNameChar();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c98);
          }
        }

        return s0;
      }

      function peg$parse_30mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c99);
          }
        }

        return s0;
      }

      function peg$parse_12rawMustache() {
        var s0;
        s0 = peg$parse_12rawMustacheUnescaped();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustacheEscaped();
        }

        return s0;
      }

      function peg$parse_12rawMustacheUnescaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12tripleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12tripleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c100(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_12rawMustacheEscaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12doubleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12doubleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c101(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_12hashStacheOpen();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_1start();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_11nonMustache();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_1start();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_12hashStacheClose();

                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c101(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_12doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c103) {
          s0 = peg$c103;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c104);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c102);
          }
        }

        return s0;
      }

      function peg$parse_12tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c106) {
          s0 = peg$c106;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c107);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c105);
          }
        }

        return s0;
      }

      function peg$parse_12doubleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c109) {
          s0 = peg$c109;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c110);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c108);
          }
        }

        return s0;
      }

      function peg$parse_12tripleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c112) {
          s0 = peg$c112;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c113);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c111);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c115) {
          s0 = peg$c115;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c116);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c114);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c117);
          }
        }

        return s0;
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c118);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c120(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c119);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c123(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c122);
          }
        }

        return s0;
      }

      function peg$parse_13nonMustacheUnit() {
        var s0;
        s0 = peg$parse_13tripleOpen();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_13doubleOpen();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_13hashStacheOpen();

            if (s0 === peg$FAILED) {
              s0 = peg$parse_3anyDedent();

              if (s0 === peg$FAILED) {
                s0 = peg$parse_13TERM();
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_13singleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s0 = peg$c54;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c124);
          }
        }

        return s0;
      }

      function peg$parse_13doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c103) {
          s0 = peg$c103;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c104);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c125);
          }
        }

        return s0;
      }

      function peg$parse_13tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c106) {
          s0 = peg$c106;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c107);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c126);
          }
        }

        return s0;
      }

      function peg$parse_13hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c115) {
          s0 = peg$c115;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c116);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c127);
          }
        }

        return s0;
      }

      function peg$parse_13TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c128);
          }
        }

        return s0;
      }

      function peg$parse_31normalAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_31attributeTextNodes();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c129(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31attributeTextNodes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c36;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_31attributeTextNodesInner();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_31closingDoubleQuote();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c130(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c34;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_31attributeTextNodesInnerSingle();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_31closingSingleQuote();

              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c130(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_31closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c131);
          }
        }

        return s0;
      }

      function peg$parse_31closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 34) {
          s0 = peg$c36;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c132);
          }
        }

        return s0;
      }

      function peg$parse_31attributeTextNodesInner() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_31preAttrMustacheText();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_31preAttrMustacheText();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_31preAttrMustacheText();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c133(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31attributeTextNodesInnerSingle() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_31preAttrMustacheTextSingle();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_31preAttrMustacheTextSingle();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_31preAttrMustacheTextSingle();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c133(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheText() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_31preAttrMustacheUnit();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_31preAttrMustacheUnit();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheTextSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_31preAttrMustacheUnitSingle();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_31preAttrMustacheUnitSingle();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheUnit() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c36;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c37);
            }
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c134);
          }
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheUnitSingle() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c34;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c134);
          }
        }

        return s0;
      }

      function peg$parse_32simpleMustacheAttr() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_17pathIdNode();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c135(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_33spreadAttribute() {
        var s0, s1;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 13) === peg$c136) {
          s1 = peg$c136;
          peg$currPos += 13;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c137);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c138(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_34attribute() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_22actionAttribute();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_25booleanAttribute();

            if (s2 === peg$FAILED) {
              s2 = peg$parse_27booleanAttribute();

              if (s2 === peg$FAILED) {
                s2 = peg$parse_28boundAttributeWithSingleMustache();

                if (s2 === peg$FAILED) {
                  s2 = peg$parse_30boundAttribute();

                  if (s2 === peg$FAILED) {
                    s2 = peg$parse_31normalAttribute();

                    if (s2 === peg$FAILED) {
                      s2 = peg$parse_32simpleMustacheAttr();

                      if (s2 === peg$FAILED) {
                        s2 = peg$parse_33spreadAttribute();
                      }
                    }
                  }
                }
              }
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c139(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/boolean-attr", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _25start: peg$parse_25start
      },
          peg$startRuleFunction = peg$parse_25start,
          peg$c0 = /^[_a-zA-Z0-9\-]/,
          peg$c1 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c2 = /^[\x80-\xFF]/,
          peg$c3 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c4 = peg$otherExpectation("_24Key"),
          peg$c5 = ":",
          peg$c6 = peg$literalExpectation(":", false),
          peg$c7 = ".",
          peg$c8 = peg$literalExpectation(".", false),
          peg$c9 = "=",
          peg$c10 = peg$literalExpectation("=", false),
          peg$c11 = "true",
          peg$c12 = peg$literalExpectation("true", false),
          peg$c13 = "false",
          peg$c14 = peg$literalExpectation("false", false),
          peg$c15 = function (key, boolValue) {
        if (boolValue === 'true') {
          return [key];
        }
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_24key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c5;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c7;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c5;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c7;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        return s0;
      }

      function peg$parse_25start() {
        var s0;
        s0 = peg$parse_25booleanAttribute();
        return s0;
      }

      function peg$parse_25booleanAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_24key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c9;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c10);
            }
          }

          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c11) {
              s3 = peg$c11;
              peg$currPos += 4;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c12);
              }
            }

            if (s3 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c13) {
                s3 = peg$c13;
                peg$currPos += 5;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c15(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/bound-attr-with-mustache", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _28start: peg$parse_28start
      },
          peg$startRuleFunction = peg$parse_28start,
          peg$c0 = peg$otherExpectation("_11mustache expression"),
          peg$c1 = "{",
          peg$c2 = peg$literalExpectation("{", false),
          peg$c3 = /^[^}]/,
          peg$c4 = peg$classExpectation(["}"], true, false),
          peg$c5 = function (text) {
        return text;
      },
          peg$c6 = /^[ \t]/,
          peg$c7 = peg$classExpectation([" ", "\t"], false, false),
          peg$c8 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c9 = function (value) {
        return value;
      },
          peg$c10 = peg$otherExpectation("_21closing mustache"),
          peg$c11 = "}",
          peg$c12 = peg$literalExpectation("}", false),
          peg$c13 = /^[_a-zA-Z0-9\-]/,
          peg$c14 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c15 = /^[\x80-\xFF]/,
          peg$c16 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c17 = peg$otherExpectation("_26Attribute Key"),
          peg$c18 = ":",
          peg$c19 = peg$literalExpectation(":", false),
          peg$c20 = ".",
          peg$c21 = peg$literalExpectation(".", false),
          peg$c22 = "@",
          peg$c23 = peg$literalExpectation("@", false),
          peg$c24 = "$",
          peg$c25 = peg$literalExpectation("$", false),
          peg$c26 = "=",
          peg$c27 = peg$literalExpectation("=", false),
          peg$c28 = function (key, value) {
        value = value.trim(); // Class logic needs to be coalesced, except for conditional statements

        if (key === 'class') {
          if (value.indexOf('if') === 0 || value.indexOf('unless') === 0) {
            return builder.generateClassNameBinding(value);
          } else {
            return splitValueIntoClassBindings(value);
          }
        } else {
          return [builder.generateAssignedMustache(value, key)];
        }
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c3.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c3.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c6.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }

        return s0;
      }

      function peg$parse_21singleMustacheValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_21mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c9(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_21mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c11;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c10);
          }
        }

        return s0;
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c13.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c14);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c15.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        return s0;
      }

      function peg$parse_26key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c18;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c19);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c20;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c21);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s2 = peg$c22;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c23);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 36) {
                  s2 = peg$c24;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c25);
                  }
                }
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c18;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c19);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c20;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c21);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 64) {
                  s2 = peg$c22;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c23);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s2 = peg$c24;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c25);
                    }
                  }
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }

        return s0;
      }

      function peg$parse_28start() {
        var s0;
        s0 = peg$parse_28boundAttributeWithSingleMustache();
        return s0;
      }

      function peg$parse_28boundAttributeWithSingleMustache() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c26;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c27);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_21singleMustacheValue();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c28(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/bound-attr", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _30start: peg$parse_30start
      },
          peg$startRuleFunction = peg$parse_30start,
          peg$c0 = /^[_a-zA-Z0-9\-]/,
          peg$c1 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c2 = /^[\x80-\xFF]/,
          peg$c3 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c4 = peg$otherExpectation("_26Attribute Key"),
          peg$c5 = ":",
          peg$c6 = peg$literalExpectation(":", false),
          peg$c7 = ".",
          peg$c8 = peg$literalExpectation(".", false),
          peg$c9 = "@",
          peg$c10 = peg$literalExpectation("@", false),
          peg$c11 = "$",
          peg$c12 = peg$literalExpectation("$", false),
          peg$c13 = /^[ \t]/,
          peg$c14 = peg$classExpectation([" ", "\t"], false, false),
          peg$c15 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c16 = " ",
          peg$c17 = peg$literalExpectation(" ", false),
          peg$c18 = function (c) {
        return c;
      },
          peg$c19 = /^[\-_\/A-Za-z0-9]/,
          peg$c20 = peg$classExpectation(["-", "_", "/", ["A", "Z"], ["a", "z"], ["0", "9"]], false, false),
          peg$c21 = "::",
          peg$c22 = peg$literalExpectation("::", false),
          peg$c23 = ".[",
          peg$c24 = peg$literalExpectation(".[", false),
          peg$c25 = "]",
          peg$c26 = peg$literalExpectation("]", false),
          peg$c27 = "=",
          peg$c28 = peg$literalExpectation("=", false),
          peg$c29 = "!",
          peg$c30 = peg$literalExpectation("!", false),
          peg$c31 = function (key, value) {
        if (key === 'class') {
          return splitValueIntoClassBindings(value);
        } else {
          return [builder.generateAssignedMustache(value, key)];
        }
      },
          peg$c32 = "{",
          peg$c33 = peg$literalExpectation("{", false),
          peg$c34 = function (value) {
        return value.replace(/ *$/, '');
      },
          peg$c35 = peg$otherExpectation("_30valid attribute value"),
          peg$c36 = peg$otherExpectation("_30closing mustache"),
          peg$c37 = "}",
          peg$c38 = peg$literalExpectation("}", false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_26key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c5;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c7;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s2 = peg$c9;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 36) {
                  s2 = peg$c11;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c12);
                  }
                }
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c5;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c7;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 64) {
                  s2 = peg$c9;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s2 = peg$c11;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c12);
                    }
                  }
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c13.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c14);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }

        return s0;
      }

      function peg$parse_18nonSeparatorColon() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 58) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;

          if (input.charCodeAt(peg$currPos) === 32) {
            s3 = peg$c16;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c17);
            }
          }

          peg$silentFails--;

          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c18(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_29newMustacheNameChar() {
        var s0;

        if (peg$c19.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_29arrayIndex();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s0 = peg$c7;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s0 = peg$c9;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c21) {
                  s0 = peg$c21;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c22);
                  }
                }

                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s0 = peg$c11;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c12);
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_29arrayIndex() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c23) {
          s1 = peg$c23;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_29newMustacheNameChar();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_29newMustacheNameChar();
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c25;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c26);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_30start() {
        var s0;
        s0 = peg$parse_30boundAttribute();
        return s0;
      }

      function peg$parse_30boundAttribute() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c27;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_30boundAttributeValue();

            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 33) {
                s5 = peg$c29;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c30);
                }
              }

              peg$silentFails--;

              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c31(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_30boundAttributeValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c32;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c33);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parse_30boundAttributeValueChar();

            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 32) {
                s5 = peg$c16;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
            }

            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parse_30boundAttributeValueChar();

                if (s5 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 32) {
                    s5 = peg$c16;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                }
              }
            } else {
              s4 = peg$FAILED;
            }

            if (s4 !== peg$FAILED) {
              s3 = input.substring(s3, peg$currPos);
            } else {
              s3 = s4;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_30mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c34(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_30boundAttributeValueChar();

          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parse_30boundAttributeValueChar();
            }
          } else {
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        return s0;
      }

      function peg$parse_30boundAttributeValueChar() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_29newMustacheNameChar();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        return s0;
      }

      function peg$parse_30mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c37;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c36);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/in-tag", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _48start: peg$parse_48start
      },
          peg$startRuleFunction = peg$parse_48start,
          peg$c0 = function (v) {
        var last = v[v.length - 1];
        var idNode; // Support for data keywords that are prefixed with @ in the each
        // block helper such as @index, @key, @first, @last

        if (last.part.charAt(0) === '@') {
          last.part = last.part.slice(1);
          idNode = new AST.IdNode(v);
          var dataNode = new AST.DataNode(idNode);
          return dataNode;
        }

        var match;
        var suffixModifier; // FIXME probably need to handle this better?

        if (match = last.part.match(/!$/)) {
          last.part = 'unbound ' + last.part.slice(0, -1);
        }

        if (match = last.part.match(/[\?\^]$/)) {
          suffixModifier = match[0];
          throw "unhandled path terminated: " + suffixModifier;
        }

        return last.part;
      },
          peg$c1 = function (first, s, p) {
        return {
          part: p,
          separator: s
        };
      },
          peg$c2 = function (first, tail) {
        var ret = [{
          part: first
        }];

        for (var i = 0; i < tail.length; ++i) {
          ret.push(tail[i]);
        }

        return ret;
      },
          peg$c3 = peg$otherExpectation("_17PathIdent"),
          peg$c4 = "..",
          peg$c5 = peg$literalExpectation("..", false),
          peg$c6 = ".",
          peg$c7 = peg$literalExpectation(".", false),
          peg$c8 = /^[a-zA-Z0-9_$\-!?\^@]/,
          peg$c9 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "$", "-", "!", "?", "^", "@"], false, false),
          peg$c10 = "=",
          peg$c11 = peg$literalExpectation("=", false),
          peg$c12 = function (s) {
        return s;
      },
          peg$c13 = "[",
          peg$c14 = peg$literalExpectation("[", false),
          peg$c15 = /^[^\]]/,
          peg$c16 = peg$classExpectation(["]"], true, false),
          peg$c17 = "]",
          peg$c18 = peg$literalExpectation("]", false),
          peg$c19 = function (segmentLiteral) {
        return segmentLiteral;
      },
          peg$c20 = peg$otherExpectation("_17PathSeparator"),
          peg$c21 = /^[\/.]/,
          peg$c22 = peg$classExpectation(["/", "."], false, false),
          peg$c23 = ":",
          peg$c24 = peg$literalExpectation(":", false),
          peg$c25 = " ",
          peg$c26 = peg$literalExpectation(" ", false),
          peg$c27 = function (c) {
        return c;
      },
          peg$c28 = peg$otherExpectation("_19valid tag string"),
          peg$c29 = /^[_a-zA-Z0-9\-]/,
          peg$c30 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c31 = "@",
          peg$c32 = peg$literalExpectation("@", false),
          peg$c33 = function (p) {
        return p;
      },
          peg$c34 = "'",
          peg$c35 = peg$literalExpectation("'", false),
          peg$c36 = "\"",
          peg$c37 = peg$literalExpectation("\"", false),
          peg$c38 = peg$otherExpectation("_20Closing single quote"),
          peg$c39 = peg$otherExpectation("_20Closing double quote"),
          peg$c40 = peg$otherExpectation("_20string action attributes"),
          peg$c41 = /^[^"}]/,
          peg$c42 = peg$classExpectation(["\"", "}"], true, false),
          peg$c43 = /^[^'}]/,
          peg$c44 = peg$classExpectation(["'", "}"], true, false),
          peg$c45 = peg$otherExpectation("_20LineEnd"),
          peg$c46 = "\r",
          peg$c47 = peg$literalExpectation("\r", false),
          peg$c48 = peg$anyExpectation(),
          peg$c49 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c50 = "\n",
          peg$c51 = peg$literalExpectation("\n", false),
          peg$c52 = function (t) {
        return false;
      },
          peg$c53 = peg$otherExpectation("_11mustache expression"),
          peg$c54 = "{",
          peg$c55 = peg$literalExpectation("{", false),
          peg$c56 = /^[^}]/,
          peg$c57 = peg$classExpectation(["}"], true, false),
          peg$c58 = function (text) {
        return text;
      },
          peg$c59 = /^[ \t]/,
          peg$c60 = peg$classExpectation([" ", "\t"], false, false),
          peg$c61 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c62 = function (value) {
        return value;
      },
          peg$c63 = peg$otherExpectation("_21closing mustache"),
          peg$c64 = "}",
          peg$c65 = peg$literalExpectation("}", false),
          peg$c66 = function (event, mustacheNode) {
        var actionBody, parts;

        if (typeof mustacheNode === 'string') {
          actionBody = mustacheNode;
        } else {
          parts = mustacheNode[1].split(' ');

          if (parts.length === 1) {
            actionBody = '"' + parts[0] + '"';
          } else {
            actionBody = mustacheNode[1];
          }
        }

        var actionContent = [actionBody];

        if (actionBody.indexOf('action ') !== 0) {
          actionContent.unshift('action');
        }

        return buildActionEvent(event, actionContent);
      },
          peg$c67 = peg$otherExpectation("_22a valid JS event"),
          peg$c68 = function (event) {
        return isAliasEvent(event);
      },
          peg$c69 = function (event) {
        return event;
      },
          peg$c70 = function (id) {
        return id;
      },
          peg$c71 = function (value) {
        return value;
      },
          peg$c72 = /^[\x80-\xFF]/,
          peg$c73 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c74 = peg$otherExpectation("_24Key"),
          peg$c75 = "true",
          peg$c76 = peg$literalExpectation("true", false),
          peg$c77 = "false",
          peg$c78 = peg$literalExpectation("false", false),
          peg$c79 = function (key, boolValue) {
        if (boolValue === 'true') {
          return [key];
        }
      },
          peg$c80 = peg$otherExpectation("_26Attribute Key"),
          peg$c81 = "$",
          peg$c82 = peg$literalExpectation("$", false),
          peg$c83 = function (key, digits) {
        var value = parseInt(digits.join(""), 10);
        return [key, value];
      },
          peg$c84 = peg$otherExpectation("_27Valid numbers"),
          peg$c85 = /^[0-9]/,
          peg$c86 = peg$classExpectation([["0", "9"]], false, false),
          peg$c87 = function (key, value) {
        value = value.trim(); // Class logic needs to be coalesced, except for conditional statements

        if (key === 'class') {
          if (value.indexOf('if') === 0 || value.indexOf('unless') === 0) {
            return builder.generateClassNameBinding(value);
          } else {
            return splitValueIntoClassBindings(value);
          }
        } else {
          return [builder.generateAssignedMustache(value, key)];
        }
      },
          peg$c88 = /^[\-_\/A-Za-z0-9]/,
          peg$c89 = peg$classExpectation(["-", "_", "/", ["A", "Z"], ["a", "z"], ["0", "9"]], false, false),
          peg$c90 = "::",
          peg$c91 = peg$literalExpectation("::", false),
          peg$c92 = ".[",
          peg$c93 = peg$literalExpectation(".[", false),
          peg$c94 = "!",
          peg$c95 = peg$literalExpectation("!", false),
          peg$c96 = function (key, value) {
        if (key === 'class') {
          return splitValueIntoClassBindings(value);
        } else {
          return [builder.generateAssignedMustache(value, key)];
        }
      },
          peg$c97 = function (value) {
        return value.replace(/ *$/, '');
      },
          peg$c98 = peg$otherExpectation("_30valid attribute value"),
          peg$c99 = peg$otherExpectation("_30closing mustache"),
          peg$c100 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), false);
      },
          peg$c101 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), true);
      },
          peg$c102 = peg$otherExpectation("_12Double Mustache Open"),
          peg$c103 = "{{",
          peg$c104 = peg$literalExpectation("{{", false),
          peg$c105 = peg$otherExpectation("_12Triple Mustache Open"),
          peg$c106 = "{{{",
          peg$c107 = peg$literalExpectation("{{{", false),
          peg$c108 = peg$otherExpectation("_12Double Mustache Close"),
          peg$c109 = "}}",
          peg$c110 = peg$literalExpectation("}}", false),
          peg$c111 = peg$otherExpectation("_12Triple Mustache Close"),
          peg$c112 = "}}}",
          peg$c113 = peg$literalExpectation("}}}", false),
          peg$c114 = peg$otherExpectation("_12String Interpolation Open"),
          peg$c115 = "#{",
          peg$c116 = peg$literalExpectation("#{", false),
          peg$c117 = peg$otherExpectation("_12String Interpolation Close"),
          peg$c118 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c119 = peg$otherExpectation("_3DEDENT"),
          peg$c120 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c121 = function (t) {
        return '';
      },
          peg$c122 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c123 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c124 = peg$otherExpectation("_13Single Mustache Open"),
          peg$c125 = peg$otherExpectation("_13Double Mustache Open"),
          peg$c126 = peg$otherExpectation("_13Triple Mustache Open"),
          peg$c127 = peg$otherExpectation("_13String Interpolation Open"),
          peg$c128 = peg$otherExpectation("_13LineEnd"),
          peg$c129 = function (key, nodes) {
        var strings = [];
        nodes.forEach(function (node) {
          if (typeof node === 'string') {
            strings.push(node);
          } else {
            // FIXME here we transform a mustache attribute
            // This should be handled higher up instead, not here.
            // This happens when the attribute is something like:
            // src="{{unbound post.showLogoUrl}}".
            // key = "src", nodes[0] = "unbound post.showLogoUrl"
            if (node.escaped) {
              strings.push('{{' + node.content + '}}');
            } else {
              strings.push('{{{' + node.content + '}}}');
            }
          }
        });
        var result = [key, strings.join('')];
        return result;
      },
          peg$c130 = function (a) {
        return a;
      },
          peg$c131 = peg$otherExpectation("_31Closing Single Quote"),
          peg$c132 = peg$otherExpectation("_31Closing Double Quote"),
          peg$c133 = function (first, tail) {
        return flattenArray(first, tail);
      },
          peg$c134 = peg$otherExpectation("_31Valid quoted attribute value"),
          peg$c135 = function (key, value) {
        return [key, '{{' + value + '}}'];
      },
          peg$c136 = "...attributes",
          peg$c137 = peg$literalExpectation("...attributes", false),
          peg$c138 = function (spread) {
        return [spread];
      },
          peg$c139 = function (a) {
        if (!a) return [];else if (!a.length) return [a];else return a;
      },
          peg$c140 = function (a) {
        return a;
      },
          peg$c141 = peg$otherExpectation("_35LineEnd"),
          peg$c142 = peg$otherExpectation("_35INDENT"),
          peg$c143 = function (t) {
        return _preprocessor.INDENT_SYMBOL === t;
      },
          peg$c144 = peg$otherExpectation("_36CSS class"),
          peg$c145 = peg$otherExpectation("_37HTML ID"),
          peg$c146 = "#",
          peg$c147 = peg$literalExpectation("#", false),
          peg$c148 = function (c) {
        return c;
      },
          peg$c149 = function (s) {
        return {
          shorthand: s,
          id: true
        };
      },
          peg$c150 = function (s) {
        return {
          shorthand: s
        };
      },
          peg$c151 = function (shorthands) {
        var id,
            classes = [];

        for (var i = 0, len = shorthands.length; i < len; ++i) {
          var shorthand = shorthands[i];

          if (shorthand.id) {
            id = shorthand.shorthand;
          } else {
            classes.push(shorthand.shorthand);
          }
        }

        return [id, classes];
      },
          peg$c152 = function (m) {
        return builder.generateMustache(m, true);
      },
          peg$c153 = peg$otherExpectation("_4RequiredWhitespace"),
          peg$c154 = peg$otherExpectation("_6INDENT"),
          peg$c155 = peg$otherExpectation("_6DEDENT"),
          peg$c156 = peg$otherExpectation("_6LineEnd"),
          peg$c157 = "/",
          peg$c158 = peg$literalExpectation("/", false),
          peg$c159 = function (h, startingInTagMustaches, inTagMustaches, fullAttributes) {
        return parseInHtml(h, startingInTagMustaches.concat(inTagMustaches), fullAttributes);
      },
          peg$c160 = function (h, inTagMustaches, fullAttributes) {
        return parseInHtml(h, inTagMustaches, fullAttributes);
      },
          peg$c161 = function (h, s) {
        return h || s;
      },
          peg$c162 = function (tag) {
        return isKnownTag(tag);
      },
          peg$c163 = function (tag) {
        return tag;
      },
          peg$c164 = peg$otherExpectation("_41LineEnd"),
          peg$c165 = peg$otherExpectation("_41INDENT"),
          peg$c166 = "as",
          peg$c167 = peg$literalExpectation("as", false),
          peg$c168 = peg$otherExpectation("_42block param starting pipe"),
          peg$c169 = "|",
          peg$c170 = peg$literalExpectation("|", false),
          peg$c171 = peg$otherExpectation("_43Quoted string"),
          peg$c172 = /^[^'"]/,
          peg$c173 = peg$classExpectation(["'", "\""], true, false),
          peg$c174 = function (v) {
        return v;
      },
          peg$c175 = /^[\/(]/,
          peg$c176 = peg$classExpectation(["/", "("], false, false),
          peg$c177 = peg$otherExpectation("_45block params closing pipe"),
          peg$c178 = function (params) {
        return params;
      },
          peg$c179 = peg$otherExpectation("_46block param"),
          peg$c180 = function (h, blockParams, inTagMustaches, fullAttributes) {
        return parseInHtml(h, inTagMustaches, fullAttributes, blockParams);
      },
          peg$c181 = function (h, inTagMustaches, fullAttributes, blockParams) {
        return parseInHtml(h, inTagMustaches, fullAttributes, blockParams);
      },
          peg$c182 = function (h, s) {
        return h || s;
      },
          peg$c183 = "%",
          peg$c184 = peg$literalExpectation("%", false),
          peg$c185 = function (s) {
        return s;
      },
          peg$c186 = peg$otherExpectation("_47LineEnd"),
          peg$c187 = peg$otherExpectation("_47INDENT"),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_17pathIdNode() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_17path();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_17path() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_17pathIdent();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_17separator();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_17pathIdent();

            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c1(s1, s4, s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_17separator();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_17pathIdent();

              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c1(s1, s4, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c2(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_17pathIdent() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s0 = peg$c6;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];

            if (peg$c8.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c8.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c9);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s1 = input.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }

            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c10;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c11);
                }
              }

              peg$silentFails--;

              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }

              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c13;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];

                if (peg$c15.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c16);
                  }
                }

                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c15.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c16);
                    }
                  }
                }

                if (s3 !== peg$FAILED) {
                  s2 = input.substring(s2, peg$currPos);
                } else {
                  s2 = s3;
                }

                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c17;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c18);
                    }
                  }

                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c19(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_17separator() {
        var s0, s1;
        peg$silentFails++;

        if (peg$c21.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_18nonSeparatorColon() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 58) {
          s1 = peg$c23;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;

          if (input.charCodeAt(peg$currPos) === 32) {
            s3 = peg$c25;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c26);
            }
          }

          peg$silentFails--;

          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_19tagString() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_19tagChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_19tagChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        return s0;
      }

      function peg$parse_19tagChar() {
        var s0;

        if (peg$c29.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 64) {
              s0 = peg$c31;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_20stringWithQuotes() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_20singleQuoteString();

        if (s1 === peg$FAILED) {
          s1 = peg$parse_20doubleQuoteString();
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_20singleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c34;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashSingleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c34;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c35);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20doubleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c36;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashDoubleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c36;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }

        return s0;
      }

      function peg$parse_20closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }

        return s0;
      }

      function peg$parse_20hashDoubleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c41.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c42);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c41.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c42);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_20hashSingleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c43.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c44);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c43.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c44);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_20TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }

        return s0;
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c54;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c56.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c57);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c56.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c57);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c58(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c53);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c59.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c60);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }

        return s0;
      }

      function peg$parse_21singleMustacheValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c54;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_21mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c62(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_21mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c63);
          }
        }

        return s0;
      }

      function peg$parse_22actionAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_22knownAliasEvent();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_22actionValue();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_22knownAliasEvent() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_19tagString();

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c68(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c69(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c67);
          }
        }

        return s0;
      }

      function peg$parse_22actionValue() {
        var s0, s1;
        s0 = peg$parse_20stringWithQuotes();

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_17pathIdNode();

          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c70(s1);
          }

          s0 = s1;

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_21singleMustacheValue();

            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c71(s1);
            }

            s0 = s1;
          }
        }

        return s0;
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c29.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c72.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c73);
          }
        }

        return s0;
      }

      function peg$parse_24key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c23;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c6;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c23;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c6;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c7);
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c74);
          }
        }

        return s0;
      }

      function peg$parse_25booleanAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_24key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c75) {
              s3 = peg$c75;
              peg$currPos += 4;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }

            if (s3 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c77) {
                s3 = peg$c77;
                peg$currPos += 5;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c78);
                }
              }
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c79(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_26key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c23;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c6;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s2 = peg$c31;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 36) {
                  s2 = peg$c81;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c82);
                  }
                }
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c23;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c6;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c7);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 64) {
                  s2 = peg$c31;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c32);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s2 = peg$c81;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c82);
                    }
                  }
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c80);
          }
        }

        return s0;
      }

      function peg$parse_27booleanAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_27digits();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c83(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_27digits() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];

        if (peg$c85.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c86);
          }
        }

        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);

            if (peg$c85.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c86);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c84);
          }
        }

        return s0;
      }

      function peg$parse_28boundAttributeWithSingleMustache() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_21singleMustacheValue();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c87(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_29newMustacheNameChar() {
        var s0;

        if (peg$c88.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c89);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_29arrayIndex();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s0 = peg$c6;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s0 = peg$c31;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }

              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c90) {
                  s0 = peg$c90;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c91);
                  }
                }

                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s0 = peg$c81;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c82);
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_29arrayIndex() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c92) {
          s1 = peg$c92;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c93);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_29newMustacheNameChar();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_29newMustacheNameChar();
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c17;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c18);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_30boundAttribute() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_30boundAttributeValue();

            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 33) {
                s5 = peg$c94;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c95);
                }
              }

              peg$silentFails--;

              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c96(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_30boundAttributeValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c54;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parse_30boundAttributeValueChar();

            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 32) {
                s5 = peg$c25;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c26);
                }
              }
            }

            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parse_30boundAttributeValueChar();

                if (s5 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 32) {
                    s5 = peg$c25;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c26);
                    }
                  }
                }
              }
            } else {
              s4 = peg$FAILED;
            }

            if (s4 !== peg$FAILED) {
              s3 = input.substring(s3, peg$currPos);
            } else {
              s3 = s4;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_30mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c97(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_30boundAttributeValueChar();

          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parse_30boundAttributeValueChar();
            }
          } else {
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        return s0;
      }

      function peg$parse_30boundAttributeValueChar() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_29newMustacheNameChar();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c98);
          }
        }

        return s0;
      }

      function peg$parse_30mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c99);
          }
        }

        return s0;
      }

      function peg$parse_12rawMustache() {
        var s0;
        s0 = peg$parse_12rawMustacheUnescaped();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustacheEscaped();
        }

        return s0;
      }

      function peg$parse_12rawMustacheUnescaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12tripleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12tripleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c100(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_12rawMustacheEscaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12doubleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12doubleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c101(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_12hashStacheOpen();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_1start();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_11nonMustache();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_1start();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_12hashStacheClose();

                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c101(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_12doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c103) {
          s0 = peg$c103;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c104);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c102);
          }
        }

        return s0;
      }

      function peg$parse_12tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c106) {
          s0 = peg$c106;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c107);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c105);
          }
        }

        return s0;
      }

      function peg$parse_12doubleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c109) {
          s0 = peg$c109;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c110);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c108);
          }
        }

        return s0;
      }

      function peg$parse_12tripleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c112) {
          s0 = peg$c112;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c113);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c111);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c115) {
          s0 = peg$c115;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c116);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c114);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c117);
          }
        }

        return s0;
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c118);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c120(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c119);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c123(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c122);
          }
        }

        return s0;
      }

      function peg$parse_13nonMustacheUnit() {
        var s0;
        s0 = peg$parse_13tripleOpen();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_13doubleOpen();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_13hashStacheOpen();

            if (s0 === peg$FAILED) {
              s0 = peg$parse_3anyDedent();

              if (s0 === peg$FAILED) {
                s0 = peg$parse_13TERM();
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_13singleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s0 = peg$c54;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c124);
          }
        }

        return s0;
      }

      function peg$parse_13doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c103) {
          s0 = peg$c103;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c104);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c125);
          }
        }

        return s0;
      }

      function peg$parse_13tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c106) {
          s0 = peg$c106;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c107);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c126);
          }
        }

        return s0;
      }

      function peg$parse_13hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c115) {
          s0 = peg$c115;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c116);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c127);
          }
        }

        return s0;
      }

      function peg$parse_13TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c128);
          }
        }

        return s0;
      }

      function peg$parse_31normalAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_31attributeTextNodes();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c129(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31attributeTextNodes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c36;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_31attributeTextNodesInner();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_31closingDoubleQuote();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c130(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c34;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_31attributeTextNodesInnerSingle();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_31closingSingleQuote();

              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c130(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_31closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c131);
          }
        }

        return s0;
      }

      function peg$parse_31closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 34) {
          s0 = peg$c36;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c132);
          }
        }

        return s0;
      }

      function peg$parse_31attributeTextNodesInner() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_31preAttrMustacheText();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_31preAttrMustacheText();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_31preAttrMustacheText();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c133(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31attributeTextNodesInnerSingle() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_31preAttrMustacheTextSingle();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_31preAttrMustacheTextSingle();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_31preAttrMustacheTextSingle();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c133(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheText() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_31preAttrMustacheUnit();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_31preAttrMustacheUnit();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheTextSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_31preAttrMustacheUnitSingle();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_31preAttrMustacheUnitSingle();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheUnit() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c36;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c37);
            }
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c134);
          }
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheUnitSingle() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c34;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c134);
          }
        }

        return s0;
      }

      function peg$parse_32simpleMustacheAttr() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_17pathIdNode();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c135(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_33spreadAttribute() {
        var s0, s1;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 13) === peg$c136) {
          s1 = peg$c136;
          peg$currPos += 13;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c137);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c138(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_34attribute() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_22actionAttribute();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_25booleanAttribute();

            if (s2 === peg$FAILED) {
              s2 = peg$parse_27booleanAttribute();

              if (s2 === peg$FAILED) {
                s2 = peg$parse_28boundAttributeWithSingleMustache();

                if (s2 === peg$FAILED) {
                  s2 = peg$parse_30boundAttribute();

                  if (s2 === peg$FAILED) {
                    s2 = peg$parse_31normalAttribute();

                    if (s2 === peg$FAILED) {
                      s2 = peg$parse_32simpleMustacheAttr();

                      if (s2 === peg$FAILED) {
                        s2 = peg$parse_33spreadAttribute();
                      }
                    }
                  }
                }
              }
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c139(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_35bracketedAttribute() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_35INDENT();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_35INDENT();
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_34attribute();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_35TERM();

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_35TERM();
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c140(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_35TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c141);
          }
        }

        return s0;
      }

      function peg$parse_35INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c143(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c142);
          }
        }

        return s0;
      }

      function peg$parse_36cssIdentifier() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_36ident();
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c144);
          }
        }

        return s0;
      }

      function peg$parse_36ident() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_23nmchar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_37idShorthand() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c146;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c147);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_36cssIdentifier();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c148(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c145);
          }
        }

        return s0;
      }

      function peg$parse_38classShorthand() {
        var s0, s1, s2;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c6;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_36cssIdentifier();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_39shorthandAttributes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parse_37idShorthand();

        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c149(s3);
        }

        s2 = s3;

        if (s2 === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parse_38classShorthand();

          if (s3 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c150(s3);
          }

          s2 = s3;
        }

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parse_37idShorthand();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c149(s3);
            }

            s2 = s3;

            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parse_38classShorthand();

              if (s3 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c150(s3);
              }

              s2 = s3;
            }
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c151(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_40inTagMustache() {
        var s0;
        s0 = peg$parse_40builtSingle();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustache();
        }

        return s0;
      }

      function peg$parse_40builtSingle() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_21singleMustacheValue();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c152(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_4start() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_0start();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_0start();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c153);
          }
        }

        return s0;
      }

      function peg$parse_6lineContent() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_6lineChar();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_6lineChar();
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_6lineChar() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_6INDENT();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_6DEDENT();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_6TERM();
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_6INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c143(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c154);
          }
        }

        return s0;
      }

      function peg$parse_6DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c120(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c155);
          }
        }

        return s0;
      }

      function peg$parse_6TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c156);
          }
        }

        return s0;
      }

      function peg$parse_10inlineComment() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 47) {
            s2 = peg$c157;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c158);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_6lineContent();

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_41tagHtml() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
        s0 = peg$currPos;
        s1 = peg$parse_41htmlStart();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_40inTagMustache();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_40inTagMustache();
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_4start();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 91) {
                s4 = peg$c13;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parse_41TERM();

                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parse_41TERM();
                }

                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parse_40inTagMustache();

                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parse_40inTagMustache();
                  }

                  if (s6 !== peg$FAILED) {
                    s7 = [];
                    s8 = peg$parse_35bracketedAttribute();

                    if (s8 !== peg$FAILED) {
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        s8 = peg$parse_35bracketedAttribute();
                      }
                    } else {
                      s7 = peg$FAILED;
                    }

                    if (s7 !== peg$FAILED) {
                      s8 = [];
                      s9 = peg$currPos;
                      s10 = peg$parse_1start();

                      if (s10 !== peg$FAILED) {
                        s11 = peg$parse_10inlineComment();

                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_1start();

                          if (s12 !== peg$FAILED) {
                            s13 = peg$parse_41TERM();

                            if (s13 !== peg$FAILED) {
                              s10 = [s10, s11, s12, s13];
                              s9 = s10;
                            } else {
                              peg$currPos = s9;
                              s9 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }

                      while (s9 !== peg$FAILED) {
                        s8.push(s9);
                        s9 = peg$currPos;
                        s10 = peg$parse_1start();

                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_10inlineComment();

                          if (s11 !== peg$FAILED) {
                            s12 = peg$parse_1start();

                            if (s12 !== peg$FAILED) {
                              s13 = peg$parse_41TERM();

                              if (s13 !== peg$FAILED) {
                                s10 = [s10, s11, s12, s13];
                                s9 = s10;
                              } else {
                                peg$currPos = s9;
                                s9 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s9;
                              s9 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      }

                      if (s8 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c159(s1, s2, s6, s7);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_41htmlStart();

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parse_40inTagMustache();

            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parse_40inTagMustache();
            }

            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parse_34attribute();

              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_34attribute();
              }

              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c160(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_41htmlStart() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_41knownTagName();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_39shorthandAttributes();

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s3 = peg$c157;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c158);
              }
            }

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = peg$currPos;
              s4 = peg$c161(s1, s2);

              if (s4) {
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                s1 = [s1, s2, s3, s4];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_41knownTagName() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_19tagString();

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c162(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c163(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_41TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c164);
          }
        }

        return s0;
      }

      function peg$parse_41INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c143(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c165);
          }
        }

        return s0;
      }

      function peg$parse_42blockStart() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c166) {
          s1 = peg$c166;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c167);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_42blockStartPipe();

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_42blockStartPipe() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c169;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c170);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c168);
          }
        }

        return s0;
      }

      function peg$parse_43quotedString() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s2 = peg$c36;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_43stringWithoutDouble();

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s4 = peg$c36;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }

            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c34;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_43stringWithoutSingle();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s4 = peg$c34;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c35);
                }
              }

              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c171);
          }
        }

        return s0;
      }

      function peg$parse_43stringWithoutDouble() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c34;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c34;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c35);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43stringWithoutSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c36;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c37);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s2 = peg$c36;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43inStringChar() {
        var s0;

        if (peg$c172.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c173);
          }
        }

        return s0;
      }

      function peg$parse_44newMustacheAttrValue() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_44invalidValueStartChar();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_42blockStart();
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_43quotedString();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_44valuePath();
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_1start();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c174(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_44valuePath() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_29newMustacheNameChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_29newMustacheNameChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_44invalidValueStartChar() {
        var s0;

        if (peg$c175.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c176);
          }
        }

        return s0;
      }

      function peg$parse_45blockEnd() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c169;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c170);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c177);
          }
        }

        return s0;
      }

      function peg$parse_46blockParams() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_42blockStart();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_46blockParamName();

            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_46blockParamName();
              }
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_45blockEnd();

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c178(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_46blockParamName() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_44newMustacheAttrValue();
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c179);
          }
        }

        return s0;
      }

      function peg$parse_47inHtmlTag() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parse_47htmlStart();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_47blockParams();

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_4start();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 91) {
                s4 = peg$c13;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parse_47TERM();

                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parse_47TERM();
                }

                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parse_40inTagMustache();

                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parse_40inTagMustache();
                  }

                  if (s6 !== peg$FAILED) {
                    s7 = [];
                    s8 = peg$parse_35bracketedAttribute();

                    while (s8 !== peg$FAILED) {
                      s7.push(s8);
                      s8 = peg$parse_35bracketedAttribute();
                    }

                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c180(s1, s2, s6, s7);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_47htmlStart();

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parse_40inTagMustache();

            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parse_40inTagMustache();
            }

            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parse_34attribute();

              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_34attribute();
              }

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_47blockParams();

                if (s4 === peg$FAILED) {
                  s4 = null;
                }

                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c181(s1, s2, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_47htmlStart() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_47componentTag();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_39shorthandAttributes();

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s3 = peg$c157;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c158);
              }
            }

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = peg$currPos;
              s4 = peg$c182(s1, s2);

              if (s4) {
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                s1 = [s1, s2, s3, s4];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_47componentTag() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 37) {
          s1 = peg$c183;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c184);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_19tagString();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c185(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_47blockParams() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_46blockParams();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c178(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_47TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c186);
          }
        }

        return s0;
      }

      function peg$parse_47INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c143(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c187);
          }
        }

        return s0;
      }

      function peg$parse_48start() {
        var s0;
        s0 = peg$parse_41tagHtml();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_47inHtmlTag();
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      function parseInHtml(h, inTagMustaches, fullAttributes, blockParams) {
        var tagName = h[0] || 'div',
            shorthandAttributes = h[1] || [],
            id = shorthandAttributes[0],
            classes = shorthandAttributes[1] || [];
        var i, l;
        var elementNode = builder.generateElement(tagName);
        builder.enter(elementNode);

        for (i = 0, l = classes.length; i < l; i++) {
          if (classes[i].type === 'classNameBinding') {
            builder.add('classNameBindings', classes[i]);
          } else {
            builder.classNameBinding(':' + classes[i]);
          }
        }

        if (id) {
          builder.attribute('id', id);
        }

        for (i = 0; i < inTagMustaches.length; ++i) {
          builder.add('attrStaches', inTagMustaches[i]);
        }

        for (i = 0; i < fullAttributes.length; ++i) {
          var currentAttr = fullAttributes[i];

          if (Array.isArray(currentAttr) && typeof currentAttr[0] === 'string') {
            // a "normalAttribute", [attrName, attrContent]
            if (currentAttr.length) {
              // a boolean false attribute will be []
              // skip classes now, coalesce them later
              if (currentAttr[0] === 'class') {
                builder.classNameBinding(':' + currentAttr[1]);
              } else {
                builder.attribute(currentAttr[0], currentAttr[1]);
              }
            }
          } else if (Array.isArray(currentAttr)) {
            currentAttr.forEach(function (attrNode) {
              builder.add(attrNode.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', attrNode);
            });
          } else {
            builder.add(currentAttr.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', currentAttr);
          }
        }

        if (blockParams && blockParams.length > 0) {
          var joinedParams = blockParams.join(' ');
          var tagString = 'as |' + joinedParams + '|';
          builder.inTagText(tagString);
        }
      }

      function isKnownTag(tag) {
        return !!_tags.default[tag];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/nested-text-nodes", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _49start: peg$parse_49start
      },
          peg$startRuleFunction = peg$parse_49start,
          peg$c0 = peg$otherExpectation("_11mustache expression"),
          peg$c1 = "{",
          peg$c2 = peg$literalExpectation("{", false),
          peg$c3 = /^[^}]/,
          peg$c4 = peg$classExpectation(["}"], true, false),
          peg$c5 = function (text) {
        return text;
      },
          peg$c6 = /^[ \t]/,
          peg$c7 = peg$classExpectation([" ", "\t"], false, false),
          peg$c8 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c9 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), false);
      },
          peg$c10 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), true);
      },
          peg$c11 = peg$otherExpectation("_12Double Mustache Open"),
          peg$c12 = "{{",
          peg$c13 = peg$literalExpectation("{{", false),
          peg$c14 = peg$otherExpectation("_12Triple Mustache Open"),
          peg$c15 = "{{{",
          peg$c16 = peg$literalExpectation("{{{", false),
          peg$c17 = peg$otherExpectation("_12Double Mustache Close"),
          peg$c18 = "}}",
          peg$c19 = peg$literalExpectation("}}", false),
          peg$c20 = peg$otherExpectation("_12Triple Mustache Close"),
          peg$c21 = "}}}",
          peg$c22 = peg$literalExpectation("}}}", false),
          peg$c23 = peg$otherExpectation("_12String Interpolation Open"),
          peg$c24 = "#{",
          peg$c25 = peg$literalExpectation("#{", false),
          peg$c26 = peg$otherExpectation("_12String Interpolation Close"),
          peg$c27 = "}",
          peg$c28 = peg$literalExpectation("}", false),
          peg$c29 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c30 = peg$otherExpectation("_3DEDENT"),
          peg$c31 = peg$anyExpectation(),
          peg$c32 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c33 = function (t) {
        return '';
      },
          peg$c34 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c35 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c36 = peg$otherExpectation("_13Single Mustache Open"),
          peg$c37 = peg$otherExpectation("_13Double Mustache Open"),
          peg$c38 = peg$otherExpectation("_13Triple Mustache Open"),
          peg$c39 = peg$otherExpectation("_13String Interpolation Open"),
          peg$c40 = peg$otherExpectation("_13LineEnd"),
          peg$c41 = "\r",
          peg$c42 = peg$literalExpectation("\r", false),
          peg$c43 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c44 = "\n",
          peg$c45 = peg$literalExpectation("\n", false),
          peg$c46 = function (t) {
        return false;
      },
          peg$c47 = function (first, tail) {
        return flattenArray(first, tail);
      },
          peg$c48 = function (c) {
        return c;
      },
          peg$c49 = peg$otherExpectation("_14LineEnd"),
          peg$c50 = peg$otherExpectation("_4RequiredWhitespace"),
          peg$c51 = function (s) {
        return s;
      },
          peg$c52 = peg$otherExpectation("_5INDENT"),
          peg$c53 = function (t) {
        return _preprocessor.INDENT_SYMBOL === t;
      },
          peg$c54 = function (nodes) {
        return nodes;
      },
          peg$c55 = function () {
        return [];
      },
          peg$c56 = peg$otherExpectation("_2LineEnd"),
          peg$c57 = " ",
          peg$c58 = peg$literalExpectation(" ", false),
          peg$c59 = function (ret, multilineContent) {
        if (multilineContent) {
          multilineContent = multilineContent[1];

          for (var i = 0, len = multilineContent.length; i < len; ++i) {
            ret.push(' ');
            ret = ret.concat(multilineContent[i]);
          }
        }

        return ret;
      },
          peg$c60 = peg$otherExpectation("_49DEDENT"),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c3.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c3.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c6.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }

        return s0;
      }

      function peg$parse_12rawMustache() {
        var s0;
        s0 = peg$parse_12rawMustacheUnescaped();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustacheEscaped();
        }

        return s0;
      }

      function peg$parse_12rawMustacheUnescaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12tripleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12tripleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c9(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_12rawMustacheEscaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12doubleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12doubleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c10(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_12hashStacheOpen();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_1start();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_11nonMustache();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_1start();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_12hashStacheClose();

                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c10(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_12doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c12) {
          s0 = peg$c12;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c11);
          }
        }

        return s0;
      }

      function peg$parse_12tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c15) {
          s0 = peg$c15;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c14);
          }
        }

        return s0;
      }

      function peg$parse_12doubleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c18) {
          s0 = peg$c18;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c19);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }

        return s0;
      }

      function peg$parse_12tripleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c21) {
          s0 = peg$c21;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c24) {
          s0 = peg$c24;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c23);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c27;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }

        return s0;
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c29);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c31);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c32(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c31);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c35(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c34);
          }
        }

        return s0;
      }

      function peg$parse_13nonMustacheUnit() {
        var s0;
        s0 = peg$parse_13tripleOpen();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_13doubleOpen();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_13hashStacheOpen();

            if (s0 === peg$FAILED) {
              s0 = peg$parse_3anyDedent();

              if (s0 === peg$FAILED) {
                s0 = peg$parse_13TERM();
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_13singleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s0 = peg$c1;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c36);
          }
        }

        return s0;
      }

      function peg$parse_13doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c12) {
          s0 = peg$c12;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        return s0;
      }

      function peg$parse_13tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c15) {
          s0 = peg$c15;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }

        return s0;
      }

      function peg$parse_13hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c24) {
          s0 = peg$c24;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }

        return s0;
      }

      function peg$parse_13TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c43(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c44;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c45);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c46(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_14textNodes() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_14preMustacheText();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_14preMustacheText();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_14preMustacheText();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_14TERM();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c47(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_14preMustacheText() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_14preMustacheUnit();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_14preMustacheUnit();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_14preMustacheUnit() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();
        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c48(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_14TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c43(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c44;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c45);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c46(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c49);
          }
        }

        return s0;
      }

      function peg$parse_4start() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_0start();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_0start();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c50);
          }
        }

        return s0;
      }

      function peg$parse_5indentation() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_5INDENT();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_4start();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c51(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_5INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c31);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c53(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c52);
          }
        }

        return s0;
      }

      function peg$parse_15whitespaceableTextNodes() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_5indentation();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_14textNodes();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_15whitespaceableTextNodes();

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_15whitespaceableTextNodes();
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_3anyDedent();

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c54(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_14textNodes();
        }

        return s0;
      }

      function peg$parse_2blankLine() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_2TERM();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c55();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_2TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c43(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c44;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c45);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c46(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c56);
          }
        }

        return s0;
      }

      function peg$parse_49start() {
        var s0;
        s0 = peg$parse_49htmlNestedTextNodes();
        return s0;
      }

      function peg$parse_49htmlNestedTextNodes() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 32) {
          s1 = peg$c57;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c58);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_14textNodes();

          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parse_5indentation();

            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parse_15whitespaceableTextNodes();

              if (s6 !== peg$FAILED) {
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parse_15whitespaceableTextNodes();
                }
              } else {
                s5 = peg$FAILED;
              }

              if (s5 !== peg$FAILED) {
                s6 = peg$parse_49DEDENT();

                if (s6 !== peg$FAILED) {
                  s4 = [s4, s5, s6];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c59(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_49DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c31);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c32(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c60);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      function parseInHtml(h, inTagMustaches, fullAttributes, blockParams) {
        var tagName = h[0] || 'div',
            shorthandAttributes = h[1] || [],
            id = shorthandAttributes[0],
            classes = shorthandAttributes[1] || [];
        var i, l;
        var elementNode = builder.generateElement(tagName);
        builder.enter(elementNode);

        for (i = 0, l = classes.length; i < l; i++) {
          if (classes[i].type === 'classNameBinding') {
            builder.add('classNameBindings', classes[i]);
          } else {
            builder.classNameBinding(':' + classes[i]);
          }
        }

        if (id) {
          builder.attribute('id', id);
        }

        for (i = 0; i < inTagMustaches.length; ++i) {
          builder.add('attrStaches', inTagMustaches[i]);
        }

        for (i = 0; i < fullAttributes.length; ++i) {
          var currentAttr = fullAttributes[i];

          if (Array.isArray(currentAttr) && typeof currentAttr[0] === 'string') {
            // a "normalAttribute", [attrName, attrContent]
            if (currentAttr.length) {
              // a boolean false attribute will be []
              // skip classes now, coalesce them later
              if (currentAttr[0] === 'class') {
                builder.classNameBinding(':' + currentAttr[1]);
              } else {
                builder.attribute(currentAttr[0], currentAttr[1]);
              }
            }
          } else if (Array.isArray(currentAttr)) {
            currentAttr.forEach(function (attrNode) {
              builder.add(attrNode.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', attrNode);
            });
          } else {
            builder.add(currentAttr.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', currentAttr);
          }
        }

        if (blockParams && blockParams.length > 0) {
          var joinedParams = blockParams.join(' ');
          var tagString = 'as |' + joinedParams + '|';
          builder.inTagText(tagString);
        }
      }

      function isKnownTag(tag) {
        return !!_tags.default[tag];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/normal-attribute", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _31start: peg$parse_31start
      },
          peg$startRuleFunction = peg$parse_31start,
          peg$c0 = peg$otherExpectation("_11mustache expression"),
          peg$c1 = "{",
          peg$c2 = peg$literalExpectation("{", false),
          peg$c3 = /^[^}]/,
          peg$c4 = peg$classExpectation(["}"], true, false),
          peg$c5 = function (text) {
        return text;
      },
          peg$c6 = /^[ \t]/,
          peg$c7 = peg$classExpectation([" ", "\t"], false, false),
          peg$c8 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c9 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), false);
      },
          peg$c10 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), true);
      },
          peg$c11 = peg$otherExpectation("_12Double Mustache Open"),
          peg$c12 = "{{",
          peg$c13 = peg$literalExpectation("{{", false),
          peg$c14 = peg$otherExpectation("_12Triple Mustache Open"),
          peg$c15 = "{{{",
          peg$c16 = peg$literalExpectation("{{{", false),
          peg$c17 = peg$otherExpectation("_12Double Mustache Close"),
          peg$c18 = "}}",
          peg$c19 = peg$literalExpectation("}}", false),
          peg$c20 = peg$otherExpectation("_12Triple Mustache Close"),
          peg$c21 = "}}}",
          peg$c22 = peg$literalExpectation("}}}", false),
          peg$c23 = peg$otherExpectation("_12String Interpolation Open"),
          peg$c24 = "#{",
          peg$c25 = peg$literalExpectation("#{", false),
          peg$c26 = peg$otherExpectation("_12String Interpolation Close"),
          peg$c27 = "}",
          peg$c28 = peg$literalExpectation("}", false),
          peg$c29 = /^[_a-zA-Z0-9\-]/,
          peg$c30 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c31 = /^[\x80-\xFF]/,
          peg$c32 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c33 = peg$otherExpectation("_26Attribute Key"),
          peg$c34 = ":",
          peg$c35 = peg$literalExpectation(":", false),
          peg$c36 = ".",
          peg$c37 = peg$literalExpectation(".", false),
          peg$c38 = "@",
          peg$c39 = peg$literalExpectation("@", false),
          peg$c40 = "$",
          peg$c41 = peg$literalExpectation("$", false),
          peg$c42 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c43 = peg$otherExpectation("_3DEDENT"),
          peg$c44 = peg$anyExpectation(),
          peg$c45 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c46 = function (t) {
        return '';
      },
          peg$c47 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c48 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c49 = peg$otherExpectation("_13Single Mustache Open"),
          peg$c50 = peg$otherExpectation("_13Double Mustache Open"),
          peg$c51 = peg$otherExpectation("_13Triple Mustache Open"),
          peg$c52 = peg$otherExpectation("_13String Interpolation Open"),
          peg$c53 = peg$otherExpectation("_13LineEnd"),
          peg$c54 = "\r",
          peg$c55 = peg$literalExpectation("\r", false),
          peg$c56 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c57 = "\n",
          peg$c58 = peg$literalExpectation("\n", false),
          peg$c59 = function (t) {
        return false;
      },
          peg$c60 = "=",
          peg$c61 = peg$literalExpectation("=", false),
          peg$c62 = function (key, nodes) {
        var strings = [];
        nodes.forEach(function (node) {
          if (typeof node === 'string') {
            strings.push(node);
          } else {
            // FIXME here we transform a mustache attribute
            // This should be handled higher up instead, not here.
            // This happens when the attribute is something like:
            // src="{{unbound post.showLogoUrl}}".
            // key = "src", nodes[0] = "unbound post.showLogoUrl"
            if (node.escaped) {
              strings.push('{{' + node.content + '}}');
            } else {
              strings.push('{{{' + node.content + '}}}');
            }
          }
        });
        var result = [key, strings.join('')];
        return result;
      },
          peg$c63 = "\"",
          peg$c64 = peg$literalExpectation("\"", false),
          peg$c65 = function (a) {
        return a;
      },
          peg$c66 = "'",
          peg$c67 = peg$literalExpectation("'", false),
          peg$c68 = peg$otherExpectation("_31Closing Single Quote"),
          peg$c69 = peg$otherExpectation("_31Closing Double Quote"),
          peg$c70 = function (first, tail) {
        return flattenArray(first, tail);
      },
          peg$c71 = peg$otherExpectation("_31Valid quoted attribute value"),
          peg$c72 = function (c) {
        return c;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c3.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c3.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c6.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }

        return s0;
      }

      function peg$parse_12rawMustache() {
        var s0;
        s0 = peg$parse_12rawMustacheUnescaped();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustacheEscaped();
        }

        return s0;
      }

      function peg$parse_12rawMustacheUnescaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12tripleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12tripleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c9(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_12rawMustacheEscaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12doubleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12doubleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c10(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_12hashStacheOpen();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_1start();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_11nonMustache();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_1start();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_12hashStacheClose();

                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c10(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_12doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c12) {
          s0 = peg$c12;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c11);
          }
        }

        return s0;
      }

      function peg$parse_12tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c15) {
          s0 = peg$c15;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c14);
          }
        }

        return s0;
      }

      function peg$parse_12doubleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c18) {
          s0 = peg$c18;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c19);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }

        return s0;
      }

      function peg$parse_12tripleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c21) {
          s0 = peg$c21;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c24) {
          s0 = peg$c24;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c23);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c27;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }

        return s0;
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c29.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c31.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c32);
          }
        }

        return s0;
      }

      function peg$parse_26key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c34;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c36;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s2 = peg$c38;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c39);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 36) {
                  s2 = peg$c40;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c41);
                  }
                }
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c34;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c35);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c36;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c37);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 64) {
                  s2 = peg$c38;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c39);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s2 = peg$c40;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c41);
                    }
                  }
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c33);
          }
        }

        return s0;
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c44);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c45(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c46(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c43);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c44);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c48(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c46(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        return s0;
      }

      function peg$parse_13nonMustacheUnit() {
        var s0;
        s0 = peg$parse_13tripleOpen();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_13doubleOpen();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_13hashStacheOpen();

            if (s0 === peg$FAILED) {
              s0 = peg$parse_3anyDedent();

              if (s0 === peg$FAILED) {
                s0 = peg$parse_13TERM();
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_13singleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s0 = peg$c1;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c49);
          }
        }

        return s0;
      }

      function peg$parse_13doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c12) {
          s0 = peg$c12;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c50);
          }
        }

        return s0;
      }

      function peg$parse_13tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c15) {
          s0 = peg$c15;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c51);
          }
        }

        return s0;
      }

      function peg$parse_13hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c24) {
          s0 = peg$c24;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c52);
          }
        }

        return s0;
      }

      function peg$parse_13TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c54;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c44);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c56(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c57;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c58);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c59(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c53);
          }
        }

        return s0;
      }

      function peg$parse_31start() {
        var s0;
        s0 = peg$parse_31normalAttribute();
        return s0;
      }

      function peg$parse_31normalAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c60;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c61);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_31attributeTextNodes();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c62(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31attributeTextNodes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c63;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c64);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_31attributeTextNodesInner();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_31closingDoubleQuote();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c65(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c66;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c67);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_31attributeTextNodesInnerSingle();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_31closingSingleQuote();

              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c65(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_31closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c66;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c67);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c68);
          }
        }

        return s0;
      }

      function peg$parse_31closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 34) {
          s0 = peg$c63;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c64);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c69);
          }
        }

        return s0;
      }

      function peg$parse_31attributeTextNodesInner() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_31preAttrMustacheText();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_31preAttrMustacheText();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_31preAttrMustacheText();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c70(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31attributeTextNodesInnerSingle() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_31preAttrMustacheTextSingle();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_31preAttrMustacheTextSingle();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_31preAttrMustacheTextSingle();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c70(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheText() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_31preAttrMustacheUnit();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_31preAttrMustacheUnit();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheTextSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_31preAttrMustacheUnitSingle();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_31preAttrMustacheUnitSingle();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheUnit() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c63;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c64);
            }
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c44);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c72(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c71);
          }
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheUnitSingle() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c66;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c67);
            }
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c44);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c72(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c71);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/number-attr", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _27start: peg$parse_27start
      },
          peg$startRuleFunction = peg$parse_27start,
          peg$c0 = /^[_a-zA-Z0-9\-]/,
          peg$c1 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c2 = /^[\x80-\xFF]/,
          peg$c3 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c4 = peg$otherExpectation("_26Attribute Key"),
          peg$c5 = ":",
          peg$c6 = peg$literalExpectation(":", false),
          peg$c7 = ".",
          peg$c8 = peg$literalExpectation(".", false),
          peg$c9 = "@",
          peg$c10 = peg$literalExpectation("@", false),
          peg$c11 = "$",
          peg$c12 = peg$literalExpectation("$", false),
          peg$c13 = "=",
          peg$c14 = peg$literalExpectation("=", false),
          peg$c15 = function (key, digits) {
        var value = parseInt(digits.join(""), 10);
        return [key, value];
      },
          peg$c16 = peg$otherExpectation("_27Valid numbers"),
          peg$c17 = /^[0-9]/,
          peg$c18 = peg$classExpectation([["0", "9"]], false, false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_26key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c5;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c7;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s2 = peg$c9;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 36) {
                  s2 = peg$c11;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c12);
                  }
                }
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c5;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c7;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 64) {
                  s2 = peg$c9;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s2 = peg$c11;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c12);
                    }
                  }
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        return s0;
      }

      function peg$parse_27start() {
        var s0;
        s0 = peg$parse_27booleanAttribute();
        return s0;
      }

      function peg$parse_27booleanAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c13;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c14);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_27digits();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c15(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_27digits() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];

        if (peg$c17.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c18);
          }
        }

        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);

            if (peg$c17.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c18);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/spread-attribute", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _33start: peg$parse_33start
      },
          peg$startRuleFunction = peg$parse_33start,
          peg$c0 = "...attributes",
          peg$c1 = peg$literalExpectation("...attributes", false),
          peg$c2 = function (spread) {
        return [spread];
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_33start() {
        var s0;
        s0 = peg$parse_33spreadAttribute();
        return s0;
      }

      function peg$parse_33spreadAttribute() {
        var s0, s1;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 13) === peg$c0) {
          s1 = peg$c0;
          peg$currPos += 13;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c2(s1);
        }

        s0 = s1;
        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/tag-component", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _47start: peg$parse_47start
      },
          peg$startRuleFunction = peg$parse_47start,
          peg$c0 = function (v) {
        var last = v[v.length - 1];
        var idNode; // Support for data keywords that are prefixed with @ in the each
        // block helper such as @index, @key, @first, @last

        if (last.part.charAt(0) === '@') {
          last.part = last.part.slice(1);
          idNode = new AST.IdNode(v);
          var dataNode = new AST.DataNode(idNode);
          return dataNode;
        }

        var match;
        var suffixModifier; // FIXME probably need to handle this better?

        if (match = last.part.match(/!$/)) {
          last.part = 'unbound ' + last.part.slice(0, -1);
        }

        if (match = last.part.match(/[\?\^]$/)) {
          suffixModifier = match[0];
          throw "unhandled path terminated: " + suffixModifier;
        }

        return last.part;
      },
          peg$c1 = function (first, s, p) {
        return {
          part: p,
          separator: s
        };
      },
          peg$c2 = function (first, tail) {
        var ret = [{
          part: first
        }];

        for (var i = 0; i < tail.length; ++i) {
          ret.push(tail[i]);
        }

        return ret;
      },
          peg$c3 = peg$otherExpectation("_17PathIdent"),
          peg$c4 = "..",
          peg$c5 = peg$literalExpectation("..", false),
          peg$c6 = ".",
          peg$c7 = peg$literalExpectation(".", false),
          peg$c8 = /^[a-zA-Z0-9_$\-!?\^@]/,
          peg$c9 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "$", "-", "!", "?", "^", "@"], false, false),
          peg$c10 = "=",
          peg$c11 = peg$literalExpectation("=", false),
          peg$c12 = function (s) {
        return s;
      },
          peg$c13 = "[",
          peg$c14 = peg$literalExpectation("[", false),
          peg$c15 = /^[^\]]/,
          peg$c16 = peg$classExpectation(["]"], true, false),
          peg$c17 = "]",
          peg$c18 = peg$literalExpectation("]", false),
          peg$c19 = function (segmentLiteral) {
        return segmentLiteral;
      },
          peg$c20 = peg$otherExpectation("_17PathSeparator"),
          peg$c21 = /^[\/.]/,
          peg$c22 = peg$classExpectation(["/", "."], false, false),
          peg$c23 = ":",
          peg$c24 = peg$literalExpectation(":", false),
          peg$c25 = " ",
          peg$c26 = peg$literalExpectation(" ", false),
          peg$c27 = function (c) {
        return c;
      },
          peg$c28 = peg$otherExpectation("_19valid tag string"),
          peg$c29 = /^[_a-zA-Z0-9\-]/,
          peg$c30 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c31 = "@",
          peg$c32 = peg$literalExpectation("@", false),
          peg$c33 = function (p) {
        return p;
      },
          peg$c34 = "'",
          peg$c35 = peg$literalExpectation("'", false),
          peg$c36 = "\"",
          peg$c37 = peg$literalExpectation("\"", false),
          peg$c38 = peg$otherExpectation("_20Closing single quote"),
          peg$c39 = peg$otherExpectation("_20Closing double quote"),
          peg$c40 = peg$otherExpectation("_20string action attributes"),
          peg$c41 = /^[^"}]/,
          peg$c42 = peg$classExpectation(["\"", "}"], true, false),
          peg$c43 = /^[^'}]/,
          peg$c44 = peg$classExpectation(["'", "}"], true, false),
          peg$c45 = peg$otherExpectation("_20LineEnd"),
          peg$c46 = "\r",
          peg$c47 = peg$literalExpectation("\r", false),
          peg$c48 = peg$anyExpectation(),
          peg$c49 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c50 = "\n",
          peg$c51 = peg$literalExpectation("\n", false),
          peg$c52 = function (t) {
        return false;
      },
          peg$c53 = peg$otherExpectation("_11mustache expression"),
          peg$c54 = "{",
          peg$c55 = peg$literalExpectation("{", false),
          peg$c56 = /^[^}]/,
          peg$c57 = peg$classExpectation(["}"], true, false),
          peg$c58 = function (text) {
        return text;
      },
          peg$c59 = /^[ \t]/,
          peg$c60 = peg$classExpectation([" ", "\t"], false, false),
          peg$c61 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c62 = function (value) {
        return value;
      },
          peg$c63 = peg$otherExpectation("_21closing mustache"),
          peg$c64 = "}",
          peg$c65 = peg$literalExpectation("}", false),
          peg$c66 = function (event, mustacheNode) {
        var actionBody, parts;

        if (typeof mustacheNode === 'string') {
          actionBody = mustacheNode;
        } else {
          parts = mustacheNode[1].split(' ');

          if (parts.length === 1) {
            actionBody = '"' + parts[0] + '"';
          } else {
            actionBody = mustacheNode[1];
          }
        }

        var actionContent = [actionBody];

        if (actionBody.indexOf('action ') !== 0) {
          actionContent.unshift('action');
        }

        return buildActionEvent(event, actionContent);
      },
          peg$c67 = peg$otherExpectation("_22a valid JS event"),
          peg$c68 = function (event) {
        return isAliasEvent(event);
      },
          peg$c69 = function (event) {
        return event;
      },
          peg$c70 = function (id) {
        return id;
      },
          peg$c71 = function (value) {
        return value;
      },
          peg$c72 = /^[\x80-\xFF]/,
          peg$c73 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c74 = peg$otherExpectation("_24Key"),
          peg$c75 = "true",
          peg$c76 = peg$literalExpectation("true", false),
          peg$c77 = "false",
          peg$c78 = peg$literalExpectation("false", false),
          peg$c79 = function (key, boolValue) {
        if (boolValue === 'true') {
          return [key];
        }
      },
          peg$c80 = peg$otherExpectation("_26Attribute Key"),
          peg$c81 = "$",
          peg$c82 = peg$literalExpectation("$", false),
          peg$c83 = function (key, digits) {
        var value = parseInt(digits.join(""), 10);
        return [key, value];
      },
          peg$c84 = peg$otherExpectation("_27Valid numbers"),
          peg$c85 = /^[0-9]/,
          peg$c86 = peg$classExpectation([["0", "9"]], false, false),
          peg$c87 = function (key, value) {
        value = value.trim(); // Class logic needs to be coalesced, except for conditional statements

        if (key === 'class') {
          if (value.indexOf('if') === 0 || value.indexOf('unless') === 0) {
            return builder.generateClassNameBinding(value);
          } else {
            return splitValueIntoClassBindings(value);
          }
        } else {
          return [builder.generateAssignedMustache(value, key)];
        }
      },
          peg$c88 = /^[\-_\/A-Za-z0-9]/,
          peg$c89 = peg$classExpectation(["-", "_", "/", ["A", "Z"], ["a", "z"], ["0", "9"]], false, false),
          peg$c90 = "::",
          peg$c91 = peg$literalExpectation("::", false),
          peg$c92 = ".[",
          peg$c93 = peg$literalExpectation(".[", false),
          peg$c94 = "!",
          peg$c95 = peg$literalExpectation("!", false),
          peg$c96 = function (key, value) {
        if (key === 'class') {
          return splitValueIntoClassBindings(value);
        } else {
          return [builder.generateAssignedMustache(value, key)];
        }
      },
          peg$c97 = function (value) {
        return value.replace(/ *$/, '');
      },
          peg$c98 = peg$otherExpectation("_30valid attribute value"),
          peg$c99 = peg$otherExpectation("_30closing mustache"),
          peg$c100 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), false);
      },
          peg$c101 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), true);
      },
          peg$c102 = peg$otherExpectation("_12Double Mustache Open"),
          peg$c103 = "{{",
          peg$c104 = peg$literalExpectation("{{", false),
          peg$c105 = peg$otherExpectation("_12Triple Mustache Open"),
          peg$c106 = "{{{",
          peg$c107 = peg$literalExpectation("{{{", false),
          peg$c108 = peg$otherExpectation("_12Double Mustache Close"),
          peg$c109 = "}}",
          peg$c110 = peg$literalExpectation("}}", false),
          peg$c111 = peg$otherExpectation("_12Triple Mustache Close"),
          peg$c112 = "}}}",
          peg$c113 = peg$literalExpectation("}}}", false),
          peg$c114 = peg$otherExpectation("_12String Interpolation Open"),
          peg$c115 = "#{",
          peg$c116 = peg$literalExpectation("#{", false),
          peg$c117 = peg$otherExpectation("_12String Interpolation Close"),
          peg$c118 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c119 = peg$otherExpectation("_3DEDENT"),
          peg$c120 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c121 = function (t) {
        return '';
      },
          peg$c122 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c123 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c124 = peg$otherExpectation("_13Single Mustache Open"),
          peg$c125 = peg$otherExpectation("_13Double Mustache Open"),
          peg$c126 = peg$otherExpectation("_13Triple Mustache Open"),
          peg$c127 = peg$otherExpectation("_13String Interpolation Open"),
          peg$c128 = peg$otherExpectation("_13LineEnd"),
          peg$c129 = function (key, nodes) {
        var strings = [];
        nodes.forEach(function (node) {
          if (typeof node === 'string') {
            strings.push(node);
          } else {
            // FIXME here we transform a mustache attribute
            // This should be handled higher up instead, not here.
            // This happens when the attribute is something like:
            // src="{{unbound post.showLogoUrl}}".
            // key = "src", nodes[0] = "unbound post.showLogoUrl"
            if (node.escaped) {
              strings.push('{{' + node.content + '}}');
            } else {
              strings.push('{{{' + node.content + '}}}');
            }
          }
        });
        var result = [key, strings.join('')];
        return result;
      },
          peg$c130 = function (a) {
        return a;
      },
          peg$c131 = peg$otherExpectation("_31Closing Single Quote"),
          peg$c132 = peg$otherExpectation("_31Closing Double Quote"),
          peg$c133 = function (first, tail) {
        return flattenArray(first, tail);
      },
          peg$c134 = peg$otherExpectation("_31Valid quoted attribute value"),
          peg$c135 = function (key, value) {
        return [key, '{{' + value + '}}'];
      },
          peg$c136 = "...attributes",
          peg$c137 = peg$literalExpectation("...attributes", false),
          peg$c138 = function (spread) {
        return [spread];
      },
          peg$c139 = function (a) {
        if (!a) return [];else if (!a.length) return [a];else return a;
      },
          peg$c140 = function (a) {
        return a;
      },
          peg$c141 = peg$otherExpectation("_35LineEnd"),
          peg$c142 = peg$otherExpectation("_35INDENT"),
          peg$c143 = function (t) {
        return _preprocessor.INDENT_SYMBOL === t;
      },
          peg$c144 = peg$otherExpectation("_36CSS class"),
          peg$c145 = peg$otherExpectation("_37HTML ID"),
          peg$c146 = "#",
          peg$c147 = peg$literalExpectation("#", false),
          peg$c148 = function (c) {
        return c;
      },
          peg$c149 = function (s) {
        return {
          shorthand: s,
          id: true
        };
      },
          peg$c150 = function (s) {
        return {
          shorthand: s
        };
      },
          peg$c151 = function (shorthands) {
        var id,
            classes = [];

        for (var i = 0, len = shorthands.length; i < len; ++i) {
          var shorthand = shorthands[i];

          if (shorthand.id) {
            id = shorthand.shorthand;
          } else {
            classes.push(shorthand.shorthand);
          }
        }

        return [id, classes];
      },
          peg$c152 = function (m) {
        return builder.generateMustache(m, true);
      },
          peg$c153 = "as",
          peg$c154 = peg$literalExpectation("as", false),
          peg$c155 = peg$otherExpectation("_42block param starting pipe"),
          peg$c156 = "|",
          peg$c157 = peg$literalExpectation("|", false),
          peg$c158 = peg$otherExpectation("_43Quoted string"),
          peg$c159 = /^[^'"]/,
          peg$c160 = peg$classExpectation(["'", "\""], true, false),
          peg$c161 = function (v) {
        return v;
      },
          peg$c162 = /^[\/(]/,
          peg$c163 = peg$classExpectation(["/", "("], false, false),
          peg$c164 = peg$otherExpectation("_45block params closing pipe"),
          peg$c165 = function (params) {
        return params;
      },
          peg$c166 = peg$otherExpectation("_46block param"),
          peg$c167 = peg$otherExpectation("_4RequiredWhitespace"),
          peg$c168 = function (h, blockParams, inTagMustaches, fullAttributes) {
        return parseInHtml(h, inTagMustaches, fullAttributes, blockParams);
      },
          peg$c169 = function (h, inTagMustaches, fullAttributes, blockParams) {
        return parseInHtml(h, inTagMustaches, fullAttributes, blockParams);
      },
          peg$c170 = "/",
          peg$c171 = peg$literalExpectation("/", false),
          peg$c172 = function (h, s) {
        return h || s;
      },
          peg$c173 = "%",
          peg$c174 = peg$literalExpectation("%", false),
          peg$c175 = function (s) {
        return s;
      },
          peg$c176 = peg$otherExpectation("_47LineEnd"),
          peg$c177 = peg$otherExpectation("_47INDENT"),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_17pathIdNode() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_17path();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_17path() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_17pathIdent();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_17separator();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_17pathIdent();

            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c1(s1, s4, s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_17separator();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_17pathIdent();

              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c1(s1, s4, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c2(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_17pathIdent() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s0 = peg$c6;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];

            if (peg$c8.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c8.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c9);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s1 = input.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }

            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c10;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c11);
                }
              }

              peg$silentFails--;

              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }

              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c13;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];

                if (peg$c15.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c16);
                  }
                }

                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c15.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c16);
                    }
                  }
                }

                if (s3 !== peg$FAILED) {
                  s2 = input.substring(s2, peg$currPos);
                } else {
                  s2 = s3;
                }

                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c17;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c18);
                    }
                  }

                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c19(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_17separator() {
        var s0, s1;
        peg$silentFails++;

        if (peg$c21.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_18nonSeparatorColon() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 58) {
          s1 = peg$c23;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;

          if (input.charCodeAt(peg$currPos) === 32) {
            s3 = peg$c25;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c26);
            }
          }

          peg$silentFails--;

          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_19tagString() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_19tagChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_19tagChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        return s0;
      }

      function peg$parse_19tagChar() {
        var s0;

        if (peg$c29.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 64) {
              s0 = peg$c31;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_20stringWithQuotes() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_20singleQuoteString();

        if (s1 === peg$FAILED) {
          s1 = peg$parse_20doubleQuoteString();
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_20singleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c34;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashSingleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c34;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c35);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20doubleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c36;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashDoubleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c36;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }

        return s0;
      }

      function peg$parse_20closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }

        return s0;
      }

      function peg$parse_20hashDoubleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c41.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c42);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c41.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c42);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_20hashSingleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c43.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c44);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c43.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c44);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_20TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }

        return s0;
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c54;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c56.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c57);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c56.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c57);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c58(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c53);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c59.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c60);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }

        return s0;
      }

      function peg$parse_21singleMustacheValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c54;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_21mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c62(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_21mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c63);
          }
        }

        return s0;
      }

      function peg$parse_22actionAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_22knownAliasEvent();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_22actionValue();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_22knownAliasEvent() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_19tagString();

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c68(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c69(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c67);
          }
        }

        return s0;
      }

      function peg$parse_22actionValue() {
        var s0, s1;
        s0 = peg$parse_20stringWithQuotes();

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_17pathIdNode();

          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c70(s1);
          }

          s0 = s1;

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_21singleMustacheValue();

            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c71(s1);
            }

            s0 = s1;
          }
        }

        return s0;
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c29.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c72.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c73);
          }
        }

        return s0;
      }

      function peg$parse_24key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c23;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c6;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c23;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c6;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c7);
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c74);
          }
        }

        return s0;
      }

      function peg$parse_25booleanAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_24key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c75) {
              s3 = peg$c75;
              peg$currPos += 4;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }

            if (s3 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c77) {
                s3 = peg$c77;
                peg$currPos += 5;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c78);
                }
              }
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c79(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_26key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c23;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c6;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s2 = peg$c31;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 36) {
                  s2 = peg$c81;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c82);
                  }
                }
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c23;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c6;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c7);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 64) {
                  s2 = peg$c31;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c32);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s2 = peg$c81;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c82);
                    }
                  }
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c80);
          }
        }

        return s0;
      }

      function peg$parse_27booleanAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_27digits();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c83(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_27digits() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];

        if (peg$c85.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c86);
          }
        }

        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);

            if (peg$c85.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c86);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c84);
          }
        }

        return s0;
      }

      function peg$parse_28boundAttributeWithSingleMustache() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_21singleMustacheValue();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c87(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_29newMustacheNameChar() {
        var s0;

        if (peg$c88.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c89);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_29arrayIndex();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s0 = peg$c6;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s0 = peg$c31;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }

              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c90) {
                  s0 = peg$c90;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c91);
                  }
                }

                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s0 = peg$c81;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c82);
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_29arrayIndex() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c92) {
          s1 = peg$c92;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c93);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_29newMustacheNameChar();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_29newMustacheNameChar();
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c17;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c18);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_30boundAttribute() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_30boundAttributeValue();

            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 33) {
                s5 = peg$c94;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c95);
                }
              }

              peg$silentFails--;

              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c96(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_30boundAttributeValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c54;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parse_30boundAttributeValueChar();

            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 32) {
                s5 = peg$c25;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c26);
                }
              }
            }

            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parse_30boundAttributeValueChar();

                if (s5 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 32) {
                    s5 = peg$c25;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c26);
                    }
                  }
                }
              }
            } else {
              s4 = peg$FAILED;
            }

            if (s4 !== peg$FAILED) {
              s3 = input.substring(s3, peg$currPos);
            } else {
              s3 = s4;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_30mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c97(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_30boundAttributeValueChar();

          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parse_30boundAttributeValueChar();
            }
          } else {
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        return s0;
      }

      function peg$parse_30boundAttributeValueChar() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_29newMustacheNameChar();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c98);
          }
        }

        return s0;
      }

      function peg$parse_30mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c99);
          }
        }

        return s0;
      }

      function peg$parse_12rawMustache() {
        var s0;
        s0 = peg$parse_12rawMustacheUnescaped();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustacheEscaped();
        }

        return s0;
      }

      function peg$parse_12rawMustacheUnescaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12tripleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12tripleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c100(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_12rawMustacheEscaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12doubleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12doubleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c101(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_12hashStacheOpen();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_1start();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_11nonMustache();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_1start();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_12hashStacheClose();

                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c101(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_12doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c103) {
          s0 = peg$c103;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c104);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c102);
          }
        }

        return s0;
      }

      function peg$parse_12tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c106) {
          s0 = peg$c106;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c107);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c105);
          }
        }

        return s0;
      }

      function peg$parse_12doubleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c109) {
          s0 = peg$c109;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c110);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c108);
          }
        }

        return s0;
      }

      function peg$parse_12tripleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c112) {
          s0 = peg$c112;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c113);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c111);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c115) {
          s0 = peg$c115;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c116);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c114);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c117);
          }
        }

        return s0;
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c118);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c120(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c119);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c123(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c122);
          }
        }

        return s0;
      }

      function peg$parse_13nonMustacheUnit() {
        var s0;
        s0 = peg$parse_13tripleOpen();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_13doubleOpen();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_13hashStacheOpen();

            if (s0 === peg$FAILED) {
              s0 = peg$parse_3anyDedent();

              if (s0 === peg$FAILED) {
                s0 = peg$parse_13TERM();
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_13singleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s0 = peg$c54;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c124);
          }
        }

        return s0;
      }

      function peg$parse_13doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c103) {
          s0 = peg$c103;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c104);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c125);
          }
        }

        return s0;
      }

      function peg$parse_13tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c106) {
          s0 = peg$c106;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c107);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c126);
          }
        }

        return s0;
      }

      function peg$parse_13hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c115) {
          s0 = peg$c115;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c116);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c127);
          }
        }

        return s0;
      }

      function peg$parse_13TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c128);
          }
        }

        return s0;
      }

      function peg$parse_31normalAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_31attributeTextNodes();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c129(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31attributeTextNodes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c36;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_31attributeTextNodesInner();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_31closingDoubleQuote();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c130(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c34;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_31attributeTextNodesInnerSingle();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_31closingSingleQuote();

              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c130(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_31closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c131);
          }
        }

        return s0;
      }

      function peg$parse_31closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 34) {
          s0 = peg$c36;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c132);
          }
        }

        return s0;
      }

      function peg$parse_31attributeTextNodesInner() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_31preAttrMustacheText();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_31preAttrMustacheText();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_31preAttrMustacheText();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c133(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31attributeTextNodesInnerSingle() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_31preAttrMustacheTextSingle();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_31preAttrMustacheTextSingle();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_31preAttrMustacheTextSingle();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c133(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheText() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_31preAttrMustacheUnit();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_31preAttrMustacheUnit();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheTextSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_31preAttrMustacheUnitSingle();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_31preAttrMustacheUnitSingle();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheUnit() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c36;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c37);
            }
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c134);
          }
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheUnitSingle() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c34;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c134);
          }
        }

        return s0;
      }

      function peg$parse_32simpleMustacheAttr() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_17pathIdNode();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c135(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_33spreadAttribute() {
        var s0, s1;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 13) === peg$c136) {
          s1 = peg$c136;
          peg$currPos += 13;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c137);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c138(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_34attribute() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_22actionAttribute();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_25booleanAttribute();

            if (s2 === peg$FAILED) {
              s2 = peg$parse_27booleanAttribute();

              if (s2 === peg$FAILED) {
                s2 = peg$parse_28boundAttributeWithSingleMustache();

                if (s2 === peg$FAILED) {
                  s2 = peg$parse_30boundAttribute();

                  if (s2 === peg$FAILED) {
                    s2 = peg$parse_31normalAttribute();

                    if (s2 === peg$FAILED) {
                      s2 = peg$parse_32simpleMustacheAttr();

                      if (s2 === peg$FAILED) {
                        s2 = peg$parse_33spreadAttribute();
                      }
                    }
                  }
                }
              }
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c139(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_35bracketedAttribute() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_35INDENT();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_35INDENT();
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_34attribute();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_35TERM();

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_35TERM();
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c140(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_35TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c141);
          }
        }

        return s0;
      }

      function peg$parse_35INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c143(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c142);
          }
        }

        return s0;
      }

      function peg$parse_36cssIdentifier() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_36ident();
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c144);
          }
        }

        return s0;
      }

      function peg$parse_36ident() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_23nmchar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_37idShorthand() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c146;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c147);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_36cssIdentifier();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c148(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c145);
          }
        }

        return s0;
      }

      function peg$parse_38classShorthand() {
        var s0, s1, s2;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c6;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_36cssIdentifier();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_39shorthandAttributes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parse_37idShorthand();

        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c149(s3);
        }

        s2 = s3;

        if (s2 === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parse_38classShorthand();

          if (s3 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c150(s3);
          }

          s2 = s3;
        }

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parse_37idShorthand();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c149(s3);
            }

            s2 = s3;

            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parse_38classShorthand();

              if (s3 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c150(s3);
              }

              s2 = s3;
            }
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c151(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_40inTagMustache() {
        var s0;
        s0 = peg$parse_40builtSingle();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustache();
        }

        return s0;
      }

      function peg$parse_40builtSingle() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_21singleMustacheValue();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c152(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_42blockStart() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c153) {
          s1 = peg$c153;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c154);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_42blockStartPipe();

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_42blockStartPipe() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c156;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c157);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c155);
          }
        }

        return s0;
      }

      function peg$parse_43quotedString() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s2 = peg$c36;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_43stringWithoutDouble();

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s4 = peg$c36;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }

            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c34;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_43stringWithoutSingle();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s4 = peg$c34;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c35);
                }
              }

              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c158);
          }
        }

        return s0;
      }

      function peg$parse_43stringWithoutDouble() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c34;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c34;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c35);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43stringWithoutSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c36;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c37);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s2 = peg$c36;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43inStringChar() {
        var s0;

        if (peg$c159.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c160);
          }
        }

        return s0;
      }

      function peg$parse_44newMustacheAttrValue() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_44invalidValueStartChar();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_42blockStart();
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_43quotedString();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_44valuePath();
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_1start();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c161(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_44valuePath() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_29newMustacheNameChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_29newMustacheNameChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_44invalidValueStartChar() {
        var s0;

        if (peg$c162.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c163);
          }
        }

        return s0;
      }

      function peg$parse_45blockEnd() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c156;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c157);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c164);
          }
        }

        return s0;
      }

      function peg$parse_46blockParams() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_42blockStart();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_46blockParamName();

            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_46blockParamName();
              }
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_45blockEnd();

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c165(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_46blockParamName() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_44newMustacheAttrValue();
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c166);
          }
        }

        return s0;
      }

      function peg$parse_4start() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_0start();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_0start();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c167);
          }
        }

        return s0;
      }

      function peg$parse_47start() {
        var s0;
        s0 = peg$parse_47inHtmlTag();
        return s0;
      }

      function peg$parse_47inHtmlTag() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parse_47htmlStart();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_47blockParams();

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_4start();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 91) {
                s4 = peg$c13;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parse_47TERM();

                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parse_47TERM();
                }

                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parse_40inTagMustache();

                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parse_40inTagMustache();
                  }

                  if (s6 !== peg$FAILED) {
                    s7 = [];
                    s8 = peg$parse_35bracketedAttribute();

                    while (s8 !== peg$FAILED) {
                      s7.push(s8);
                      s8 = peg$parse_35bracketedAttribute();
                    }

                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c168(s1, s2, s6, s7);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_47htmlStart();

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parse_40inTagMustache();

            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parse_40inTagMustache();
            }

            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parse_34attribute();

              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_34attribute();
              }

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_47blockParams();

                if (s4 === peg$FAILED) {
                  s4 = null;
                }

                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c169(s1, s2, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_47htmlStart() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_47componentTag();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_39shorthandAttributes();

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s3 = peg$c170;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c171);
              }
            }

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = peg$currPos;
              s4 = peg$c172(s1, s2);

              if (s4) {
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                s1 = [s1, s2, s3, s4];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_47componentTag() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 37) {
          s1 = peg$c173;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c174);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_19tagString();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c175(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_47blockParams() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_46blockParams();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c165(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_47TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c176);
          }
        }

        return s0;
      }

      function peg$parse_47INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c143(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c177);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/tag-html", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _41start: peg$parse_41start
      },
          peg$startRuleFunction = peg$parse_41start,
          peg$c0 = function (v) {
        var last = v[v.length - 1];
        var idNode; // Support for data keywords that are prefixed with @ in the each
        // block helper such as @index, @key, @first, @last

        if (last.part.charAt(0) === '@') {
          last.part = last.part.slice(1);
          idNode = new AST.IdNode(v);
          var dataNode = new AST.DataNode(idNode);
          return dataNode;
        }

        var match;
        var suffixModifier; // FIXME probably need to handle this better?

        if (match = last.part.match(/!$/)) {
          last.part = 'unbound ' + last.part.slice(0, -1);
        }

        if (match = last.part.match(/[\?\^]$/)) {
          suffixModifier = match[0];
          throw "unhandled path terminated: " + suffixModifier;
        }

        return last.part;
      },
          peg$c1 = function (first, s, p) {
        return {
          part: p,
          separator: s
        };
      },
          peg$c2 = function (first, tail) {
        var ret = [{
          part: first
        }];

        for (var i = 0; i < tail.length; ++i) {
          ret.push(tail[i]);
        }

        return ret;
      },
          peg$c3 = peg$otherExpectation("_17PathIdent"),
          peg$c4 = "..",
          peg$c5 = peg$literalExpectation("..", false),
          peg$c6 = ".",
          peg$c7 = peg$literalExpectation(".", false),
          peg$c8 = /^[a-zA-Z0-9_$\-!?\^@]/,
          peg$c9 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "$", "-", "!", "?", "^", "@"], false, false),
          peg$c10 = "=",
          peg$c11 = peg$literalExpectation("=", false),
          peg$c12 = function (s) {
        return s;
      },
          peg$c13 = "[",
          peg$c14 = peg$literalExpectation("[", false),
          peg$c15 = /^[^\]]/,
          peg$c16 = peg$classExpectation(["]"], true, false),
          peg$c17 = "]",
          peg$c18 = peg$literalExpectation("]", false),
          peg$c19 = function (segmentLiteral) {
        return segmentLiteral;
      },
          peg$c20 = peg$otherExpectation("_17PathSeparator"),
          peg$c21 = /^[\/.]/,
          peg$c22 = peg$classExpectation(["/", "."], false, false),
          peg$c23 = ":",
          peg$c24 = peg$literalExpectation(":", false),
          peg$c25 = " ",
          peg$c26 = peg$literalExpectation(" ", false),
          peg$c27 = function (c) {
        return c;
      },
          peg$c28 = peg$otherExpectation("_19valid tag string"),
          peg$c29 = /^[_a-zA-Z0-9\-]/,
          peg$c30 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c31 = "@",
          peg$c32 = peg$literalExpectation("@", false),
          peg$c33 = function (p) {
        return p;
      },
          peg$c34 = "'",
          peg$c35 = peg$literalExpectation("'", false),
          peg$c36 = "\"",
          peg$c37 = peg$literalExpectation("\"", false),
          peg$c38 = peg$otherExpectation("_20Closing single quote"),
          peg$c39 = peg$otherExpectation("_20Closing double quote"),
          peg$c40 = peg$otherExpectation("_20string action attributes"),
          peg$c41 = /^[^"}]/,
          peg$c42 = peg$classExpectation(["\"", "}"], true, false),
          peg$c43 = /^[^'}]/,
          peg$c44 = peg$classExpectation(["'", "}"], true, false),
          peg$c45 = peg$otherExpectation("_20LineEnd"),
          peg$c46 = "\r",
          peg$c47 = peg$literalExpectation("\r", false),
          peg$c48 = peg$anyExpectation(),
          peg$c49 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c50 = "\n",
          peg$c51 = peg$literalExpectation("\n", false),
          peg$c52 = function (t) {
        return false;
      },
          peg$c53 = peg$otherExpectation("_11mustache expression"),
          peg$c54 = "{",
          peg$c55 = peg$literalExpectation("{", false),
          peg$c56 = /^[^}]/,
          peg$c57 = peg$classExpectation(["}"], true, false),
          peg$c58 = function (text) {
        return text;
      },
          peg$c59 = /^[ \t]/,
          peg$c60 = peg$classExpectation([" ", "\t"], false, false),
          peg$c61 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c62 = function (value) {
        return value;
      },
          peg$c63 = peg$otherExpectation("_21closing mustache"),
          peg$c64 = "}",
          peg$c65 = peg$literalExpectation("}", false),
          peg$c66 = function (event, mustacheNode) {
        var actionBody, parts;

        if (typeof mustacheNode === 'string') {
          actionBody = mustacheNode;
        } else {
          parts = mustacheNode[1].split(' ');

          if (parts.length === 1) {
            actionBody = '"' + parts[0] + '"';
          } else {
            actionBody = mustacheNode[1];
          }
        }

        var actionContent = [actionBody];

        if (actionBody.indexOf('action ') !== 0) {
          actionContent.unshift('action');
        }

        return buildActionEvent(event, actionContent);
      },
          peg$c67 = peg$otherExpectation("_22a valid JS event"),
          peg$c68 = function (event) {
        return isAliasEvent(event);
      },
          peg$c69 = function (event) {
        return event;
      },
          peg$c70 = function (id) {
        return id;
      },
          peg$c71 = function (value) {
        return value;
      },
          peg$c72 = /^[\x80-\xFF]/,
          peg$c73 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c74 = peg$otherExpectation("_24Key"),
          peg$c75 = "true",
          peg$c76 = peg$literalExpectation("true", false),
          peg$c77 = "false",
          peg$c78 = peg$literalExpectation("false", false),
          peg$c79 = function (key, boolValue) {
        if (boolValue === 'true') {
          return [key];
        }
      },
          peg$c80 = peg$otherExpectation("_26Attribute Key"),
          peg$c81 = "$",
          peg$c82 = peg$literalExpectation("$", false),
          peg$c83 = function (key, digits) {
        var value = parseInt(digits.join(""), 10);
        return [key, value];
      },
          peg$c84 = peg$otherExpectation("_27Valid numbers"),
          peg$c85 = /^[0-9]/,
          peg$c86 = peg$classExpectation([["0", "9"]], false, false),
          peg$c87 = function (key, value) {
        value = value.trim(); // Class logic needs to be coalesced, except for conditional statements

        if (key === 'class') {
          if (value.indexOf('if') === 0 || value.indexOf('unless') === 0) {
            return builder.generateClassNameBinding(value);
          } else {
            return splitValueIntoClassBindings(value);
          }
        } else {
          return [builder.generateAssignedMustache(value, key)];
        }
      },
          peg$c88 = /^[\-_\/A-Za-z0-9]/,
          peg$c89 = peg$classExpectation(["-", "_", "/", ["A", "Z"], ["a", "z"], ["0", "9"]], false, false),
          peg$c90 = "::",
          peg$c91 = peg$literalExpectation("::", false),
          peg$c92 = ".[",
          peg$c93 = peg$literalExpectation(".[", false),
          peg$c94 = "!",
          peg$c95 = peg$literalExpectation("!", false),
          peg$c96 = function (key, value) {
        if (key === 'class') {
          return splitValueIntoClassBindings(value);
        } else {
          return [builder.generateAssignedMustache(value, key)];
        }
      },
          peg$c97 = function (value) {
        return value.replace(/ *$/, '');
      },
          peg$c98 = peg$otherExpectation("_30valid attribute value"),
          peg$c99 = peg$otherExpectation("_30closing mustache"),
          peg$c100 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), false);
      },
          peg$c101 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), true);
      },
          peg$c102 = peg$otherExpectation("_12Double Mustache Open"),
          peg$c103 = "{{",
          peg$c104 = peg$literalExpectation("{{", false),
          peg$c105 = peg$otherExpectation("_12Triple Mustache Open"),
          peg$c106 = "{{{",
          peg$c107 = peg$literalExpectation("{{{", false),
          peg$c108 = peg$otherExpectation("_12Double Mustache Close"),
          peg$c109 = "}}",
          peg$c110 = peg$literalExpectation("}}", false),
          peg$c111 = peg$otherExpectation("_12Triple Mustache Close"),
          peg$c112 = "}}}",
          peg$c113 = peg$literalExpectation("}}}", false),
          peg$c114 = peg$otherExpectation("_12String Interpolation Open"),
          peg$c115 = "#{",
          peg$c116 = peg$literalExpectation("#{", false),
          peg$c117 = peg$otherExpectation("_12String Interpolation Close"),
          peg$c118 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c119 = peg$otherExpectation("_3DEDENT"),
          peg$c120 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c121 = function (t) {
        return '';
      },
          peg$c122 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c123 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c124 = peg$otherExpectation("_13Single Mustache Open"),
          peg$c125 = peg$otherExpectation("_13Double Mustache Open"),
          peg$c126 = peg$otherExpectation("_13Triple Mustache Open"),
          peg$c127 = peg$otherExpectation("_13String Interpolation Open"),
          peg$c128 = peg$otherExpectation("_13LineEnd"),
          peg$c129 = function (key, nodes) {
        var strings = [];
        nodes.forEach(function (node) {
          if (typeof node === 'string') {
            strings.push(node);
          } else {
            // FIXME here we transform a mustache attribute
            // This should be handled higher up instead, not here.
            // This happens when the attribute is something like:
            // src="{{unbound post.showLogoUrl}}".
            // key = "src", nodes[0] = "unbound post.showLogoUrl"
            if (node.escaped) {
              strings.push('{{' + node.content + '}}');
            } else {
              strings.push('{{{' + node.content + '}}}');
            }
          }
        });
        var result = [key, strings.join('')];
        return result;
      },
          peg$c130 = function (a) {
        return a;
      },
          peg$c131 = peg$otherExpectation("_31Closing Single Quote"),
          peg$c132 = peg$otherExpectation("_31Closing Double Quote"),
          peg$c133 = function (first, tail) {
        return flattenArray(first, tail);
      },
          peg$c134 = peg$otherExpectation("_31Valid quoted attribute value"),
          peg$c135 = function (key, value) {
        return [key, '{{' + value + '}}'];
      },
          peg$c136 = "...attributes",
          peg$c137 = peg$literalExpectation("...attributes", false),
          peg$c138 = function (spread) {
        return [spread];
      },
          peg$c139 = function (a) {
        if (!a) return [];else if (!a.length) return [a];else return a;
      },
          peg$c140 = function (a) {
        return a;
      },
          peg$c141 = peg$otherExpectation("_35LineEnd"),
          peg$c142 = peg$otherExpectation("_35INDENT"),
          peg$c143 = function (t) {
        return _preprocessor.INDENT_SYMBOL === t;
      },
          peg$c144 = peg$otherExpectation("_36CSS class"),
          peg$c145 = peg$otherExpectation("_37HTML ID"),
          peg$c146 = "#",
          peg$c147 = peg$literalExpectation("#", false),
          peg$c148 = function (c) {
        return c;
      },
          peg$c149 = function (s) {
        return {
          shorthand: s,
          id: true
        };
      },
          peg$c150 = function (s) {
        return {
          shorthand: s
        };
      },
          peg$c151 = function (shorthands) {
        var id,
            classes = [];

        for (var i = 0, len = shorthands.length; i < len; ++i) {
          var shorthand = shorthands[i];

          if (shorthand.id) {
            id = shorthand.shorthand;
          } else {
            classes.push(shorthand.shorthand);
          }
        }

        return [id, classes];
      },
          peg$c152 = function (m) {
        return builder.generateMustache(m, true);
      },
          peg$c153 = peg$otherExpectation("_4RequiredWhitespace"),
          peg$c154 = peg$otherExpectation("_6INDENT"),
          peg$c155 = peg$otherExpectation("_6DEDENT"),
          peg$c156 = peg$otherExpectation("_6LineEnd"),
          peg$c157 = "/",
          peg$c158 = peg$literalExpectation("/", false),
          peg$c159 = function (h, startingInTagMustaches, inTagMustaches, fullAttributes) {
        return parseInHtml(h, startingInTagMustaches.concat(inTagMustaches), fullAttributes);
      },
          peg$c160 = function (h, inTagMustaches, fullAttributes) {
        return parseInHtml(h, inTagMustaches, fullAttributes);
      },
          peg$c161 = function (h, s) {
        return h || s;
      },
          peg$c162 = function (tag) {
        return isKnownTag(tag);
      },
          peg$c163 = function (tag) {
        return tag;
      },
          peg$c164 = peg$otherExpectation("_41LineEnd"),
          peg$c165 = peg$otherExpectation("_41INDENT"),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_17pathIdNode() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_17path();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_17path() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_17pathIdent();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_17separator();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_17pathIdent();

            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c1(s1, s4, s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_17separator();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_17pathIdent();

              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c1(s1, s4, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c2(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_17pathIdent() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s0 = peg$c6;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];

            if (peg$c8.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c8.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c9);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s1 = input.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }

            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c10;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c11);
                }
              }

              peg$silentFails--;

              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }

              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c13;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];

                if (peg$c15.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c16);
                  }
                }

                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c15.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c16);
                    }
                  }
                }

                if (s3 !== peg$FAILED) {
                  s2 = input.substring(s2, peg$currPos);
                } else {
                  s2 = s3;
                }

                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c17;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c18);
                    }
                  }

                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c19(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_17separator() {
        var s0, s1;
        peg$silentFails++;

        if (peg$c21.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_18nonSeparatorColon() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 58) {
          s1 = peg$c23;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;

          if (input.charCodeAt(peg$currPos) === 32) {
            s3 = peg$c25;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c26);
            }
          }

          peg$silentFails--;

          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_19tagString() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_19tagChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_19tagChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        return s0;
      }

      function peg$parse_19tagChar() {
        var s0;

        if (peg$c29.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 64) {
              s0 = peg$c31;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_20stringWithQuotes() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_20singleQuoteString();

        if (s1 === peg$FAILED) {
          s1 = peg$parse_20doubleQuoteString();
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_20singleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c34;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashSingleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c34;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c35);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20doubleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c36;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashDoubleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c36;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }

        return s0;
      }

      function peg$parse_20closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }

        return s0;
      }

      function peg$parse_20hashDoubleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c41.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c42);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c41.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c42);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_20hashSingleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c43.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c44);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c43.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c44);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_20TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }

        return s0;
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c54;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c56.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c57);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c56.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c57);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c58(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c53);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c59.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c60);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }

        return s0;
      }

      function peg$parse_21singleMustacheValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c54;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_21mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c62(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_21mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c63);
          }
        }

        return s0;
      }

      function peg$parse_22actionAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_22knownAliasEvent();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_22actionValue();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_22knownAliasEvent() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_19tagString();

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c68(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c69(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c67);
          }
        }

        return s0;
      }

      function peg$parse_22actionValue() {
        var s0, s1;
        s0 = peg$parse_20stringWithQuotes();

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_17pathIdNode();

          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c70(s1);
          }

          s0 = s1;

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_21singleMustacheValue();

            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c71(s1);
            }

            s0 = s1;
          }
        }

        return s0;
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c29.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c72.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c73);
          }
        }

        return s0;
      }

      function peg$parse_24key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c23;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c6;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c23;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c6;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c7);
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c74);
          }
        }

        return s0;
      }

      function peg$parse_25booleanAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_24key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c75) {
              s3 = peg$c75;
              peg$currPos += 4;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }

            if (s3 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c77) {
                s3 = peg$c77;
                peg$currPos += 5;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c78);
                }
              }
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c79(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_26key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c23;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c6;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s2 = peg$c31;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 36) {
                  s2 = peg$c81;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c82);
                  }
                }
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c23;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c6;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c7);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 64) {
                  s2 = peg$c31;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c32);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s2 = peg$c81;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c82);
                    }
                  }
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c80);
          }
        }

        return s0;
      }

      function peg$parse_27booleanAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_27digits();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c83(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_27digits() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];

        if (peg$c85.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c86);
          }
        }

        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);

            if (peg$c85.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c86);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c84);
          }
        }

        return s0;
      }

      function peg$parse_28boundAttributeWithSingleMustache() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_21singleMustacheValue();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c87(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_29newMustacheNameChar() {
        var s0;

        if (peg$c88.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c89);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_29arrayIndex();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s0 = peg$c6;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s0 = peg$c31;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }

              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c90) {
                  s0 = peg$c90;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c91);
                  }
                }

                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s0 = peg$c81;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c82);
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_29arrayIndex() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c92) {
          s1 = peg$c92;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c93);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_29newMustacheNameChar();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_29newMustacheNameChar();
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c17;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c18);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_30boundAttribute() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_30boundAttributeValue();

            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 33) {
                s5 = peg$c94;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c95);
                }
              }

              peg$silentFails--;

              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c96(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_30boundAttributeValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c54;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parse_30boundAttributeValueChar();

            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 32) {
                s5 = peg$c25;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c26);
                }
              }
            }

            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parse_30boundAttributeValueChar();

                if (s5 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 32) {
                    s5 = peg$c25;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c26);
                    }
                  }
                }
              }
            } else {
              s4 = peg$FAILED;
            }

            if (s4 !== peg$FAILED) {
              s3 = input.substring(s3, peg$currPos);
            } else {
              s3 = s4;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_30mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c97(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_30boundAttributeValueChar();

          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parse_30boundAttributeValueChar();
            }
          } else {
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        return s0;
      }

      function peg$parse_30boundAttributeValueChar() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_29newMustacheNameChar();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c98);
          }
        }

        return s0;
      }

      function peg$parse_30mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c99);
          }
        }

        return s0;
      }

      function peg$parse_12rawMustache() {
        var s0;
        s0 = peg$parse_12rawMustacheUnescaped();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustacheEscaped();
        }

        return s0;
      }

      function peg$parse_12rawMustacheUnescaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12tripleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12tripleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c100(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_12rawMustacheEscaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12doubleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12doubleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c101(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_12hashStacheOpen();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_1start();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_11nonMustache();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_1start();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_12hashStacheClose();

                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c101(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_12doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c103) {
          s0 = peg$c103;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c104);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c102);
          }
        }

        return s0;
      }

      function peg$parse_12tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c106) {
          s0 = peg$c106;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c107);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c105);
          }
        }

        return s0;
      }

      function peg$parse_12doubleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c109) {
          s0 = peg$c109;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c110);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c108);
          }
        }

        return s0;
      }

      function peg$parse_12tripleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c112) {
          s0 = peg$c112;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c113);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c111);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c115) {
          s0 = peg$c115;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c116);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c114);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c64;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c117);
          }
        }

        return s0;
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c118);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c120(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c119);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c123(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c122);
          }
        }

        return s0;
      }

      function peg$parse_13nonMustacheUnit() {
        var s0;
        s0 = peg$parse_13tripleOpen();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_13doubleOpen();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_13hashStacheOpen();

            if (s0 === peg$FAILED) {
              s0 = peg$parse_3anyDedent();

              if (s0 === peg$FAILED) {
                s0 = peg$parse_13TERM();
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_13singleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s0 = peg$c54;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c124);
          }
        }

        return s0;
      }

      function peg$parse_13doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c103) {
          s0 = peg$c103;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c104);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c125);
          }
        }

        return s0;
      }

      function peg$parse_13tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c106) {
          s0 = peg$c106;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c107);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c126);
          }
        }

        return s0;
      }

      function peg$parse_13hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c115) {
          s0 = peg$c115;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c116);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c127);
          }
        }

        return s0;
      }

      function peg$parse_13TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c128);
          }
        }

        return s0;
      }

      function peg$parse_31normalAttribute() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_31attributeTextNodes();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c129(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31attributeTextNodes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c36;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_31attributeTextNodesInner();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_31closingDoubleQuote();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c130(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c34;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_31attributeTextNodesInnerSingle();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_31closingSingleQuote();

              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c130(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_31closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c34;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c131);
          }
        }

        return s0;
      }

      function peg$parse_31closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 34) {
          s0 = peg$c36;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c132);
          }
        }

        return s0;
      }

      function peg$parse_31attributeTextNodesInner() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_31preAttrMustacheText();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_31preAttrMustacheText();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_31preAttrMustacheText();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c133(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31attributeTextNodesInnerSingle() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_31preAttrMustacheTextSingle();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_31preAttrMustacheTextSingle();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_31preAttrMustacheTextSingle();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c133(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheText() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_31preAttrMustacheUnit();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_31preAttrMustacheUnit();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheTextSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_31preAttrMustacheUnitSingle();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_31preAttrMustacheUnitSingle();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheUnit() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c36;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c37);
            }
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c134);
          }
        }

        return s0;
      }

      function peg$parse_31preAttrMustacheUnitSingle() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c34;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c134);
          }
        }

        return s0;
      }

      function peg$parse_32simpleMustacheAttr() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_17pathIdNode();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c135(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_33spreadAttribute() {
        var s0, s1;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 13) === peg$c136) {
          s1 = peg$c136;
          peg$currPos += 13;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c137);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c138(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_34attribute() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_22actionAttribute();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_25booleanAttribute();

            if (s2 === peg$FAILED) {
              s2 = peg$parse_27booleanAttribute();

              if (s2 === peg$FAILED) {
                s2 = peg$parse_28boundAttributeWithSingleMustache();

                if (s2 === peg$FAILED) {
                  s2 = peg$parse_30boundAttribute();

                  if (s2 === peg$FAILED) {
                    s2 = peg$parse_31normalAttribute();

                    if (s2 === peg$FAILED) {
                      s2 = peg$parse_32simpleMustacheAttr();

                      if (s2 === peg$FAILED) {
                        s2 = peg$parse_33spreadAttribute();
                      }
                    }
                  }
                }
              }
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c139(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_35bracketedAttribute() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_35INDENT();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_35INDENT();
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_34attribute();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_35TERM();

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_35TERM();
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c140(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_35TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c141);
          }
        }

        return s0;
      }

      function peg$parse_35INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c143(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c142);
          }
        }

        return s0;
      }

      function peg$parse_36cssIdentifier() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_36ident();
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c144);
          }
        }

        return s0;
      }

      function peg$parse_36ident() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_23nmchar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_37idShorthand() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c146;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c147);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_36cssIdentifier();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c148(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c145);
          }
        }

        return s0;
      }

      function peg$parse_38classShorthand() {
        var s0, s1, s2;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c6;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_36cssIdentifier();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_39shorthandAttributes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parse_37idShorthand();

        if (s3 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c149(s3);
        }

        s2 = s3;

        if (s2 === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parse_38classShorthand();

          if (s3 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c150(s3);
          }

          s2 = s3;
        }

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parse_37idShorthand();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c149(s3);
            }

            s2 = s3;

            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parse_38classShorthand();

              if (s3 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c150(s3);
              }

              s2 = s3;
            }
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c151(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_40inTagMustache() {
        var s0;
        s0 = peg$parse_40builtSingle();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustache();
        }

        return s0;
      }

      function peg$parse_40builtSingle() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_21singleMustacheValue();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c152(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_4start() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_0start();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_0start();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c153);
          }
        }

        return s0;
      }

      function peg$parse_6lineContent() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_6lineChar();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_6lineChar();
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_6lineChar() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_6INDENT();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_6DEDENT();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_6TERM();
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_6INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c143(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c154);
          }
        }

        return s0;
      }

      function peg$parse_6DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c120(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c155);
          }
        }

        return s0;
      }

      function peg$parse_6TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c156);
          }
        }

        return s0;
      }

      function peg$parse_10inlineComment() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 47) {
            s2 = peg$c157;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c158);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_6lineContent();

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_41start() {
        var s0;
        s0 = peg$parse_41tagHtml();
        return s0;
      }

      function peg$parse_41tagHtml() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
        s0 = peg$currPos;
        s1 = peg$parse_41htmlStart();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_40inTagMustache();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_40inTagMustache();
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_4start();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 91) {
                s4 = peg$c13;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parse_41TERM();

                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parse_41TERM();
                }

                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parse_40inTagMustache();

                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parse_40inTagMustache();
                  }

                  if (s6 !== peg$FAILED) {
                    s7 = [];
                    s8 = peg$parse_35bracketedAttribute();

                    if (s8 !== peg$FAILED) {
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        s8 = peg$parse_35bracketedAttribute();
                      }
                    } else {
                      s7 = peg$FAILED;
                    }

                    if (s7 !== peg$FAILED) {
                      s8 = [];
                      s9 = peg$currPos;
                      s10 = peg$parse_1start();

                      if (s10 !== peg$FAILED) {
                        s11 = peg$parse_10inlineComment();

                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_1start();

                          if (s12 !== peg$FAILED) {
                            s13 = peg$parse_41TERM();

                            if (s13 !== peg$FAILED) {
                              s10 = [s10, s11, s12, s13];
                              s9 = s10;
                            } else {
                              peg$currPos = s9;
                              s9 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }

                      while (s9 !== peg$FAILED) {
                        s8.push(s9);
                        s9 = peg$currPos;
                        s10 = peg$parse_1start();

                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_10inlineComment();

                          if (s11 !== peg$FAILED) {
                            s12 = peg$parse_1start();

                            if (s12 !== peg$FAILED) {
                              s13 = peg$parse_41TERM();

                              if (s13 !== peg$FAILED) {
                                s10 = [s10, s11, s12, s13];
                                s9 = s10;
                              } else {
                                peg$currPos = s9;
                                s9 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s9;
                              s9 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      }

                      if (s8 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c159(s1, s2, s6, s7);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_41htmlStart();

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parse_40inTagMustache();

            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parse_40inTagMustache();
            }

            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parse_34attribute();

              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_34attribute();
              }

              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c160(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_41htmlStart() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_41knownTagName();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_39shorthandAttributes();

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s3 = peg$c157;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c158);
              }
            }

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = peg$currPos;
              s4 = peg$c161(s1, s2);

              if (s4) {
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                s1 = [s1, s2, s3, s4];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_41knownTagName() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_19tagString();

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c162(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c163(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_41TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c49(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c50;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c164);
          }
        }

        return s0;
      }

      function peg$parse_41INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c143(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c165);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/tag-string", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _19start: peg$parse_19start
      },
          peg$startRuleFunction = peg$parse_19start,
          peg$c0 = ":",
          peg$c1 = peg$literalExpectation(":", false),
          peg$c2 = " ",
          peg$c3 = peg$literalExpectation(" ", false),
          peg$c4 = function (c) {
        return c;
      },
          peg$c5 = peg$otherExpectation("_19valid tag string"),
          peg$c6 = /^[_a-zA-Z0-9\-]/,
          peg$c7 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c8 = "@",
          peg$c9 = peg$literalExpectation("@", false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_18nonSeparatorColon() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 58) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;

          if (input.charCodeAt(peg$currPos) === 32) {
            s3 = peg$c2;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c3);
            }
          }

          peg$silentFails--;

          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_19start() {
        var s0;
        s0 = peg$parse_19tagString();
        return s0;
      }

      function peg$parse_19tagString() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_19tagChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_19tagChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        return s0;
      }

      function peg$parse_19tagChar() {
        var s0;

        if (peg$c6.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_18nonSeparatorColon();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 64) {
              s0 = peg$c8;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/html/unbound-attribute", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _32start: peg$parse_32start
      },
          peg$startRuleFunction = peg$parse_32start,
          peg$c0 = function (v) {
        var last = v[v.length - 1];
        var idNode; // Support for data keywords that are prefixed with @ in the each
        // block helper such as @index, @key, @first, @last

        if (last.part.charAt(0) === '@') {
          last.part = last.part.slice(1);
          idNode = new AST.IdNode(v);
          var dataNode = new AST.DataNode(idNode);
          return dataNode;
        }

        var match;
        var suffixModifier; // FIXME probably need to handle this better?

        if (match = last.part.match(/!$/)) {
          last.part = 'unbound ' + last.part.slice(0, -1);
        }

        if (match = last.part.match(/[\?\^]$/)) {
          suffixModifier = match[0];
          throw "unhandled path terminated: " + suffixModifier;
        }

        return last.part;
      },
          peg$c1 = function (first, s, p) {
        return {
          part: p,
          separator: s
        };
      },
          peg$c2 = function (first, tail) {
        var ret = [{
          part: first
        }];

        for (var i = 0; i < tail.length; ++i) {
          ret.push(tail[i]);
        }

        return ret;
      },
          peg$c3 = peg$otherExpectation("_17PathIdent"),
          peg$c4 = "..",
          peg$c5 = peg$literalExpectation("..", false),
          peg$c6 = ".",
          peg$c7 = peg$literalExpectation(".", false),
          peg$c8 = /^[a-zA-Z0-9_$\-!?\^@]/,
          peg$c9 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "$", "-", "!", "?", "^", "@"], false, false),
          peg$c10 = "=",
          peg$c11 = peg$literalExpectation("=", false),
          peg$c12 = function (s) {
        return s;
      },
          peg$c13 = "[",
          peg$c14 = peg$literalExpectation("[", false),
          peg$c15 = /^[^\]]/,
          peg$c16 = peg$classExpectation(["]"], true, false),
          peg$c17 = "]",
          peg$c18 = peg$literalExpectation("]", false),
          peg$c19 = function (segmentLiteral) {
        return segmentLiteral;
      },
          peg$c20 = peg$otherExpectation("_17PathSeparator"),
          peg$c21 = /^[\/.]/,
          peg$c22 = peg$classExpectation(["/", "."], false, false),
          peg$c23 = /^[_a-zA-Z0-9\-]/,
          peg$c24 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c25 = /^[\x80-\xFF]/,
          peg$c26 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c27 = peg$otherExpectation("_26Attribute Key"),
          peg$c28 = ":",
          peg$c29 = peg$literalExpectation(":", false),
          peg$c30 = "@",
          peg$c31 = peg$literalExpectation("@", false),
          peg$c32 = "$",
          peg$c33 = peg$literalExpectation("$", false),
          peg$c34 = function (key, value) {
        return [key, '{{' + value + '}}'];
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_17pathIdNode() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_17path();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_17path() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_17pathIdent();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_17separator();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_17pathIdent();

            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c1(s1, s4, s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_17separator();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_17pathIdent();

              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c1(s1, s4, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c2(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_17pathIdent() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s0 = peg$c6;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];

            if (peg$c8.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c8.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c9);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s1 = input.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }

            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c10;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c11);
                }
              }

              peg$silentFails--;

              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }

              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c13;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];

                if (peg$c15.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c16);
                  }
                }

                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c15.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c16);
                    }
                  }
                }

                if (s3 !== peg$FAILED) {
                  s2 = input.substring(s2, peg$currPos);
                } else {
                  s2 = s3;
                }

                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c17;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c18);
                    }
                  }

                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c19(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_17separator() {
        var s0, s1;
        peg$silentFails++;

        if (peg$c21.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c23.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c25.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }

        return s0;
      }

      function peg$parse_26key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c28;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c29);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c6;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s2 = peg$c30;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c31);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 36) {
                  s2 = peg$c32;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c33);
                  }
                }
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c28;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c29);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c6;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c7);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 64) {
                  s2 = peg$c30;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c31);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s2 = peg$c32;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c33);
                    }
                  }
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c27);
          }
        }

        return s0;
      }

      function peg$parse_32start() {
        var s0;
        s0 = peg$parse_32simpleMustacheAttr();
        return s0;
      }

      function peg$parse_32simpleMustacheAttr() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_17pathIdNode();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c34(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/indentation", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _5start: peg$parse_5start
      },
          peg$startRuleFunction = peg$parse_5start,
          peg$c0 = /^[ \t]/,
          peg$c1 = peg$classExpectation([" ", "\t"], false, false),
          peg$c2 = peg$otherExpectation("_4RequiredWhitespace"),
          peg$c3 = function (s) {
        return s;
      },
          peg$c4 = peg$otherExpectation("_5INDENT"),
          peg$c5 = peg$anyExpectation(),
          peg$c6 = function (t) {
        return _preprocessor.INDENT_SYMBOL === t;
      },
          peg$c7 = function (t) {
        return '';
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      function peg$parse_4start() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_0start();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_0start();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        return s0;
      }

      function peg$parse_5start() {
        var s0;
        s0 = peg$parse_5indentation();
        return s0;
      }

      function peg$parse_5indentation() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_5INDENT();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_4start();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c3(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_5INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c6(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c7(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/inline-comment", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _10start: peg$parse_10start
      },
          peg$startRuleFunction = peg$parse_10start,
          peg$c0 = /^[ \t]/,
          peg$c1 = peg$classExpectation([" ", "\t"], false, false),
          peg$c2 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c3 = peg$anyExpectation(),
          peg$c4 = function (c) {
        return c;
      },
          peg$c5 = peg$otherExpectation("_6INDENT"),
          peg$c6 = function (t) {
        return _preprocessor.INDENT_SYMBOL === t;
      },
          peg$c7 = function (t) {
        return '';
      },
          peg$c8 = peg$otherExpectation("_6DEDENT"),
          peg$c9 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c10 = peg$otherExpectation("_6LineEnd"),
          peg$c11 = "\r",
          peg$c12 = peg$literalExpectation("\r", false),
          peg$c13 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c14 = "\n",
          peg$c15 = peg$literalExpectation("\n", false),
          peg$c16 = function (t) {
        return false;
      },
          peg$c17 = "/",
          peg$c18 = peg$literalExpectation("/", false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        return s0;
      }

      function peg$parse_6lineContent() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_6lineChar();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_6lineChar();
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_6lineChar() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_6INDENT();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_6DEDENT();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_6TERM();
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c3);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_6INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c6(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c7(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        return s0;
      }

      function peg$parse_6DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c9(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c7(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }

        return s0;
      }

      function peg$parse_6TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c11;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c3);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c13(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c14;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c15);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c16(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c10);
          }
        }

        return s0;
      }

      function peg$parse_10start() {
        var s0;
        s0 = peg$parse_10inlineComment();
        return s0;
      }

      function peg$parse_10inlineComment() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 47) {
            s2 = peg$c17;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c18);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_6lineContent();

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/key", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _26start: peg$parse_26start
      },
          peg$startRuleFunction = peg$parse_26start,
          peg$c0 = /^[_a-zA-Z0-9\-]/,
          peg$c1 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c2 = /^[\x80-\xFF]/,
          peg$c3 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c4 = peg$otherExpectation("_26Attribute Key"),
          peg$c5 = ":",
          peg$c6 = peg$literalExpectation(":", false),
          peg$c7 = ".",
          peg$c8 = peg$literalExpectation(".", false),
          peg$c9 = "@",
          peg$c10 = peg$literalExpectation("@", false),
          peg$c11 = "$",
          peg$c12 = peg$literalExpectation("$", false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_26start() {
        var s0;
        s0 = peg$parse_26key();
        return s0;
      }

      function peg$parse_26key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c5;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c7;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s2 = peg$c9;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 36) {
                  s2 = peg$c11;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c12);
                  }
                }
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c5;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c7;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 64) {
                  s2 = peg$c9;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s2 = peg$c11;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c12);
                    }
                  }
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/line-content", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _6start: peg$parse_6start
      },
          peg$startRuleFunction = peg$parse_6start,
          peg$c0 = peg$anyExpectation(),
          peg$c1 = function (c) {
        return c;
      },
          peg$c2 = peg$otherExpectation("_6INDENT"),
          peg$c3 = function (t) {
        return _preprocessor.INDENT_SYMBOL === t;
      },
          peg$c4 = function (t) {
        return '';
      },
          peg$c5 = peg$otherExpectation("_6DEDENT"),
          peg$c6 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c7 = peg$otherExpectation("_6LineEnd"),
          peg$c8 = "\r",
          peg$c9 = peg$literalExpectation("\r", false),
          peg$c10 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c11 = "\n",
          peg$c12 = peg$literalExpectation("\n", false),
          peg$c13 = function (t) {
        return false;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_6start() {
        var s0;
        s0 = peg$parse_6lineContent();
        return s0;
      }

      function peg$parse_6lineContent() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_6lineChar();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_6lineChar();
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_6lineChar() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_6INDENT();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_6DEDENT();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_6TERM();
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c0);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_6INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c3(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        return s0;
      }

      function peg$parse_6DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c6(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        return s0;
      }

      function peg$parse_6TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c8;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c9);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c0);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c10(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c11;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c12);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c13(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/mustache/ast/in-tag", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _40start: peg$parse_40start
      },
          peg$startRuleFunction = peg$parse_40start,
          peg$c0 = peg$otherExpectation("_11mustache expression"),
          peg$c1 = "{",
          peg$c2 = peg$literalExpectation("{", false),
          peg$c3 = /^[^}]/,
          peg$c4 = peg$classExpectation(["}"], true, false),
          peg$c5 = function (text) {
        return text;
      },
          peg$c6 = /^[ \t]/,
          peg$c7 = peg$classExpectation([" ", "\t"], false, false),
          peg$c8 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c9 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), false);
      },
          peg$c10 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), true);
      },
          peg$c11 = peg$otherExpectation("_12Double Mustache Open"),
          peg$c12 = "{{",
          peg$c13 = peg$literalExpectation("{{", false),
          peg$c14 = peg$otherExpectation("_12Triple Mustache Open"),
          peg$c15 = "{{{",
          peg$c16 = peg$literalExpectation("{{{", false),
          peg$c17 = peg$otherExpectation("_12Double Mustache Close"),
          peg$c18 = "}}",
          peg$c19 = peg$literalExpectation("}}", false),
          peg$c20 = peg$otherExpectation("_12Triple Mustache Close"),
          peg$c21 = "}}}",
          peg$c22 = peg$literalExpectation("}}}", false),
          peg$c23 = peg$otherExpectation("_12String Interpolation Open"),
          peg$c24 = "#{",
          peg$c25 = peg$literalExpectation("#{", false),
          peg$c26 = peg$otherExpectation("_12String Interpolation Close"),
          peg$c27 = "}",
          peg$c28 = peg$literalExpectation("}", false),
          peg$c29 = function (value) {
        return value;
      },
          peg$c30 = peg$otherExpectation("_21closing mustache"),
          peg$c31 = function (m) {
        return builder.generateMustache(m, true);
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c3.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c3.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c6.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }

        return s0;
      }

      function peg$parse_12rawMustache() {
        var s0;
        s0 = peg$parse_12rawMustacheUnescaped();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustacheEscaped();
        }

        return s0;
      }

      function peg$parse_12rawMustacheUnescaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12tripleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12tripleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c9(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_12rawMustacheEscaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12doubleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12doubleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c10(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_12hashStacheOpen();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_1start();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_11nonMustache();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_1start();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_12hashStacheClose();

                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c10(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_12doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c12) {
          s0 = peg$c12;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c11);
          }
        }

        return s0;
      }

      function peg$parse_12tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c15) {
          s0 = peg$c15;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c14);
          }
        }

        return s0;
      }

      function peg$parse_12doubleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c18) {
          s0 = peg$c18;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c19);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }

        return s0;
      }

      function peg$parse_12tripleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c21) {
          s0 = peg$c21;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c24) {
          s0 = peg$c24;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c23);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c27;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }

        return s0;
      }

      function peg$parse_21singleMustacheValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_21mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c29(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_21mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c27;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        return s0;
      }

      function peg$parse_40start() {
        var s0;
        s0 = peg$parse_40inTagMustache();
        return s0;
      }

      function peg$parse_40inTagMustache() {
        var s0;
        s0 = peg$parse_40builtSingle();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustache();
        }

        return s0;
      }

      function peg$parse_40builtSingle() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_21singleMustacheValue();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31(s1);
        }

        s0 = s1;
        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/mustache/ast/mustache", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _53start: peg$parse_53start
      },
          peg$startRuleFunction = peg$parse_53start,
          peg$c0 = /^[ \t]/,
          peg$c1 = peg$classExpectation([" ", "\t"], false, false),
          peg$c2 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c3 = peg$otherExpectation("_11mustache expression"),
          peg$c4 = "{",
          peg$c5 = peg$literalExpectation("{", false),
          peg$c6 = /^[^}]/,
          peg$c7 = peg$classExpectation(["}"], true, false),
          peg$c8 = function (text) {
        return text;
      },
          peg$c9 = /^[\-_\/A-Za-z0-9]/,
          peg$c10 = peg$classExpectation(["-", "_", "/", ["A", "Z"], ["a", "z"], ["0", "9"]], false, false),
          peg$c11 = ".",
          peg$c12 = peg$literalExpectation(".", false),
          peg$c13 = "@",
          peg$c14 = peg$literalExpectation("@", false),
          peg$c15 = "::",
          peg$c16 = peg$literalExpectation("::", false),
          peg$c17 = "$",
          peg$c18 = peg$literalExpectation("$", false),
          peg$c19 = ".[",
          peg$c20 = peg$literalExpectation(".[", false),
          peg$c21 = "]",
          peg$c22 = peg$literalExpectation("]", false),
          peg$c23 = "as",
          peg$c24 = peg$literalExpectation("as", false),
          peg$c25 = peg$otherExpectation("_42block param starting pipe"),
          peg$c26 = "|",
          peg$c27 = peg$literalExpectation("|", false),
          peg$c28 = peg$otherExpectation("_43Quoted string"),
          peg$c29 = "\"",
          peg$c30 = peg$literalExpectation("\"", false),
          peg$c31 = "'",
          peg$c32 = peg$literalExpectation("'", false),
          peg$c33 = /^[^'"]/,
          peg$c34 = peg$classExpectation(["'", "\""], true, false),
          peg$c35 = function (v) {
        return v;
      },
          peg$c36 = /^[\/(]/,
          peg$c37 = peg$classExpectation(["/", "("], false, false),
          peg$c38 = /^[_a-zA-Z0-9\-]/,
          peg$c39 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c40 = /^[\x80-\xFF]/,
          peg$c41 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c42 = peg$otherExpectation("_26Attribute Key"),
          peg$c43 = ":",
          peg$c44 = peg$literalExpectation(":", false),
          peg$c45 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c46 = peg$otherExpectation("_3DEDENT"),
          peg$c47 = peg$anyExpectation(),
          peg$c48 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c49 = function (t) {
        return '';
      },
          peg$c50 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c51 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c52 = peg$otherExpectation("_4RequiredWhitespace"),
          peg$c53 = function (s) {
        return s;
      },
          peg$c54 = peg$otherExpectation("_5INDENT"),
          peg$c55 = function (t) {
        return _preprocessor.INDENT_SYMBOL === t;
      },
          peg$c56 = function (c) {
        return c;
      },
          peg$c57 = peg$otherExpectation("_6INDENT"),
          peg$c58 = peg$otherExpectation("_6DEDENT"),
          peg$c59 = peg$otherExpectation("_6LineEnd"),
          peg$c60 = "\r",
          peg$c61 = peg$literalExpectation("\r", false),
          peg$c62 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c63 = "\n",
          peg$c64 = peg$literalExpectation("\n", false),
          peg$c65 = function (t) {
        return false;
      },
          peg$c66 = peg$otherExpectation("_7Comment"),
          peg$c67 = "/",
          peg$c68 = peg$literalExpectation("/", false),
          peg$c69 = function () {
        return [];
      },
          peg$c70 = peg$otherExpectation("_7LineEnd"),
          peg$c71 = peg$otherExpectation("_2LineEnd"),
          peg$c72 = function (initialAttr, attrs) {
        if (initialAttr) attrs.unshift(initialAttr); // Filter out comments

        return attrs.filter(function (attr) {
          return attr && attr.length > 0;
        });
      },
          peg$c73 = function (attr) {
        return attr;
      },
          peg$c74 = "[",
          peg$c75 = peg$literalExpectation("[", false),
          peg$c76 = peg$otherExpectation("_50Closing bracket"),
          peg$c77 = "=",
          peg$c78 = peg$literalExpectation("=", false),
          peg$c79 = function (key, value) {
        return key + '=' + value;
      },
          peg$c80 = "(",
          peg$c81 = peg$literalExpectation("(", false),
          peg$c82 = function (helper, attrs) {
        var firstHalf = '(' + helper;
        if (attrs) return firstHalf + ' ' + attrs.join(' ') + ')';else return firstHalf + ')';
      },
          peg$c83 = peg$otherExpectation("_50Closing ) for Subexpression"),
          peg$c84 = ")",
          peg$c85 = peg$literalExpectation(")", false),
          peg$c86 = peg$otherExpectation("_50Subexpression bracketed attribute"),
          peg$c87 = function (attrs) {
        return attrs;
      },
          peg$c88 = peg$otherExpectation("_50INDENT"),
          peg$c89 = peg$otherExpectation("_50DEDENT"),
          peg$c90 = peg$otherExpectation("_50LineEnd"),
          peg$c91 = peg$otherExpectation("_51tagName shorthand"),
          peg$c92 = "%",
          peg$c93 = peg$literalExpectation("%", false),
          peg$c94 = function (tagName) {
        return 'tagName="' + tagName + '"';
      },
          peg$c95 = peg$otherExpectation("_51elementId shorthand"),
          peg$c96 = "#",
          peg$c97 = peg$literalExpectation("#", false),
          peg$c98 = function (idName) {
        return 'elementId="' + idName + '"';
      },
          peg$c99 = peg$otherExpectation("_51class shorthand"),
          peg$c100 = function (className) {
        return 'class="' + className + '"';
      },
          peg$c101 = /^[A-Za-z0-9\-_]/,
          peg$c102 = peg$classExpectation([["A", "Z"], ["a", "z"], ["0", "9"], "-", "_"], false, false),
          peg$c103 = peg$otherExpectation("_52Unbound modifier !"),
          peg$c104 = "!",
          peg$c105 = peg$literalExpectation("!", false),
          peg$c106 = peg$otherExpectation("_52Conditional modifier ?"),
          peg$c107 = "?",
          peg$c108 = peg$literalExpectation("?", false),
          peg$c109 = peg$otherExpectation("_45block params closing pipe"),
          peg$c110 = function (params) {
        return params;
      },
          peg$c111 = peg$otherExpectation("_46block param"),
          peg$c112 = function (mustacheStart, attrs, blockParams) {
        attrs = attrs.concat(mustacheStart.shorthands);
        mustacheStart['attrs'] = attrs;
        mustacheStart['blockParams'] = blockParams;
        return mustacheStart;
      },
          peg$c113 = function (nameAst, shorthands) {
        var component = nameAst.name.indexOf('-') > -1;
        nameAst['component'] = component;
        nameAst['shorthands'] = shorthands;
        return nameAst;
      },
          peg$c114 = function (name, modifier) {
        return {
          name: name,
          modifier: modifier
        };
      },
          peg$c115 = peg$otherExpectation("_53Invalid mustache starting character"),
          peg$c116 = "-",
          peg$c117 = peg$literalExpectation("-", false),
          peg$c118 = /^[0-9]/,
          peg$c119 = peg$classExpectation([["0", "9"]], false, false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        return s0;
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c4;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c6.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c6.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c8(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_29newMustacheNameChar() {
        var s0;

        if (peg$c9.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c10);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_29arrayIndex();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s0 = peg$c11;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c12);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s0 = peg$c13;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c15) {
                  s0 = peg$c15;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c16);
                  }
                }

                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s0 = peg$c17;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c18);
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_29arrayIndex() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c19) {
          s1 = peg$c19;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_29newMustacheNameChar();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_29newMustacheNameChar();
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c21;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c22);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_42blockStart() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c23) {
          s1 = peg$c23;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_42blockStartPipe();

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_42blockStartPipe() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c26;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c27);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        return s0;
      }

      function peg$parse_43quotedString() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s2 = peg$c29;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_43stringWithoutDouble();

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s4 = peg$c29;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }

            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c31;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_43stringWithoutSingle();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s4 = peg$c31;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }

              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        return s0;
      }

      function peg$parse_43stringWithoutDouble() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c31;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c31;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43stringWithoutSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c29;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s2 = peg$c29;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43inStringChar() {
        var s0;

        if (peg$c33.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c34);
          }
        }

        return s0;
      }

      function peg$parse_44newMustacheAttrValue() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_44invalidValueStartChar();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_42blockStart();
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_43quotedString();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_44valuePath();
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_1start();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c35(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_44valuePath() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_29newMustacheNameChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_29newMustacheNameChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_44invalidValueStartChar() {
        var s0;

        if (peg$c36.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        return s0;
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c38.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c40.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c41);
          }
        }

        return s0;
      }

      function peg$parse_26key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c43;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c44);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c11;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c12);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s2 = peg$c13;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 36) {
                  s2 = peg$c17;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c18);
                  }
                }
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c43;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c44);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c11;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c12);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 64) {
                  s2 = peg$c13;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c14);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s2 = peg$c17;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c18);
                    }
                  }
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }

        return s0;
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c48(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c46);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c51(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c50);
          }
        }

        return s0;
      }

      function peg$parse_4start() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_0start();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_0start();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c52);
          }
        }

        return s0;
      }

      function peg$parse_5indentation() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_5INDENT();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_4start();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c53(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_5INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c55(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c54);
          }
        }

        return s0;
      }

      function peg$parse_6lineContent() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_6lineChar();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_6lineChar();
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_6lineChar() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_6INDENT();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_6DEDENT();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_6TERM();
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c47);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c56(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_6INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c55(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c57);
          }
        }

        return s0;
      }

      function peg$parse_6DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c48(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c58);
          }
        }

        return s0;
      }

      function peg$parse_6TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c60;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c47);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c62(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c63;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c64);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c65(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c59);
          }
        }

        return s0;
      }

      function peg$parse_7comment() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c67;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c68);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_7commentContent();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c69();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c66);
          }
        }

        return s0;
      }

      function peg$parse_7commentContent() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parse_6lineContent();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_7TERM();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$currPos;
            s5 = peg$parse_5indentation();

            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$parse_7commentContent();

              if (s7 !== peg$FAILED) {
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parse_7commentContent();
                }
              } else {
                s6 = peg$FAILED;
              }

              if (s6 !== peg$FAILED) {
                s7 = peg$parse_3anyDedent();

                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$currPos;
              s5 = peg$parse_5indentation();

              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parse_7commentContent();

                if (s7 !== peg$FAILED) {
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parse_7commentContent();
                  }
                } else {
                  s6 = peg$FAILED;
                }

                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_3anyDedent();

                  if (s7 !== peg$FAILED) {
                    s5 = [s5, s6, s7];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c69();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_7TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c60;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c47);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c62(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c63;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c64);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c65(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c70);
          }
        }

        return s0;
      }

      function peg$parse_10inlineComment() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 47) {
            s2 = peg$c67;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c68);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_6lineContent();

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_2blankLine() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_2TERM();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c69();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_2TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c60;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c47);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c62(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c63;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c64);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c65(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c71);
          }
        }

        return s0;
      }

      function peg$parse_50mustacheAttrs() {
        var s0, s1;
        s0 = peg$parse_50bracketedAttrs();

        if (s0 === peg$FAILED) {
          s0 = [];
          s1 = peg$parse_50mustacheAttr();

          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parse_50mustacheAttr();
          }
        }

        return s0;
      }

      function peg$parse_50bracketedAttrs() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_44newMustacheAttrValue();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_50openBracket();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_50bracketedAttr();

            if (s4 === peg$FAILED) {
              s4 = peg$parse_50commentWithSpace();

              if (s4 === peg$FAILED) {
                s4 = peg$parse_2blankLine();
              }
            }

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_50bracketedAttr();

              if (s4 === peg$FAILED) {
                s4 = peg$parse_50commentWithSpace();

                if (s4 === peg$FAILED) {
                  s4 = peg$parse_2blankLine();
                }
              }
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parse_50closeBracket();
              peg$silentFails--;

              if (s5 !== peg$FAILED) {
                peg$currPos = s4;
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c72(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50commentWithSpace() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parse_1start();

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_7comment();

          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c69();
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_50bracketedAttr() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_50mustacheAttr();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_50TERM();

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c73(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50openBracket() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c74;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c75);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_10inlineComment();

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parse_50TERM();

              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parse_50TERM();
                }
              } else {
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_50INDENT();

                if (s5 !== peg$FAILED) {
                  s1 = [s1, s2, s3, s4, s5];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50closeBracket() {
        var s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_50DEDENT();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c21;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c22);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c76);
          }
        }

        return s0;
      }

      function peg$parse_50mustacheAttr() {
        var s0;
        s0 = peg$parse_50mustacheKeyValue();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_50subexpression();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_44newMustacheAttrValue();
          }
        }

        return s0;
      }

      function peg$parse_50mustacheKeyValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c77;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c78);
              }
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_50subexpression();

                if (s5 === peg$FAILED) {
                  s5 = peg$parse_44newMustacheAttrValue();
                }

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c79(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50subexpression() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s2 = peg$c80;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c81);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_1start();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_44newMustacheAttrValue();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_1start();

                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_50subexpressionBracketAttrs();

                  if (s6 === peg$FAILED) {
                    s6 = [];
                    s7 = peg$parse_50subexpressionAttrs();

                    if (s7 !== peg$FAILED) {
                      while (s7 !== peg$FAILED) {
                        s6.push(s7);
                        s7 = peg$parse_50subexpressionAttrs();
                      }
                    } else {
                      s6 = peg$FAILED;
                    }
                  }

                  if (s6 === peg$FAILED) {
                    s6 = null;
                  }

                  if (s6 !== peg$FAILED) {
                    s7 = peg$parse_50subexpressionClose();

                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse_1start();

                      if (s8 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c82(s4, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50subexpressionClose() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s2 = peg$c84;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c85);
            }
          }

          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c83);
          }
        }

        return s0;
      }

      function peg$parse_50subexpressionBracketAttrs() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_50bracketedAttrs();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_50closeBracket();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c87(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c86);
          }
        }

        return s0;
      }

      function peg$parse_50subexpressionAttrs() {
        var s0;
        s0 = peg$parse_50mustacheKeyValue();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_50subexpression();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_44newMustacheAttrValue();
          }
        }

        return s0;
      }

      function peg$parse_50INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c55(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c88);
          }
        }

        return s0;
      }

      function peg$parse_50DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c48(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c89);
          }
        }

        return s0;
      }

      function peg$parse_50TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c60;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c47);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c62(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c63;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c64);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c65(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c90);
          }
        }

        return s0;
      }

      function peg$parse_51newMustacheShortHand() {
        var s0;
        s0 = peg$parse_51shortHandTagName();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_51shortHandIdName();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_51shortHandClassName();
          }
        }

        return s0;
      }

      function peg$parse_51shortHandTagName() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 37) {
          s1 = peg$c92;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c93);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_51newMustacheShortHandName();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c94(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c91);
          }
        }

        return s0;
      }

      function peg$parse_51shortHandIdName() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c96;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c97);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_51newMustacheShortHandName();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c98(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c95);
          }
        }

        return s0;
      }

      function peg$parse_51shortHandClassName() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c11;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_51newMustacheShortHandName();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c100(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c99);
          }
        }

        return s0;
      }

      function peg$parse_51newMustacheShortHandName() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];

        if (peg$c101.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c102);
          }
        }

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);

            if (peg$c101.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c102);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_52modifierChar() {
        var s0;
        s0 = peg$parse_52unboundChar();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_52conditionalChar();
        }

        return s0;
      }

      function peg$parse_52unboundChar() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 33) {
          s0 = peg$c104;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c105);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c103);
          }
        }

        return s0;
      }

      function peg$parse_52conditionalChar() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 63) {
          s0 = peg$c107;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c108);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c106);
          }
        }

        return s0;
      }

      function peg$parse_45blockEnd() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c26;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c27);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c109);
          }
        }

        return s0;
      }

      function peg$parse_46blockParams() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_42blockStart();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_46blockParamName();

            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_46blockParamName();
              }
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_45blockEnd();

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c110(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_46blockParamName() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_44newMustacheAttrValue();
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c111);
          }
        }

        return s0;
      }

      function peg$parse_53start() {
        var s0;
        s0 = peg$parse_53newMustache();
        return s0;
      }

      function peg$parse_53newMustache() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_53newMustacheStart();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_50mustacheAttrs();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_46blockParams();

              if (s4 === peg$FAILED) {
                s4 = null;
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c112(s1, s3, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_53newMustacheStart() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_53newMustacheName();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_51newMustacheShortHand();

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_51newMustacheShortHand();
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c113(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_53newMustacheName() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_53invalidNameStartChar();
        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];
          s4 = peg$parse_29newMustacheNameChar();

          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_29newMustacheNameChar();
            }
          } else {
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_52modifierChar();

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c114(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_53invalidNameStartChar() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 46) {
          s0 = peg$c11;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s0 = peg$c116;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c117);
            }
          }

          if (s0 === peg$FAILED) {
            if (peg$c118.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c119);
              }
            }
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c115);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      function parseInHtml(h, inTagMustaches, fullAttributes, blockParams) {
        var tagName = h[0] || 'div',
            shorthandAttributes = h[1] || [],
            id = shorthandAttributes[0],
            classes = shorthandAttributes[1] || [];
        var i, l;
        var elementNode = builder.generateElement(tagName);
        builder.enter(elementNode);

        for (i = 0, l = classes.length; i < l; i++) {
          if (classes[i].type === 'classNameBinding') {
            builder.add('classNameBindings', classes[i]);
          } else {
            builder.classNameBinding(':' + classes[i]);
          }
        }

        if (id) {
          builder.attribute('id', id);
        }

        for (i = 0; i < inTagMustaches.length; ++i) {
          builder.add('attrStaches', inTagMustaches[i]);
        }

        for (i = 0; i < fullAttributes.length; ++i) {
          var currentAttr = fullAttributes[i];

          if (Array.isArray(currentAttr) && typeof currentAttr[0] === 'string') {
            // a "normalAttribute", [attrName, attrContent]
            if (currentAttr.length) {
              // a boolean false attribute will be []
              // skip classes now, coalesce them later
              if (currentAttr[0] === 'class') {
                builder.classNameBinding(':' + currentAttr[1]);
              } else {
                builder.attribute(currentAttr[0], currentAttr[1]);
              }
            }
          } else if (Array.isArray(currentAttr)) {
            currentAttr.forEach(function (attrNode) {
              builder.add(attrNode.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', attrNode);
            });
          } else {
            builder.add(currentAttr.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', currentAttr);
          }
        }

        if (blockParams && blockParams.length > 0) {
          var joinedParams = blockParams.join(' ');
          var tagString = 'as |' + joinedParams + '|';
          builder.inTagText(tagString);
        }
      }

      function isKnownTag(tag) {
        return !!_tags.default[tag];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/mustache/ast/statement", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _12start: peg$parse_12start
      },
          peg$startRuleFunction = peg$parse_12start,
          peg$c0 = peg$otherExpectation("_11mustache expression"),
          peg$c1 = "{",
          peg$c2 = peg$literalExpectation("{", false),
          peg$c3 = /^[^}]/,
          peg$c4 = peg$classExpectation(["}"], true, false),
          peg$c5 = function (text) {
        return text;
      },
          peg$c6 = /^[ \t]/,
          peg$c7 = peg$classExpectation([" ", "\t"], false, false),
          peg$c8 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c9 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), false);
      },
          peg$c10 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), true);
      },
          peg$c11 = peg$otherExpectation("_12Double Mustache Open"),
          peg$c12 = "{{",
          peg$c13 = peg$literalExpectation("{{", false),
          peg$c14 = peg$otherExpectation("_12Triple Mustache Open"),
          peg$c15 = "{{{",
          peg$c16 = peg$literalExpectation("{{{", false),
          peg$c17 = peg$otherExpectation("_12Double Mustache Close"),
          peg$c18 = "}}",
          peg$c19 = peg$literalExpectation("}}", false),
          peg$c20 = peg$otherExpectation("_12Triple Mustache Close"),
          peg$c21 = "}}}",
          peg$c22 = peg$literalExpectation("}}}", false),
          peg$c23 = peg$otherExpectation("_12String Interpolation Open"),
          peg$c24 = "#{",
          peg$c25 = peg$literalExpectation("#{", false),
          peg$c26 = peg$otherExpectation("_12String Interpolation Close"),
          peg$c27 = "}",
          peg$c28 = peg$literalExpectation("}", false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c3.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c3.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c6.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }

        return s0;
      }

      function peg$parse_12start() {
        var s0;
        s0 = peg$parse_12rawMustache();
        return s0;
      }

      function peg$parse_12rawMustache() {
        var s0;
        s0 = peg$parse_12rawMustacheUnescaped();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustacheEscaped();
        }

        return s0;
      }

      function peg$parse_12rawMustacheUnescaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12tripleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12tripleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c9(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_12rawMustacheEscaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12doubleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12doubleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c10(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_12hashStacheOpen();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_1start();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_11nonMustache();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_1start();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_12hashStacheClose();

                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c10(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_12doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c12) {
          s0 = peg$c12;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c11);
          }
        }

        return s0;
      }

      function peg$parse_12tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c15) {
          s0 = peg$c15;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c14);
          }
        }

        return s0;
      }

      function peg$parse_12doubleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c18) {
          s0 = peg$c18;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c19);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }

        return s0;
      }

      function peg$parse_12tripleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c21) {
          s0 = peg$c21;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c24) {
          s0 = peg$c24;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c23);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c27;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/mustache/attr-statement", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _50start: peg$parse_50start
      },
          peg$startRuleFunction = peg$parse_50start,
          peg$c0 = /^[ \t]/,
          peg$c1 = peg$classExpectation([" ", "\t"], false, false),
          peg$c2 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c3 = peg$otherExpectation("_11mustache expression"),
          peg$c4 = "{",
          peg$c5 = peg$literalExpectation("{", false),
          peg$c6 = /^[^}]/,
          peg$c7 = peg$classExpectation(["}"], true, false),
          peg$c8 = function (text) {
        return text;
      },
          peg$c9 = /^[\-_\/A-Za-z0-9]/,
          peg$c10 = peg$classExpectation(["-", "_", "/", ["A", "Z"], ["a", "z"], ["0", "9"]], false, false),
          peg$c11 = ".",
          peg$c12 = peg$literalExpectation(".", false),
          peg$c13 = "@",
          peg$c14 = peg$literalExpectation("@", false),
          peg$c15 = "::",
          peg$c16 = peg$literalExpectation("::", false),
          peg$c17 = "$",
          peg$c18 = peg$literalExpectation("$", false),
          peg$c19 = ".[",
          peg$c20 = peg$literalExpectation(".[", false),
          peg$c21 = "]",
          peg$c22 = peg$literalExpectation("]", false),
          peg$c23 = "as",
          peg$c24 = peg$literalExpectation("as", false),
          peg$c25 = peg$otherExpectation("_42block param starting pipe"),
          peg$c26 = "|",
          peg$c27 = peg$literalExpectation("|", false),
          peg$c28 = peg$otherExpectation("_43Quoted string"),
          peg$c29 = "\"",
          peg$c30 = peg$literalExpectation("\"", false),
          peg$c31 = "'",
          peg$c32 = peg$literalExpectation("'", false),
          peg$c33 = /^[^'"]/,
          peg$c34 = peg$classExpectation(["'", "\""], true, false),
          peg$c35 = function (v) {
        return v;
      },
          peg$c36 = /^[\/(]/,
          peg$c37 = peg$classExpectation(["/", "("], false, false),
          peg$c38 = /^[_a-zA-Z0-9\-]/,
          peg$c39 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c40 = /^[\x80-\xFF]/,
          peg$c41 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c42 = peg$otherExpectation("_26Attribute Key"),
          peg$c43 = ":",
          peg$c44 = peg$literalExpectation(":", false),
          peg$c45 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c46 = peg$otherExpectation("_3DEDENT"),
          peg$c47 = peg$anyExpectation(),
          peg$c48 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c49 = function (t) {
        return '';
      },
          peg$c50 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c51 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c52 = peg$otherExpectation("_4RequiredWhitespace"),
          peg$c53 = function (s) {
        return s;
      },
          peg$c54 = peg$otherExpectation("_5INDENT"),
          peg$c55 = function (t) {
        return _preprocessor.INDENT_SYMBOL === t;
      },
          peg$c56 = function (c) {
        return c;
      },
          peg$c57 = peg$otherExpectation("_6INDENT"),
          peg$c58 = peg$otherExpectation("_6DEDENT"),
          peg$c59 = peg$otherExpectation("_6LineEnd"),
          peg$c60 = "\r",
          peg$c61 = peg$literalExpectation("\r", false),
          peg$c62 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c63 = "\n",
          peg$c64 = peg$literalExpectation("\n", false),
          peg$c65 = function (t) {
        return false;
      },
          peg$c66 = peg$otherExpectation("_7Comment"),
          peg$c67 = "/",
          peg$c68 = peg$literalExpectation("/", false),
          peg$c69 = function () {
        return [];
      },
          peg$c70 = peg$otherExpectation("_7LineEnd"),
          peg$c71 = peg$otherExpectation("_2LineEnd"),
          peg$c72 = function (initialAttr, attrs) {
        if (initialAttr) attrs.unshift(initialAttr); // Filter out comments

        return attrs.filter(function (attr) {
          return attr && attr.length > 0;
        });
      },
          peg$c73 = function (attr) {
        return attr;
      },
          peg$c74 = "[",
          peg$c75 = peg$literalExpectation("[", false),
          peg$c76 = peg$otherExpectation("_50Closing bracket"),
          peg$c77 = "=",
          peg$c78 = peg$literalExpectation("=", false),
          peg$c79 = function (key, value) {
        return key + '=' + value;
      },
          peg$c80 = "(",
          peg$c81 = peg$literalExpectation("(", false),
          peg$c82 = function (helper, attrs) {
        var firstHalf = '(' + helper;
        if (attrs) return firstHalf + ' ' + attrs.join(' ') + ')';else return firstHalf + ')';
      },
          peg$c83 = peg$otherExpectation("_50Closing ) for Subexpression"),
          peg$c84 = ")",
          peg$c85 = peg$literalExpectation(")", false),
          peg$c86 = peg$otherExpectation("_50Subexpression bracketed attribute"),
          peg$c87 = function (attrs) {
        return attrs;
      },
          peg$c88 = peg$otherExpectation("_50INDENT"),
          peg$c89 = peg$otherExpectation("_50DEDENT"),
          peg$c90 = peg$otherExpectation("_50LineEnd"),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        return s0;
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c4;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c6.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c6.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c8(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_29newMustacheNameChar() {
        var s0;

        if (peg$c9.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c10);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_29arrayIndex();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s0 = peg$c11;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c12);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s0 = peg$c13;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c15) {
                  s0 = peg$c15;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c16);
                  }
                }

                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s0 = peg$c17;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c18);
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_29arrayIndex() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c19) {
          s1 = peg$c19;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_29newMustacheNameChar();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_29newMustacheNameChar();
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c21;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c22);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_42blockStart() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c23) {
          s1 = peg$c23;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_42blockStartPipe();

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_42blockStartPipe() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c26;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c27);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        return s0;
      }

      function peg$parse_43quotedString() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s2 = peg$c29;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_43stringWithoutDouble();

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s4 = peg$c29;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }

            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c31;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_43stringWithoutSingle();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s4 = peg$c31;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }

              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        return s0;
      }

      function peg$parse_43stringWithoutDouble() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c31;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c31;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43stringWithoutSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c29;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s2 = peg$c29;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43inStringChar() {
        var s0;

        if (peg$c33.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c34);
          }
        }

        return s0;
      }

      function peg$parse_44newMustacheAttrValue() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_44invalidValueStartChar();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_42blockStart();
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_43quotedString();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_44valuePath();
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_1start();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c35(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_44valuePath() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_29newMustacheNameChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_29newMustacheNameChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_44invalidValueStartChar() {
        var s0;

        if (peg$c36.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        return s0;
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c38.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c40.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c41);
          }
        }

        return s0;
      }

      function peg$parse_26key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c43;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c44);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c11;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c12);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s2 = peg$c13;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 36) {
                  s2 = peg$c17;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c18);
                  }
                }
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c43;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c44);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c11;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c12);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 64) {
                  s2 = peg$c13;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c14);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s2 = peg$c17;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c18);
                    }
                  }
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }

        return s0;
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c48(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c46);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c51(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c50);
          }
        }

        return s0;
      }

      function peg$parse_4start() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_0start();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_0start();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c52);
          }
        }

        return s0;
      }

      function peg$parse_5indentation() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_5INDENT();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_4start();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c53(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_5INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c55(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c54);
          }
        }

        return s0;
      }

      function peg$parse_6lineContent() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_6lineChar();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_6lineChar();
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_6lineChar() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_6INDENT();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_6DEDENT();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_6TERM();
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c47);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c56(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_6INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c55(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c57);
          }
        }

        return s0;
      }

      function peg$parse_6DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c48(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c58);
          }
        }

        return s0;
      }

      function peg$parse_6TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c60;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c47);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c62(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c63;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c64);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c65(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c59);
          }
        }

        return s0;
      }

      function peg$parse_7comment() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c67;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c68);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_7commentContent();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c69();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c66);
          }
        }

        return s0;
      }

      function peg$parse_7commentContent() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parse_6lineContent();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_7TERM();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$currPos;
            s5 = peg$parse_5indentation();

            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$parse_7commentContent();

              if (s7 !== peg$FAILED) {
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parse_7commentContent();
                }
              } else {
                s6 = peg$FAILED;
              }

              if (s6 !== peg$FAILED) {
                s7 = peg$parse_3anyDedent();

                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$currPos;
              s5 = peg$parse_5indentation();

              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parse_7commentContent();

                if (s7 !== peg$FAILED) {
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parse_7commentContent();
                  }
                } else {
                  s6 = peg$FAILED;
                }

                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_3anyDedent();

                  if (s7 !== peg$FAILED) {
                    s5 = [s5, s6, s7];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c69();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_7TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c60;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c47);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c62(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c63;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c64);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c65(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c70);
          }
        }

        return s0;
      }

      function peg$parse_10inlineComment() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 47) {
            s2 = peg$c67;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c68);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_6lineContent();

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_2blankLine() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_2TERM();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c69();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_2TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c60;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c47);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c62(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c63;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c64);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c65(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c71);
          }
        }

        return s0;
      }

      function peg$parse_50start() {
        var s0;
        s0 = peg$parse_50mustacheAttrs();
        return s0;
      }

      function peg$parse_50mustacheAttrs() {
        var s0, s1;
        s0 = peg$parse_50bracketedAttrs();

        if (s0 === peg$FAILED) {
          s0 = [];
          s1 = peg$parse_50mustacheAttr();

          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parse_50mustacheAttr();
          }
        }

        return s0;
      }

      function peg$parse_50bracketedAttrs() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_44newMustacheAttrValue();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_50openBracket();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_50bracketedAttr();

            if (s4 === peg$FAILED) {
              s4 = peg$parse_50commentWithSpace();

              if (s4 === peg$FAILED) {
                s4 = peg$parse_2blankLine();
              }
            }

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_50bracketedAttr();

              if (s4 === peg$FAILED) {
                s4 = peg$parse_50commentWithSpace();

                if (s4 === peg$FAILED) {
                  s4 = peg$parse_2blankLine();
                }
              }
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parse_50closeBracket();
              peg$silentFails--;

              if (s5 !== peg$FAILED) {
                peg$currPos = s4;
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c72(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50commentWithSpace() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parse_1start();

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_7comment();

          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c69();
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_50bracketedAttr() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_50mustacheAttr();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_50TERM();

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c73(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50openBracket() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c74;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c75);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_10inlineComment();

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parse_50TERM();

              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parse_50TERM();
                }
              } else {
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_50INDENT();

                if (s5 !== peg$FAILED) {
                  s1 = [s1, s2, s3, s4, s5];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50closeBracket() {
        var s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_50DEDENT();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c21;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c22);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c76);
          }
        }

        return s0;
      }

      function peg$parse_50mustacheAttr() {
        var s0;
        s0 = peg$parse_50mustacheKeyValue();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_50subexpression();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_44newMustacheAttrValue();
          }
        }

        return s0;
      }

      function peg$parse_50mustacheKeyValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_26key();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c77;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c78);
              }
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_50subexpression();

                if (s5 === peg$FAILED) {
                  s5 = peg$parse_44newMustacheAttrValue();
                }

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c79(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50subexpression() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s2 = peg$c80;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c81);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_1start();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_44newMustacheAttrValue();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_1start();

                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_50subexpressionBracketAttrs();

                  if (s6 === peg$FAILED) {
                    s6 = [];
                    s7 = peg$parse_50subexpressionAttrs();

                    if (s7 !== peg$FAILED) {
                      while (s7 !== peg$FAILED) {
                        s6.push(s7);
                        s7 = peg$parse_50subexpressionAttrs();
                      }
                    } else {
                      s6 = peg$FAILED;
                    }
                  }

                  if (s6 === peg$FAILED) {
                    s6 = null;
                  }

                  if (s6 !== peg$FAILED) {
                    s7 = peg$parse_50subexpressionClose();

                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse_1start();

                      if (s8 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c82(s4, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_50subexpressionClose() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_1start();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s2 = peg$c84;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c85);
            }
          }

          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c83);
          }
        }

        return s0;
      }

      function peg$parse_50subexpressionBracketAttrs() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parse_50bracketedAttrs();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_50closeBracket();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c87(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c86);
          }
        }

        return s0;
      }

      function peg$parse_50subexpressionAttrs() {
        var s0;
        s0 = peg$parse_50mustacheKeyValue();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_50subexpression();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_44newMustacheAttrValue();
          }
        }

        return s0;
      }

      function peg$parse_50INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c55(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c88);
          }
        }

        return s0;
      }

      function peg$parse_50DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c48(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c89);
          }
        }

        return s0;
      }

      function peg$parse_50TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c60;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c47);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c62(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c63;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c64);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c65(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c90);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      function parseInHtml(h, inTagMustaches, fullAttributes, blockParams) {
        var tagName = h[0] || 'div',
            shorthandAttributes = h[1] || [],
            id = shorthandAttributes[0],
            classes = shorthandAttributes[1] || [];
        var i, l;
        var elementNode = builder.generateElement(tagName);
        builder.enter(elementNode);

        for (i = 0, l = classes.length; i < l; i++) {
          if (classes[i].type === 'classNameBinding') {
            builder.add('classNameBindings', classes[i]);
          } else {
            builder.classNameBinding(':' + classes[i]);
          }
        }

        if (id) {
          builder.attribute('id', id);
        }

        for (i = 0; i < inTagMustaches.length; ++i) {
          builder.add('attrStaches', inTagMustaches[i]);
        }

        for (i = 0; i < fullAttributes.length; ++i) {
          var currentAttr = fullAttributes[i];

          if (Array.isArray(currentAttr) && typeof currentAttr[0] === 'string') {
            // a "normalAttribute", [attrName, attrContent]
            if (currentAttr.length) {
              // a boolean false attribute will be []
              // skip classes now, coalesce them later
              if (currentAttr[0] === 'class') {
                builder.classNameBinding(':' + currentAttr[1]);
              } else {
                builder.attribute(currentAttr[0], currentAttr[1]);
              }
            }
          } else if (Array.isArray(currentAttr)) {
            currentAttr.forEach(function (attrNode) {
              builder.add(attrNode.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', attrNode);
            });
          } else {
            builder.add(currentAttr.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', currentAttr);
          }
        }

        if (blockParams && blockParams.length > 0) {
          var joinedParams = blockParams.join(' ');
          var tagString = 'as |' + joinedParams + '|';
          builder.inTagText(tagString);
        }
      }

      function isKnownTag(tag) {
        return !!_tags.default[tag];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/mustache/attr-value", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _44start: peg$parse_44start
      },
          peg$startRuleFunction = peg$parse_44start,
          peg$c0 = peg$otherExpectation("_11mustache expression"),
          peg$c1 = "{",
          peg$c2 = peg$literalExpectation("{", false),
          peg$c3 = /^[^}]/,
          peg$c4 = peg$classExpectation(["}"], true, false),
          peg$c5 = function (text) {
        return text;
      },
          peg$c6 = /^[\-_\/A-Za-z0-9]/,
          peg$c7 = peg$classExpectation(["-", "_", "/", ["A", "Z"], ["a", "z"], ["0", "9"]], false, false),
          peg$c8 = ".",
          peg$c9 = peg$literalExpectation(".", false),
          peg$c10 = "@",
          peg$c11 = peg$literalExpectation("@", false),
          peg$c12 = "::",
          peg$c13 = peg$literalExpectation("::", false),
          peg$c14 = "$",
          peg$c15 = peg$literalExpectation("$", false),
          peg$c16 = ".[",
          peg$c17 = peg$literalExpectation(".[", false),
          peg$c18 = "]",
          peg$c19 = peg$literalExpectation("]", false),
          peg$c20 = /^[ \t]/,
          peg$c21 = peg$classExpectation([" ", "\t"], false, false),
          peg$c22 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c23 = "as",
          peg$c24 = peg$literalExpectation("as", false),
          peg$c25 = peg$otherExpectation("_42block param starting pipe"),
          peg$c26 = "|",
          peg$c27 = peg$literalExpectation("|", false),
          peg$c28 = peg$otherExpectation("_43Quoted string"),
          peg$c29 = "\"",
          peg$c30 = peg$literalExpectation("\"", false),
          peg$c31 = "'",
          peg$c32 = peg$literalExpectation("'", false),
          peg$c33 = /^[^'"]/,
          peg$c34 = peg$classExpectation(["'", "\""], true, false),
          peg$c35 = function (v) {
        return v;
      },
          peg$c36 = /^[\/(]/,
          peg$c37 = peg$classExpectation(["/", "("], false, false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c3.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c3.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_29newMustacheNameChar() {
        var s0;

        if (peg$c6.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_29arrayIndex();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s0 = peg$c8;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s0 = peg$c10;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c11);
                }
              }

              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c12) {
                  s0 = peg$c12;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c13);
                  }
                }

                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s0 = peg$c14;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c15);
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_29arrayIndex() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c16) {
          s1 = peg$c16;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_29newMustacheNameChar();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_29newMustacheNameChar();
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c18;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c19);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c20.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c21);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        return s0;
      }

      function peg$parse_42blockStart() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c23) {
          s1 = peg$c23;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_42blockStartPipe();

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_42blockStartPipe() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c26;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c27);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        return s0;
      }

      function peg$parse_43quotedString() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s2 = peg$c29;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_43stringWithoutDouble();

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s4 = peg$c29;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }

            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c31;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_43stringWithoutSingle();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s4 = peg$c31;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }

              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        return s0;
      }

      function peg$parse_43stringWithoutDouble() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c31;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c31;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43stringWithoutSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c29;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s2 = peg$c29;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43inStringChar() {
        var s0;

        if (peg$c33.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c34);
          }
        }

        return s0;
      }

      function peg$parse_44start() {
        var s0;
        s0 = peg$parse_44newMustacheAttrValue();
        return s0;
      }

      function peg$parse_44newMustacheAttrValue() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_44invalidValueStartChar();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_42blockStart();
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_43quotedString();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_44valuePath();
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_1start();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c35(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_44valuePath() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_29newMustacheNameChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_29newMustacheNameChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_44invalidValueStartChar() {
        var s0;

        if (peg$c36.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/mustache/name-character", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _29start: peg$parse_29start
      },
          peg$startRuleFunction = peg$parse_29start,
          peg$c0 = /^[\-_\/A-Za-z0-9]/,
          peg$c1 = peg$classExpectation(["-", "_", "/", ["A", "Z"], ["a", "z"], ["0", "9"]], false, false),
          peg$c2 = ".",
          peg$c3 = peg$literalExpectation(".", false),
          peg$c4 = "@",
          peg$c5 = peg$literalExpectation("@", false),
          peg$c6 = "::",
          peg$c7 = peg$literalExpectation("::", false),
          peg$c8 = "$",
          peg$c9 = peg$literalExpectation("$", false),
          peg$c10 = ".[",
          peg$c11 = peg$literalExpectation(".[", false),
          peg$c12 = "]",
          peg$c13 = peg$literalExpectation("]", false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_29start() {
        var s0;
        s0 = peg$parse_29newMustacheNameChar();
        return s0;
      }

      function peg$parse_29newMustacheNameChar() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_29arrayIndex();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s0 = peg$c2;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c3);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s0 = peg$c4;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c5);
                }
              }

              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c6) {
                  s0 = peg$c6;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c7);
                  }
                }

                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s0 = peg$c8;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c9);
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_29arrayIndex() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c10) {
          s1 = peg$c10;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c11);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_29newMustacheNameChar();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_29newMustacheNameChar();
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c12;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c13);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/mustache/non-mustache", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _11start: peg$parse_11start
      },
          peg$startRuleFunction = peg$parse_11start,
          peg$c0 = peg$otherExpectation("_11mustache expression"),
          peg$c1 = "{",
          peg$c2 = peg$literalExpectation("{", false),
          peg$c3 = /^[^}]/,
          peg$c4 = peg$classExpectation(["}"], true, false),
          peg$c5 = function (text) {
        return text;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_11start() {
        var s0;
        s0 = peg$parse_11nonMustache();
        return s0;
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c3.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c3.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/mustache/statement-single", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _21start: peg$parse_21start
      },
          peg$startRuleFunction = peg$parse_21start,
          peg$c0 = peg$otherExpectation("_11mustache expression"),
          peg$c1 = "{",
          peg$c2 = peg$literalExpectation("{", false),
          peg$c3 = /^[^}]/,
          peg$c4 = peg$classExpectation(["}"], true, false),
          peg$c5 = function (text) {
        return text;
      },
          peg$c6 = /^[ \t]/,
          peg$c7 = peg$classExpectation([" ", "\t"], false, false),
          peg$c8 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c9 = function (value) {
        return value;
      },
          peg$c10 = peg$otherExpectation("_21closing mustache"),
          peg$c11 = "}",
          peg$c12 = peg$literalExpectation("}", false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c3.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c3.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c6.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }

        return s0;
      }

      function peg$parse_21start() {
        var s0;
        s0 = peg$parse_21singleMustacheValue();
        return s0;
      }

      function peg$parse_21singleMustacheValue() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_21mustacheClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c9(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_21mustacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c11;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c10);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/nmchar", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _23start: peg$parse_23start
      },
          peg$startRuleFunction = peg$parse_23start,
          peg$c0 = /^[_a-zA-Z0-9\-]/,
          peg$c1 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c2 = /^[\x80-\xFF]/,
          peg$c3 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_23start() {
        var s0;
        s0 = peg$parse_23nmchar();
        return s0;
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/non-glimmer-key", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _24start: peg$parse_24start
      },
          peg$startRuleFunction = peg$parse_24start,
          peg$c0 = /^[_a-zA-Z0-9\-]/,
          peg$c1 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c2 = /^[\x80-\xFF]/,
          peg$c3 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c4 = peg$otherExpectation("_24Key"),
          peg$c5 = ":",
          peg$c6 = peg$literalExpectation(":", false),
          peg$c7 = ".",
          peg$c8 = peg$literalExpectation(".", false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_24start() {
        var s0;
        s0 = peg$parse_24key();
        return s0;
      }

      function peg$parse_24key() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c5;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c7;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_23nmchar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c5;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c7;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/non-mustache-unit", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _13start: peg$parse_13start
      },
          peg$startRuleFunction = peg$parse_13start,
          peg$c0 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c1 = peg$otherExpectation("_3DEDENT"),
          peg$c2 = peg$anyExpectation(),
          peg$c3 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c4 = function (t) {
        return '';
      },
          peg$c5 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c6 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c7 = peg$otherExpectation("_13Single Mustache Open"),
          peg$c8 = "{",
          peg$c9 = peg$literalExpectation("{", false),
          peg$c10 = peg$otherExpectation("_13Double Mustache Open"),
          peg$c11 = "{{",
          peg$c12 = peg$literalExpectation("{{", false),
          peg$c13 = peg$otherExpectation("_13Triple Mustache Open"),
          peg$c14 = "{{{",
          peg$c15 = peg$literalExpectation("{{{", false),
          peg$c16 = peg$otherExpectation("_13String Interpolation Open"),
          peg$c17 = "#{",
          peg$c18 = peg$literalExpectation("#{", false),
          peg$c19 = peg$otherExpectation("_13LineEnd"),
          peg$c20 = "\r",
          peg$c21 = peg$literalExpectation("\r", false),
          peg$c22 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c23 = "\n",
          peg$c24 = peg$literalExpectation("\n", false),
          peg$c25 = function (t) {
        return false;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c3(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c6(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        return s0;
      }

      function peg$parse_13start() {
        var s0;
        s0 = peg$parse_13nonMustacheUnit();
        return s0;
      }

      function peg$parse_13nonMustacheUnit() {
        var s0;
        s0 = peg$parse_13tripleOpen();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_13doubleOpen();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_13hashStacheOpen();

            if (s0 === peg$FAILED) {
              s0 = peg$parse_3anyDedent();

              if (s0 === peg$FAILED) {
                s0 = peg$parse_13TERM();
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_13singleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s0 = peg$c8;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c9);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        return s0;
      }

      function peg$parse_13doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c11) {
          s0 = peg$c11;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c10);
          }
        }

        return s0;
      }

      function peg$parse_13tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c14) {
          s0 = peg$c14;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }

        return s0;
      }

      function peg$parse_13hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c17) {
          s0 = peg$c17;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c18);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        return s0;
      }

      function peg$parse_13TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c20;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c21);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c2);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c22(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c23;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c24);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c25(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c19);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/non-separator-colon", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _18start: peg$parse_18start
      },
          peg$startRuleFunction = peg$parse_18start,
          peg$c0 = ":",
          peg$c1 = peg$literalExpectation(":", false),
          peg$c2 = " ",
          peg$c3 = peg$literalExpectation(" ", false),
          peg$c4 = function (c) {
        return c;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_18start() {
        var s0;
        s0 = peg$parse_18nonSeparatorColon();
        return s0;
      }

      function peg$parse_18nonSeparatorColon() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 58) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;

          if (input.charCodeAt(peg$currPos) === 32) {
            s3 = peg$c2;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c3);
            }
          }

          peg$silentFails--;

          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/param", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _55start: peg$parse_55start
      },
          peg$startRuleFunction = peg$parse_55start,
          peg$c0 = function (v) {
        var last = v[v.length - 1];
        var idNode; // Support for data keywords that are prefixed with @ in the each
        // block helper such as @index, @key, @first, @last

        if (last.part.charAt(0) === '@') {
          last.part = last.part.slice(1);
          idNode = new AST.IdNode(v);
          var dataNode = new AST.DataNode(idNode);
          return dataNode;
        }

        var match;
        var suffixModifier; // FIXME probably need to handle this better?

        if (match = last.part.match(/!$/)) {
          last.part = 'unbound ' + last.part.slice(0, -1);
        }

        if (match = last.part.match(/[\?\^]$/)) {
          suffixModifier = match[0];
          throw "unhandled path terminated: " + suffixModifier;
        }

        return last.part;
      },
          peg$c1 = function (first, s, p) {
        return {
          part: p,
          separator: s
        };
      },
          peg$c2 = function (first, tail) {
        var ret = [{
          part: first
        }];

        for (var i = 0; i < tail.length; ++i) {
          ret.push(tail[i]);
        }

        return ret;
      },
          peg$c3 = peg$otherExpectation("_17PathIdent"),
          peg$c4 = "..",
          peg$c5 = peg$literalExpectation("..", false),
          peg$c6 = ".",
          peg$c7 = peg$literalExpectation(".", false),
          peg$c8 = /^[a-zA-Z0-9_$\-!?\^@]/,
          peg$c9 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "$", "-", "!", "?", "^", "@"], false, false),
          peg$c10 = "=",
          peg$c11 = peg$literalExpectation("=", false),
          peg$c12 = function (s) {
        return s;
      },
          peg$c13 = "[",
          peg$c14 = peg$literalExpectation("[", false),
          peg$c15 = /^[^\]]/,
          peg$c16 = peg$classExpectation(["]"], true, false),
          peg$c17 = "]",
          peg$c18 = peg$literalExpectation("]", false),
          peg$c19 = function (segmentLiteral) {
        return segmentLiteral;
      },
          peg$c20 = peg$otherExpectation("_17PathSeparator"),
          peg$c21 = /^[\/.]/,
          peg$c22 = peg$classExpectation(["/", "."], false, false),
          peg$c23 = function (v) {
        return new AST.BooleanNode(v);
      },
          peg$c24 = peg$otherExpectation("_55Boolean"),
          peg$c25 = "true",
          peg$c26 = peg$literalExpectation("true", false),
          peg$c27 = "false",
          peg$c28 = peg$literalExpectation("false", false),
          peg$c29 = function (v) {
        return new AST.NumberNode(v);
      },
          peg$c30 = peg$otherExpectation("_55Integer"),
          peg$c31 = "-",
          peg$c32 = peg$literalExpectation("-", false),
          peg$c33 = /^[0-9]/,
          peg$c34 = peg$classExpectation([["0", "9"]], false, false),
          peg$c35 = function (s) {
        return parseInt(s);
      },
          peg$c36 = function (v) {
        return new AST.StringNode(v);
      },
          peg$c37 = "\"",
          peg$c38 = peg$literalExpectation("\"", false),
          peg$c39 = "'",
          peg$c40 = peg$literalExpectation("'", false),
          peg$c41 = function (p) {
        return p[1];
      },
          peg$c42 = /^[^"}]/,
          peg$c43 = peg$classExpectation(["\"", "}"], true, false),
          peg$c44 = /^[^'}]/,
          peg$c45 = peg$classExpectation(["'", "}"], true, false),
          peg$c46 = peg$otherExpectation("_55LineEnd"),
          peg$c47 = "\r",
          peg$c48 = peg$literalExpectation("\r", false),
          peg$c49 = peg$anyExpectation(),
          peg$c50 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c51 = "\n",
          peg$c52 = peg$literalExpectation("\n", false),
          peg$c53 = function (t) {
        return false;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_17pathIdNode() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_17path();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_17path() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_17pathIdent();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_17separator();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_17pathIdent();

            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c1(s1, s4, s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_17separator();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_17pathIdent();

              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c1(s1, s4, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c2(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_17pathIdent() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s0 = peg$c6;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];

            if (peg$c8.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c8.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c9);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s1 = input.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }

            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c10;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c11);
                }
              }

              peg$silentFails--;

              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }

              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c13;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];

                if (peg$c15.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c16);
                  }
                }

                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c15.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c16);
                    }
                  }
                }

                if (s3 !== peg$FAILED) {
                  s2 = input.substring(s2, peg$currPos);
                } else {
                  s2 = s3;
                }

                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c17;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c18);
                    }
                  }

                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c19(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_17separator() {
        var s0, s1;
        peg$silentFails++;

        if (peg$c21.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_55start() {
        var s0;
        s0 = peg$parse_55param();
        return s0;
      }

      function peg$parse_55param() {
        var s0;
        s0 = peg$parse_55booleanNode();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_55integerNode();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_17pathIdNode();

            if (s0 === peg$FAILED) {
              s0 = peg$parse_55stringNode();
            }
          }
        }

        return s0;
      }

      function peg$parse_55booleanNode() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_55boolean();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c23(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_55boolean() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 4) === peg$c25) {
          s0 = peg$c25;
          peg$currPos += 4;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c27) {
            s0 = peg$c27;
            peg$currPos += 5;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        return s0;
      }

      function peg$parse_55integerNode() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_55integer();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c29(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_55integer() {
        var s0, s1, s2, s3, s4, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 45) {
          s3 = peg$c31;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c32);
          }
        }

        if (s3 === peg$FAILED) {
          s3 = null;
        }

        if (s3 !== peg$FAILED) {
          s4 = [];

          if (peg$c33.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c34);
            }
          }

          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);

              if (peg$c33.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c34);
                }
              }
            }
          } else {
            s4 = peg$FAILED;
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        if (s2 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s2;
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c35(s1);
        }

        s0 = s1;
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        return s0;
      }

      function peg$parse_55stringNode() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_55string();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c36(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_55string() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s2 = peg$c37;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_55hashDoubleQuoteStringValue();

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s4 = peg$c37;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c38);
              }
            }

            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 === peg$FAILED) {
          s1 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c39;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c40);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_55hashSingleQuoteStringValue();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s4 = peg$c39;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c40);
                }
              }

              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c41(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_55hashDoubleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_55TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c42.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c43);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_55TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c42.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c43);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_55hashSingleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_55TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c44.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_55TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c44.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_55TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c47;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c49);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c50(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c51;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c52);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c53(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c46);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      function parseInHtml(h, inTagMustaches, fullAttributes, blockParams) {
        var tagName = h[0] || 'div',
            shorthandAttributes = h[1] || [],
            id = shorthandAttributes[0],
            classes = shorthandAttributes[1] || [];
        var i, l;
        var elementNode = builder.generateElement(tagName);
        builder.enter(elementNode);

        for (i = 0, l = classes.length; i < l; i++) {
          if (classes[i].type === 'classNameBinding') {
            builder.add('classNameBindings', classes[i]);
          } else {
            builder.classNameBinding(':' + classes[i]);
          }
        }

        if (id) {
          builder.attribute('id', id);
        }

        for (i = 0; i < inTagMustaches.length; ++i) {
          builder.add('attrStaches', inTagMustaches[i]);
        }

        for (i = 0; i < fullAttributes.length; ++i) {
          var currentAttr = fullAttributes[i];

          if (Array.isArray(currentAttr) && typeof currentAttr[0] === 'string') {
            // a "normalAttribute", [attrName, attrContent]
            if (currentAttr.length) {
              // a boolean false attribute will be []
              // skip classes now, coalesce them later
              if (currentAttr[0] === 'class') {
                builder.classNameBinding(':' + currentAttr[1]);
              } else {
                builder.attribute(currentAttr[0], currentAttr[1]);
              }
            }
          } else if (Array.isArray(currentAttr)) {
            currentAttr.forEach(function (attrNode) {
              builder.add(attrNode.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', attrNode);
            });
          } else {
            builder.add(currentAttr.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', currentAttr);
          }
        }

        if (blockParams && blockParams.length > 0) {
          var joinedParams = blockParams.join(' ');
          var tagString = 'as |' + joinedParams + '|';
          builder.inTagText(tagString);
        }
      }

      function isKnownTag(tag) {
        return !!_tags.default[tag];
      }

      var builder = options.builder;
      var UNBOUND_MODIFIER = '!';
      var CONDITIONAL_MODIFIER = '?';

      function logDeprecation(message) {
        if (!options.quiet) {
          var output = 'DEPRECATION: ' + message;

          if (options.file) {
            output += '\nFile: ' + options.file;
          }

          console.log(output);
        }
      }

      function flattenArray(first, tail) {
        var ret = [];

        if (first) {
          ret.push(first);
        }

        for (var i = 0; i < tail.length; ++i) {
          var t = tail[i];
          ret.push(t[0]);

          if (t[1]) {
            ret.push(t[1]);
          }
        }

        return ret;
      }
      /**
        Splits a value string into separate parts,
        then generates a classBinding for each part.
      */


      function splitValueIntoClassBindings(value) {
        return value.split(' ').map(function (v) {
          return builder.generateClassNameBinding(v);
        });
      }

      function isArray(obj) {
        return obj && obj.constructor === Array;
      } // Receives an array object and verifies it has content
      // Useful for checking blocks to make sure there is actual data in the payload


      function isArrayWithContent(obj) {
        if (!isArray(obj)) return;
        var hasItems = false;
        var length = obj.length;

        for (var i = 0; i < length; i++) {
          var item = obj[i];

          if (isArray(item)) {
            if (item.length > 0) hasItems = true;
          } else if (!!item) {
            hasItems = true;
          }
        }

        return hasItems;
      }
      /**
        @param [<<>, {}>] mustacheTuple
        @return
      */


      function createBlockOrMustache(mustacheTuple) {
        var mustache = mustacheTuple[0];
        var block = mustacheTuple[1] || {};
        var escaped = mustache.isEscaped;
        var mustacheContent = mustache.name;
        var mustacheAttrs = mustache.attrs;
        var mustacheBlockParams = mustache.blockParams || block.blockParams;
        var blockTuple = block.blockTuple;

        if (mustacheAttrs.length) {
          var attrs = coalesceAttrs(mustacheAttrs);
          mustacheContent += ' ' + attrs.join(' ');
        }

        if (mustacheBlockParams) {
          mustacheContent += ' as |' + mustacheBlockParams.join(' ') + '|';
        }

        if (mustache.isViewHelper) {
          mustacheContent = 'view ' + mustacheContent;
        }

        if (mustache.modifier === UNBOUND_MODIFIER) {
          logDeprecation('Unbound modifier is deprecated');
          mustacheContent = 'unbound ' + mustacheContent;
        } else if (mustache.modifier === CONDITIONAL_MODIFIER) {
          mustacheContent = 'if ' + mustacheContent;
        }

        if (isArrayWithContent(blockTuple)) {
          var block = builder.generateBlock(mustacheContent, escaped);
          builder.enter(block); // Iterate on each tuple and either add it as a child node or an invertible node

          blockTuple.forEach(function (tuple) {
            if (!tuple) return;
            if (tuple.isInvertible) builder.add('invertibleNodes', tuple);else builder.add('childNodes', tuple);
          });
          return builder.exit();
        } else {
          return builder.generateMustache(mustacheContent, escaped);
        }
      } // attrs are simple strings,
      // combine all the ones that start with 'class='


      function coalesceAttrs(attrs) {
        var classes = [];
        var newAttrs = [];
        var classRegex = /^class="(.*)"$/;
        var match;

        for (var i = 0, l = attrs.length; i < l; i++) {
          var attr = attrs[i];

          if (match = attr.match(classRegex)) {
            classes.push(match[1]);
          } else {
            newAttrs.push(attr);
          }
        }

        if (classes.length) {
          newAttrs.push('class="' + classes.join(' ') + '"');
        }

        return newAttrs;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/path-id-node", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _17start: peg$parse_17start
      },
          peg$startRuleFunction = peg$parse_17start,
          peg$c0 = function (v) {
        var last = v[v.length - 1];
        var idNode; // Support for data keywords that are prefixed with @ in the each
        // block helper such as @index, @key, @first, @last

        if (last.part.charAt(0) === '@') {
          last.part = last.part.slice(1);
          idNode = new AST.IdNode(v);
          var dataNode = new AST.DataNode(idNode);
          return dataNode;
        }

        var match;
        var suffixModifier; // FIXME probably need to handle this better?

        if (match = last.part.match(/!$/)) {
          last.part = 'unbound ' + last.part.slice(0, -1);
        }

        if (match = last.part.match(/[\?\^]$/)) {
          suffixModifier = match[0];
          throw "unhandled path terminated: " + suffixModifier;
        }

        return last.part;
      },
          peg$c1 = function (first, s, p) {
        return {
          part: p,
          separator: s
        };
      },
          peg$c2 = function (first, tail) {
        var ret = [{
          part: first
        }];

        for (var i = 0; i < tail.length; ++i) {
          ret.push(tail[i]);
        }

        return ret;
      },
          peg$c3 = peg$otherExpectation("_17PathIdent"),
          peg$c4 = "..",
          peg$c5 = peg$literalExpectation("..", false),
          peg$c6 = ".",
          peg$c7 = peg$literalExpectation(".", false),
          peg$c8 = /^[a-zA-Z0-9_$\-!?\^@]/,
          peg$c9 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "$", "-", "!", "?", "^", "@"], false, false),
          peg$c10 = "=",
          peg$c11 = peg$literalExpectation("=", false),
          peg$c12 = function (s) {
        return s;
      },
          peg$c13 = "[",
          peg$c14 = peg$literalExpectation("[", false),
          peg$c15 = /^[^\]]/,
          peg$c16 = peg$classExpectation(["]"], true, false),
          peg$c17 = "]",
          peg$c18 = peg$literalExpectation("]", false),
          peg$c19 = function (segmentLiteral) {
        return segmentLiteral;
      },
          peg$c20 = peg$otherExpectation("_17PathSeparator"),
          peg$c21 = /^[\/.]/,
          peg$c22 = peg$classExpectation(["/", "."], false, false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_17start() {
        var s0;
        s0 = peg$parse_17pathIdNode();
        return s0;
      }

      function peg$parse_17pathIdNode() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_17path();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_17path() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_17pathIdent();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_17separator();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_17pathIdent();

            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c1(s1, s4, s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_17separator();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_17pathIdent();

              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c1(s1, s4, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c2(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_17pathIdent() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s0 = peg$c6;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];

            if (peg$c8.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c8.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c9);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s1 = input.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }

            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;

              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c10;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c11);
                }
              }

              peg$silentFails--;

              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }

              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c13;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c14);
                }
              }

              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];

                if (peg$c15.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c16);
                  }
                }

                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c15.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c16);
                    }
                  }
                }

                if (s3 !== peg$FAILED) {
                  s2 = input.substring(s2, peg$currPos);
                } else {
                  s2 = s3;
                }

                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c17;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c18);
                    }
                  }

                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c19(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_17separator() {
        var s0, s1;
        peg$silentFails++;

        if (peg$c21.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/quoted-string", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _43start: peg$parse_43start
      },
          peg$startRuleFunction = peg$parse_43start,
          peg$c0 = peg$otherExpectation("_43Quoted string"),
          peg$c1 = "\"",
          peg$c2 = peg$literalExpectation("\"", false),
          peg$c3 = "'",
          peg$c4 = peg$literalExpectation("'", false),
          peg$c5 = /^[^'"]/,
          peg$c6 = peg$classExpectation(["'", "\""], true, false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_43start() {
        var s0;
        s0 = peg$parse_43quotedString();
        return s0;
      }

      function peg$parse_43quotedString() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_43stringWithoutDouble();

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s4 = peg$c1;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c2);
              }
            }

            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c3;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_43stringWithoutSingle();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s4 = peg$c3;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c4);
                }
              }

              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_43stringWithoutDouble() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c3;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c3;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43stringWithoutSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c1;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c2);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s2 = peg$c1;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c2);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43inStringChar() {
        var s0;

        if (peg$c5.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/string-with-quotes", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _20start: peg$parse_20start
      },
          peg$startRuleFunction = peg$parse_20start,
          peg$c0 = function (p) {
        return p;
      },
          peg$c1 = "'",
          peg$c2 = peg$literalExpectation("'", false),
          peg$c3 = "\"",
          peg$c4 = peg$literalExpectation("\"", false),
          peg$c5 = peg$otherExpectation("_20Closing single quote"),
          peg$c6 = peg$otherExpectation("_20Closing double quote"),
          peg$c7 = peg$otherExpectation("_20string action attributes"),
          peg$c8 = /^[^"}]/,
          peg$c9 = peg$classExpectation(["\"", "}"], true, false),
          peg$c10 = /^[^'}]/,
          peg$c11 = peg$classExpectation(["'", "}"], true, false),
          peg$c12 = peg$otherExpectation("_20LineEnd"),
          peg$c13 = "\r",
          peg$c14 = peg$literalExpectation("\r", false),
          peg$c15 = peg$anyExpectation(),
          peg$c16 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c17 = "\n",
          peg$c18 = peg$literalExpectation("\n", false),
          peg$c19 = function (t) {
        return false;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_20start() {
        var s0;
        s0 = peg$parse_20stringWithQuotes();
        return s0;
      }

      function peg$parse_20stringWithQuotes() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_20singleQuoteString();

        if (s1 === peg$FAILED) {
          s1 = peg$parse_20doubleQuoteString();
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
        }

        s0 = s1;
        return s0;
      }

      function peg$parse_20singleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashSingleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c1;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c2);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20doubleQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c3;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_20hashDoubleQuoteStringValue();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c3;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_20closingSingleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c1;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        return s0;
      }

      function peg$parse_20closingDoubleQuote() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c1;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        return s0;
      }

      function peg$parse_20hashDoubleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c8.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c9);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c8.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        return s0;
      }

      function peg$parse_20hashSingleQuoteStringValue() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse_20TERM();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (peg$c10.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }

          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parse_20TERM();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (peg$c10.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c11);
              }
            }

            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        return s0;
      }

      function peg$parse_20TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c13;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c14);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c15);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c16(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c17;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c18);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c19(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/syntax/block-end", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _45start: peg$parse_45start
      },
          peg$startRuleFunction = peg$parse_45start,
          peg$c0 = peg$otherExpectation("_45block params closing pipe"),
          peg$c1 = "|",
          peg$c2 = peg$literalExpectation("|", false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_45start() {
        var s0;
        s0 = peg$parse_45blockEnd();
        return s0;
      }

      function peg$parse_45blockEnd() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c1;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/syntax/block-params", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _46start: peg$parse_46start
      },
          peg$startRuleFunction = peg$parse_46start,
          peg$c0 = peg$otherExpectation("_11mustache expression"),
          peg$c1 = "{",
          peg$c2 = peg$literalExpectation("{", false),
          peg$c3 = /^[^}]/,
          peg$c4 = peg$classExpectation(["}"], true, false),
          peg$c5 = function (text) {
        return text;
      },
          peg$c6 = /^[\-_\/A-Za-z0-9]/,
          peg$c7 = peg$classExpectation(["-", "_", "/", ["A", "Z"], ["a", "z"], ["0", "9"]], false, false),
          peg$c8 = ".",
          peg$c9 = peg$literalExpectation(".", false),
          peg$c10 = "@",
          peg$c11 = peg$literalExpectation("@", false),
          peg$c12 = "::",
          peg$c13 = peg$literalExpectation("::", false),
          peg$c14 = "$",
          peg$c15 = peg$literalExpectation("$", false),
          peg$c16 = ".[",
          peg$c17 = peg$literalExpectation(".[", false),
          peg$c18 = "]",
          peg$c19 = peg$literalExpectation("]", false),
          peg$c20 = /^[ \t]/,
          peg$c21 = peg$classExpectation([" ", "\t"], false, false),
          peg$c22 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c23 = "as",
          peg$c24 = peg$literalExpectation("as", false),
          peg$c25 = peg$otherExpectation("_42block param starting pipe"),
          peg$c26 = "|",
          peg$c27 = peg$literalExpectation("|", false),
          peg$c28 = peg$otherExpectation("_43Quoted string"),
          peg$c29 = "\"",
          peg$c30 = peg$literalExpectation("\"", false),
          peg$c31 = "'",
          peg$c32 = peg$literalExpectation("'", false),
          peg$c33 = /^[^'"]/,
          peg$c34 = peg$classExpectation(["'", "\""], true, false),
          peg$c35 = function (v) {
        return v;
      },
          peg$c36 = /^[\/(]/,
          peg$c37 = peg$classExpectation(["/", "("], false, false),
          peg$c38 = peg$otherExpectation("_45block params closing pipe"),
          peg$c39 = function (params) {
        return params;
      },
          peg$c40 = peg$otherExpectation("_46block param"),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c3.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c3.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_29newMustacheNameChar() {
        var s0;

        if (peg$c6.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_29arrayIndex();

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s0 = peg$c8;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 64) {
                s0 = peg$c10;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c11);
                }
              }

              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c12) {
                  s0 = peg$c12;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c13);
                  }
                }

                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 36) {
                    s0 = peg$c14;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c15);
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_29arrayIndex() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c16) {
          s1 = peg$c16;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_29newMustacheNameChar();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_29newMustacheNameChar();
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c18;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c19);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c20.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c21);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        return s0;
      }

      function peg$parse_42blockStart() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c23) {
          s1 = peg$c23;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_42blockStartPipe();

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_42blockStartPipe() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c26;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c27);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        return s0;
      }

      function peg$parse_43quotedString() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s2 = peg$c29;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_43stringWithoutDouble();

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s4 = peg$c29;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }

            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c31;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_43stringWithoutSingle();

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s4 = peg$c31;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }

              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        return s0;
      }

      function peg$parse_43stringWithoutDouble() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c31;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c31;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43stringWithoutSingle() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_43inStringChar();

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c29;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
        }

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_43inStringChar();

          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s2 = peg$c29;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_43inStringChar() {
        var s0;

        if (peg$c33.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c34);
          }
        }

        return s0;
      }

      function peg$parse_44newMustacheAttrValue() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_44invalidValueStartChar();

        if (s2 === peg$FAILED) {
          s2 = peg$parse_42blockStart();
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_43quotedString();

          if (s2 === peg$FAILED) {
            s2 = peg$parse_44valuePath();
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_1start();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c35(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_44valuePath() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_29newMustacheNameChar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_29newMustacheNameChar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_44invalidValueStartChar() {
        var s0;

        if (peg$c36.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        return s0;
      }

      function peg$parse_45blockEnd() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c26;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c27);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }

        return s0;
      }

      function peg$parse_46start() {
        var s0;
        s0 = peg$parse_46blockParams();
        return s0;
      }

      function peg$parse_46blockParams() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_42blockStart();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_46blockParamName();

            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_46blockParamName();
              }
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_45blockEnd();

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c39(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_46blockParamName() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_44newMustacheAttrValue();
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/syntax/block-start", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _42start: peg$parse_42start
      },
          peg$startRuleFunction = peg$parse_42start,
          peg$c0 = /^[ \t]/,
          peg$c1 = peg$classExpectation([" ", "\t"], false, false),
          peg$c2 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c3 = "as",
          peg$c4 = peg$literalExpectation("as", false),
          peg$c5 = peg$otherExpectation("_42block param starting pipe"),
          peg$c6 = "|",
          peg$c7 = peg$literalExpectation("|", false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        return s0;
      }

      function peg$parse_42start() {
        var s0;
        s0 = peg$parse_42blockStart();
        return s0;
      }

      function peg$parse_42blockStart() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c3) {
          s1 = peg$c3;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_42blockStartPipe();

            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_42blockStartPipe() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c6;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/syntax/class", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _38start: peg$parse_38start
      },
          peg$startRuleFunction = peg$parse_38start,
          peg$c0 = /^[_a-zA-Z0-9\-]/,
          peg$c1 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c2 = /^[\x80-\xFF]/,
          peg$c3 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c4 = peg$otherExpectation("_36CSS class"),
          peg$c5 = ".",
          peg$c6 = peg$literalExpectation(".", false),
          peg$c7 = function (c) {
        return c;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_36cssIdentifier() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_36ident();
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        return s0;
      }

      function peg$parse_36ident() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_23nmchar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_38start() {
        var s0;
        s0 = peg$parse_38classShorthand();
        return s0;
      }

      function peg$parse_38classShorthand() {
        var s0, s1, s2;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_36cssIdentifier();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c7(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/syntax/css-identifier", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _36start: peg$parse_36start
      },
          peg$startRuleFunction = peg$parse_36start,
          peg$c0 = /^[_a-zA-Z0-9\-]/,
          peg$c1 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c2 = /^[\x80-\xFF]/,
          peg$c3 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c4 = peg$otherExpectation("_36CSS class"),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_36start() {
        var s0;
        s0 = peg$parse_36cssIdentifier();
        return s0;
      }

      function peg$parse_36cssIdentifier() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_36ident();
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        return s0;
      }

      function peg$parse_36ident() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_23nmchar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/syntax/id", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _37start: peg$parse_37start
      },
          peg$startRuleFunction = peg$parse_37start,
          peg$c0 = /^[_a-zA-Z0-9\-]/,
          peg$c1 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c2 = /^[\x80-\xFF]/,
          peg$c3 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c4 = peg$otherExpectation("_36CSS class"),
          peg$c5 = peg$otherExpectation("_37HTML ID"),
          peg$c6 = "#",
          peg$c7 = peg$literalExpectation("#", false),
          peg$c8 = function (c) {
        return c;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_36cssIdentifier() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_36ident();
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        return s0;
      }

      function peg$parse_36ident() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_23nmchar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_37start() {
        var s0;
        s0 = peg$parse_37idShorthand();
        return s0;
      }

      function peg$parse_37idShorthand() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c6;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_36cssIdentifier();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c8(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/syntax/modifier-char", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _52start: peg$parse_52start
      },
          peg$startRuleFunction = peg$parse_52start,
          peg$c0 = peg$otherExpectation("_52Unbound modifier !"),
          peg$c1 = "!",
          peg$c2 = peg$literalExpectation("!", false),
          peg$c3 = peg$otherExpectation("_52Conditional modifier ?"),
          peg$c4 = "?",
          peg$c5 = peg$literalExpectation("?", false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_52start() {
        var s0;
        s0 = peg$parse_52modifierChar();
        return s0;
      }

      function peg$parse_52modifierChar() {
        var s0;
        s0 = peg$parse_52unboundChar();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_52conditionalChar();
        }

        return s0;
      }

      function peg$parse_52unboundChar() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 33) {
          s0 = peg$c1;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_52conditionalChar() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 63) {
          s0 = peg$c4;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      function parseInHtml(h, inTagMustaches, fullAttributes, blockParams) {
        var tagName = h[0] || 'div',
            shorthandAttributes = h[1] || [],
            id = shorthandAttributes[0],
            classes = shorthandAttributes[1] || [];
        var i, l;
        var elementNode = builder.generateElement(tagName);
        builder.enter(elementNode);

        for (i = 0, l = classes.length; i < l; i++) {
          if (classes[i].type === 'classNameBinding') {
            builder.add('classNameBindings', classes[i]);
          } else {
            builder.classNameBinding(':' + classes[i]);
          }
        }

        if (id) {
          builder.attribute('id', id);
        }

        for (i = 0; i < inTagMustaches.length; ++i) {
          builder.add('attrStaches', inTagMustaches[i]);
        }

        for (i = 0; i < fullAttributes.length; ++i) {
          var currentAttr = fullAttributes[i];

          if (Array.isArray(currentAttr) && typeof currentAttr[0] === 'string') {
            // a "normalAttribute", [attrName, attrContent]
            if (currentAttr.length) {
              // a boolean false attribute will be []
              // skip classes now, coalesce them later
              if (currentAttr[0] === 'class') {
                builder.classNameBinding(':' + currentAttr[1]);
              } else {
                builder.attribute(currentAttr[0], currentAttr[1]);
              }
            }
          } else if (Array.isArray(currentAttr)) {
            currentAttr.forEach(function (attrNode) {
              builder.add(attrNode.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', attrNode);
            });
          } else {
            builder.add(currentAttr.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', currentAttr);
          }
        }

        if (blockParams && blockParams.length > 0) {
          var joinedParams = blockParams.join(' ');
          var tagString = 'as |' + joinedParams + '|';
          builder.inTagText(tagString);
        }
      }

      function isKnownTag(tag) {
        return !!_tags.default[tag];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/syntax/mustache-shorthand", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _51start: peg$parse_51start
      },
          peg$startRuleFunction = peg$parse_51start,
          peg$c0 = peg$otherExpectation("_51tagName shorthand"),
          peg$c1 = "%",
          peg$c2 = peg$literalExpectation("%", false),
          peg$c3 = function (tagName) {
        return 'tagName="' + tagName + '"';
      },
          peg$c4 = peg$otherExpectation("_51elementId shorthand"),
          peg$c5 = "#",
          peg$c6 = peg$literalExpectation("#", false),
          peg$c7 = function (idName) {
        return 'elementId="' + idName + '"';
      },
          peg$c8 = peg$otherExpectation("_51class shorthand"),
          peg$c9 = ".",
          peg$c10 = peg$literalExpectation(".", false),
          peg$c11 = function (className) {
        return 'class="' + className + '"';
      },
          peg$c12 = /^[A-Za-z0-9\-_]/,
          peg$c13 = peg$classExpectation([["A", "Z"], ["a", "z"], ["0", "9"], "-", "_"], false, false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_51start() {
        var s0;
        s0 = peg$parse_51newMustacheShortHand();
        return s0;
      }

      function peg$parse_51newMustacheShortHand() {
        var s0;
        s0 = peg$parse_51shortHandTagName();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_51shortHandIdName();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_51shortHandClassName();
          }
        }

        return s0;
      }

      function peg$parse_51shortHandTagName() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 37) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_51newMustacheShortHandName();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c3(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_51shortHandIdName() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_51newMustacheShortHandName();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c7(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        return s0;
      }

      function peg$parse_51shortHandClassName() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c9;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c10);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_51newMustacheShortHandName();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c11(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }

        return s0;
      }

      function peg$parse_51newMustacheShortHandName() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];

        if (peg$c12.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);

            if (peg$c12.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c13);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      function parseInHtml(h, inTagMustaches, fullAttributes, blockParams) {
        var tagName = h[0] || 'div',
            shorthandAttributes = h[1] || [],
            id = shorthandAttributes[0],
            classes = shorthandAttributes[1] || [];
        var i, l;
        var elementNode = builder.generateElement(tagName);
        builder.enter(elementNode);

        for (i = 0, l = classes.length; i < l; i++) {
          if (classes[i].type === 'classNameBinding') {
            builder.add('classNameBindings', classes[i]);
          } else {
            builder.classNameBinding(':' + classes[i]);
          }
        }

        if (id) {
          builder.attribute('id', id);
        }

        for (i = 0; i < inTagMustaches.length; ++i) {
          builder.add('attrStaches', inTagMustaches[i]);
        }

        for (i = 0; i < fullAttributes.length; ++i) {
          var currentAttr = fullAttributes[i];

          if (Array.isArray(currentAttr) && typeof currentAttr[0] === 'string') {
            // a "normalAttribute", [attrName, attrContent]
            if (currentAttr.length) {
              // a boolean false attribute will be []
              // skip classes now, coalesce them later
              if (currentAttr[0] === 'class') {
                builder.classNameBinding(':' + currentAttr[1]);
              } else {
                builder.attribute(currentAttr[0], currentAttr[1]);
              }
            }
          } else if (Array.isArray(currentAttr)) {
            currentAttr.forEach(function (attrNode) {
              builder.add(attrNode.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', attrNode);
            });
          } else {
            builder.add(currentAttr.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', currentAttr);
          }
        }

        if (blockParams && blockParams.length > 0) {
          var joinedParams = blockParams.join(' ');
          var tagString = 'as |' + joinedParams + '|';
          builder.inTagText(tagString);
        }
      }

      function isKnownTag(tag) {
        return !!_tags.default[tag];
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/syntax/tag", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _56start: peg$parse_56start
      },
          peg$startRuleFunction = peg$parse_56start,
          peg$c0 = /^[_a-zA-Z0-9\-]/,
          peg$c1 = peg$classExpectation(["_", ["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
          peg$c2 = /^[\x80-\xFF]/,
          peg$c3 = peg$classExpectation([["\x80", "\xFF"]], false, false),
          peg$c4 = peg$otherExpectation("_36CSS class"),
          peg$c5 = "%",
          peg$c6 = peg$literalExpectation("%", false),
          peg$c7 = function (c) {
        return c;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_23nmchar() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_23nonascii();
        }

        return s0;
      }

      function peg$parse_23nonascii() {
        var s0;

        if (peg$c2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }

        return s0;
      }

      function peg$parse_36cssIdentifier() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_36ident();
        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }

        return s0;
      }

      function peg$parse_36ident() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_23nmchar();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_23nmchar();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_56start() {
        var s0;
        s0 = peg$parse_56tagNameShorthand();
        return s0;
      }

      function peg$parse_56tagNameShorthand() {
        var s0, s1, s2;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 37) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_36cssIdentifier();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c7(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      function buildActionEvent(event, actionContent) {
        actionContent.push('on=\"' + event + '\"');
        return [builder.generateMustache(actionContent.join(' '))];
      }

      function isAliasEvent(event) {
        return !!_events.ALIAS_EVENTS[event];
      }

      function parseInHtml(h, inTagMustaches, fullAttributes, blockParams) {
        var tagName = h[0] || 'div',
            shorthandAttributes = h[1] || [],
            id = shorthandAttributes[0],
            classes = shorthandAttributes[1] || [];
        var i, l;
        var elementNode = builder.generateElement(tagName);
        builder.enter(elementNode);

        for (i = 0, l = classes.length; i < l; i++) {
          if (classes[i].type === 'classNameBinding') {
            builder.add('classNameBindings', classes[i]);
          } else {
            builder.classNameBinding(':' + classes[i]);
          }
        }

        if (id) {
          builder.attribute('id', id);
        }

        for (i = 0; i < inTagMustaches.length; ++i) {
          builder.add('attrStaches', inTagMustaches[i]);
        }

        for (i = 0; i < fullAttributes.length; ++i) {
          var currentAttr = fullAttributes[i];

          if (Array.isArray(currentAttr) && typeof currentAttr[0] === 'string') {
            // a "normalAttribute", [attrName, attrContent]
            if (currentAttr.length) {
              // a boolean false attribute will be []
              // skip classes now, coalesce them later
              if (currentAttr[0] === 'class') {
                builder.classNameBinding(':' + currentAttr[1]);
              } else {
                builder.attribute(currentAttr[0], currentAttr[1]);
              }
            }
          } else if (Array.isArray(currentAttr)) {
            currentAttr.forEach(function (attrNode) {
              builder.add(attrNode.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', attrNode);
            });
          } else {
            builder.add(currentAttr.type === 'classNameBinding' ? 'classNameBindings' : 'attrStaches', currentAttr);
          }
        }

        if (blockParams && blockParams.length > 0) {
          var joinedParams = blockParams.join(' ');
          var tagString = 'as |' + joinedParams + '|';
          builder.inTagText(tagString);
        }
      }

      function isKnownTag(tag) {
        return !!_tags.default[tag];
      }

      var builder = options.builder;
      var UNBOUND_MODIFIER = '!';
      var CONDITIONAL_MODIFIER = '?';

      function logDeprecation(message) {
        if (!options.quiet) {
          var output = 'DEPRECATION: ' + message;

          if (options.file) {
            output += '\nFile: ' + options.file;
          }

          console.log(output);
        }
      }

      function flattenArray(first, tail) {
        var ret = [];

        if (first) {
          ret.push(first);
        }

        for (var i = 0; i < tail.length; ++i) {
          var t = tail[i];
          ret.push(t[0]);

          if (t[1]) {
            ret.push(t[1]);
          }
        }

        return ret;
      }
      /**
        Splits a value string into separate parts,
        then generates a classBinding for each part.
      */


      function splitValueIntoClassBindings(value) {
        return value.split(' ').map(function (v) {
          return builder.generateClassNameBinding(v);
        });
      }

      function isArray(obj) {
        return obj && obj.constructor === Array;
      } // Receives an array object and verifies it has content
      // Useful for checking blocks to make sure there is actual data in the payload


      function isArrayWithContent(obj) {
        if (!isArray(obj)) return;
        var hasItems = false;
        var length = obj.length;

        for (var i = 0; i < length; i++) {
          var item = obj[i];

          if (isArray(item)) {
            if (item.length > 0) hasItems = true;
          } else if (!!item) {
            hasItems = true;
          }
        }

        return hasItems;
      }
      /**
        @param [<<>, {}>] mustacheTuple
        @return
      */


      function createBlockOrMustache(mustacheTuple) {
        var mustache = mustacheTuple[0];
        var block = mustacheTuple[1] || {};
        var escaped = mustache.isEscaped;
        var mustacheContent = mustache.name;
        var mustacheAttrs = mustache.attrs;
        var mustacheBlockParams = mustache.blockParams || block.blockParams;
        var blockTuple = block.blockTuple;

        if (mustacheAttrs.length) {
          var attrs = coalesceAttrs(mustacheAttrs);
          mustacheContent += ' ' + attrs.join(' ');
        }

        if (mustacheBlockParams) {
          mustacheContent += ' as |' + mustacheBlockParams.join(' ') + '|';
        }

        if (mustache.isViewHelper) {
          mustacheContent = 'view ' + mustacheContent;
        }

        if (mustache.modifier === UNBOUND_MODIFIER) {
          logDeprecation('Unbound modifier is deprecated');
          mustacheContent = 'unbound ' + mustacheContent;
        } else if (mustache.modifier === CONDITIONAL_MODIFIER) {
          mustacheContent = 'if ' + mustacheContent;
        }

        if (isArrayWithContent(blockTuple)) {
          var block = builder.generateBlock(mustacheContent, escaped);
          builder.enter(block); // Iterate on each tuple and either add it as a child node or an invertible node

          blockTuple.forEach(function (tuple) {
            if (!tuple) return;
            if (tuple.isInvertible) builder.add('invertibleNodes', tuple);else builder.add('childNodes', tuple);
          });
          return builder.exit();
        } else {
          return builder.generateMustache(mustacheContent, escaped);
        }
      } // attrs are simple strings,
      // combine all the ones that start with 'class='


      function coalesceAttrs(attrs) {
        var classes = [];
        var newAttrs = [];
        var classRegex = /^class="(.*)"$/;
        var match;

        for (var i = 0, l = attrs.length; i < l; i++) {
          var attr = attrs[i];

          if (match = attr.match(classRegex)) {
            classes.push(match[1]);
          } else {
            newAttrs.push(attr);
          }
        }

        if (classes.length) {
          newAttrs.push('class="' + classes.join(' ') + '"');
        }

        return newAttrs;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/text-line", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _16start: peg$parse_16start
      },
          peg$startRuleFunction = peg$parse_16start,
          peg$c0 = peg$otherExpectation("_11mustache expression"),
          peg$c1 = "{",
          peg$c2 = peg$literalExpectation("{", false),
          peg$c3 = /^[^}]/,
          peg$c4 = peg$classExpectation(["}"], true, false),
          peg$c5 = function (text) {
        return text;
      },
          peg$c6 = /^[ \t]/,
          peg$c7 = peg$classExpectation([" ", "\t"], false, false),
          peg$c8 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c9 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), false);
      },
          peg$c10 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), true);
      },
          peg$c11 = peg$otherExpectation("_12Double Mustache Open"),
          peg$c12 = "{{",
          peg$c13 = peg$literalExpectation("{{", false),
          peg$c14 = peg$otherExpectation("_12Triple Mustache Open"),
          peg$c15 = "{{{",
          peg$c16 = peg$literalExpectation("{{{", false),
          peg$c17 = peg$otherExpectation("_12Double Mustache Close"),
          peg$c18 = "}}",
          peg$c19 = peg$literalExpectation("}}", false),
          peg$c20 = peg$otherExpectation("_12Triple Mustache Close"),
          peg$c21 = "}}}",
          peg$c22 = peg$literalExpectation("}}}", false),
          peg$c23 = peg$otherExpectation("_12String Interpolation Open"),
          peg$c24 = "#{",
          peg$c25 = peg$literalExpectation("#{", false),
          peg$c26 = peg$otherExpectation("_12String Interpolation Close"),
          peg$c27 = "}",
          peg$c28 = peg$literalExpectation("}", false),
          peg$c29 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c30 = peg$otherExpectation("_3DEDENT"),
          peg$c31 = peg$anyExpectation(),
          peg$c32 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c33 = function (t) {
        return '';
      },
          peg$c34 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c35 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c36 = peg$otherExpectation("_13Single Mustache Open"),
          peg$c37 = peg$otherExpectation("_13Double Mustache Open"),
          peg$c38 = peg$otherExpectation("_13Triple Mustache Open"),
          peg$c39 = peg$otherExpectation("_13String Interpolation Open"),
          peg$c40 = peg$otherExpectation("_13LineEnd"),
          peg$c41 = "\r",
          peg$c42 = peg$literalExpectation("\r", false),
          peg$c43 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c44 = "\n",
          peg$c45 = peg$literalExpectation("\n", false),
          peg$c46 = function (t) {
        return false;
      },
          peg$c47 = function (first, tail) {
        return flattenArray(first, tail);
      },
          peg$c48 = function (c) {
        return c;
      },
          peg$c49 = peg$otherExpectation("_14LineEnd"),
          peg$c50 = peg$otherExpectation("_4RequiredWhitespace"),
          peg$c51 = function (s) {
        return s;
      },
          peg$c52 = peg$otherExpectation("_5INDENT"),
          peg$c53 = function (t) {
        return _preprocessor.INDENT_SYMBOL === t;
      },
          peg$c54 = function (nodes) {
        return nodes;
      },
          peg$c55 = function (s, nodes, w) {
        return w;
      },
          peg$c56 = function (s, nodes, indentedNodes) {
        var i, l;
        var hasNodes = nodes && nodes.length,
            hasIndentedNodes = indentedNodes && indentedNodes.length; // add a space after the first line if it had content and
        // there are indented nodes to follow

        if (hasNodes && hasIndentedNodes) {
          nodes.push(' ');
        } // concat indented nodes


        if (indentedNodes) {
          for (i = 0, l = indentedNodes.length; i < l; i++) {
            nodes = nodes.concat(indentedNodes[i]); // connect logical lines with a space, skipping the next-to-last line

            if (i < l - 1) {
              nodes.push(' ');
            }
          }
        } // add trailing space to non-indented nodes if special modifier


        if (s === LINE_SPACE_MODIFIERS.SPACE_AFTER) {
          nodes.push(' ');
        } else if (s === LINE_SPACE_MODIFIERS.NEWLINE) {
          nodes.push('\n');
        } else if (s === LINE_SPACE_MODIFIERS.SPACE_BOTH) {
          nodes.push(' ');
          nodes.unshift(' ');
        } else if (s === LINE_SPACE_MODIFIERS.SPACE_BEFORE) {
          nodes.unshift(' ');
        }

        return castStringsToTextNodes(nodes);
      },
          peg$c57 = /^[|`'+"]/,
          peg$c58 = peg$classExpectation(["|", "`", "'", "+", "\""], false, false),
          peg$c59 = " ",
          peg$c60 = peg$literalExpectation(" ", false),
          peg$c61 = "<",
          peg$c62 = peg$literalExpectation("<", false),
          peg$c63 = function () {
        return '<';
      },
          peg$c64 = peg$otherExpectation("_16DEDENT"),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c3.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c3.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c6.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }

        return s0;
      }

      function peg$parse_12rawMustache() {
        var s0;
        s0 = peg$parse_12rawMustacheUnescaped();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustacheEscaped();
        }

        return s0;
      }

      function peg$parse_12rawMustacheUnescaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12tripleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12tripleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c9(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_12rawMustacheEscaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12doubleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12doubleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c10(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_12hashStacheOpen();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_1start();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_11nonMustache();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_1start();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_12hashStacheClose();

                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c10(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_12doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c12) {
          s0 = peg$c12;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c11);
          }
        }

        return s0;
      }

      function peg$parse_12tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c15) {
          s0 = peg$c15;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c14);
          }
        }

        return s0;
      }

      function peg$parse_12doubleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c18) {
          s0 = peg$c18;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c19);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }

        return s0;
      }

      function peg$parse_12tripleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c21) {
          s0 = peg$c21;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c24) {
          s0 = peg$c24;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c23);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c27;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }

        return s0;
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c29);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c31);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c32(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c31);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c35(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c34);
          }
        }

        return s0;
      }

      function peg$parse_13nonMustacheUnit() {
        var s0;
        s0 = peg$parse_13tripleOpen();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_13doubleOpen();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_13hashStacheOpen();

            if (s0 === peg$FAILED) {
              s0 = peg$parse_3anyDedent();

              if (s0 === peg$FAILED) {
                s0 = peg$parse_13TERM();
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_13singleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s0 = peg$c1;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c36);
          }
        }

        return s0;
      }

      function peg$parse_13doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c12) {
          s0 = peg$c12;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        return s0;
      }

      function peg$parse_13tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c15) {
          s0 = peg$c15;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }

        return s0;
      }

      function peg$parse_13hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c24) {
          s0 = peg$c24;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }

        return s0;
      }

      function peg$parse_13TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c43(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c44;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c45);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c46(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_14textNodes() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_14preMustacheText();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_14preMustacheText();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_14preMustacheText();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_14TERM();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c47(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_14preMustacheText() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_14preMustacheUnit();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_14preMustacheUnit();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_14preMustacheUnit() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();
        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c48(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_14TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c43(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c44;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c45);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c46(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c49);
          }
        }

        return s0;
      }

      function peg$parse_4start() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_0start();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_0start();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c50);
          }
        }

        return s0;
      }

      function peg$parse_5indentation() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_5INDENT();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_4start();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c51(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_5INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c31);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c53(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c52);
          }
        }

        return s0;
      }

      function peg$parse_15whitespaceableTextNodes() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_5indentation();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_14textNodes();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_15whitespaceableTextNodes();

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_15whitespaceableTextNodes();
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_3anyDedent();

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c54(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_14textNodes();
        }

        return s0;
      }

      function peg$parse_16start() {
        var s0;
        s0 = peg$parse_16textLine();
        return s0;
      }

      function peg$parse_16textLine() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parse_16textLineStart();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_14textNodes();

          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parse_5indentation();

            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parse_15whitespaceableTextNodes();

              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parse_15whitespaceableTextNodes();
              }

              if (s5 !== peg$FAILED) {
                s6 = peg$parse_16DEDENT();

                if (s6 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c55(s1, s2, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }

            if (s3 === peg$FAILED) {
              s3 = null;
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c56(s1, s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_16textLineStart() {
        var s0, s1, s2;
        s0 = peg$currPos;

        if (peg$c57.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c58);
          }
        }

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 32) {
            s2 = peg$c59;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c60);
            }
          }

          if (s2 === peg$FAILED) {
            s2 = null;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c51(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;

          if (input.charCodeAt(peg$currPos) === 60) {
            s2 = peg$c61;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c62);
            }
          }

          peg$silentFails--;

          if (s2 !== peg$FAILED) {
            peg$currPos = s1;
            s1 = void 0;
          } else {
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c63();
          }

          s0 = s1;
        }

        return s0;
      }

      function peg$parse_16DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c31);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c32(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c64);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      var LINE_SPACE_MODIFIERS = {
        NEWLINE: '`',
        SPACE_AFTER: "'",
        SPACE_BOTH: '"',
        SPACE_BEFORE: "+"
      };

      function castStringsToTextNodes(possibleStrings) {
        var ret = [];
        var nodes = [];
        var currentString = null;
        var possibleString;

        for (var i = 0, l = possibleStrings.length; i < l; i++) {
          possibleString = possibleStrings[i];

          if (typeof possibleString === 'string') {
            currentString = (currentString || '') + possibleString;
          } else {
            if (currentString) {
              ret.push(textNode(currentString));
              currentString = null;
            }

            ret.push(possibleString); // not a string, it is a node here
          }
        }

        if (currentString) {
          ret.push(textNode(currentString));
        }

        return ret;
      }

      function textNode(content) {
        return builder.generateText(content);
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/text-nodes", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _14start: peg$parse_14start
      },
          peg$startRuleFunction = peg$parse_14start,
          peg$c0 = peg$otherExpectation("_11mustache expression"),
          peg$c1 = "{",
          peg$c2 = peg$literalExpectation("{", false),
          peg$c3 = /^[^}]/,
          peg$c4 = peg$classExpectation(["}"], true, false),
          peg$c5 = function (text) {
        return text;
      },
          peg$c6 = /^[ \t]/,
          peg$c7 = peg$classExpectation([" ", "\t"], false, false),
          peg$c8 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c9 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), false);
      },
          peg$c10 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), true);
      },
          peg$c11 = peg$otherExpectation("_12Double Mustache Open"),
          peg$c12 = "{{",
          peg$c13 = peg$literalExpectation("{{", false),
          peg$c14 = peg$otherExpectation("_12Triple Mustache Open"),
          peg$c15 = "{{{",
          peg$c16 = peg$literalExpectation("{{{", false),
          peg$c17 = peg$otherExpectation("_12Double Mustache Close"),
          peg$c18 = "}}",
          peg$c19 = peg$literalExpectation("}}", false),
          peg$c20 = peg$otherExpectation("_12Triple Mustache Close"),
          peg$c21 = "}}}",
          peg$c22 = peg$literalExpectation("}}}", false),
          peg$c23 = peg$otherExpectation("_12String Interpolation Open"),
          peg$c24 = "#{",
          peg$c25 = peg$literalExpectation("#{", false),
          peg$c26 = peg$otherExpectation("_12String Interpolation Close"),
          peg$c27 = "}",
          peg$c28 = peg$literalExpectation("}", false),
          peg$c29 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c30 = peg$otherExpectation("_3DEDENT"),
          peg$c31 = peg$anyExpectation(),
          peg$c32 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c33 = function (t) {
        return '';
      },
          peg$c34 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c35 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c36 = peg$otherExpectation("_13Single Mustache Open"),
          peg$c37 = peg$otherExpectation("_13Double Mustache Open"),
          peg$c38 = peg$otherExpectation("_13Triple Mustache Open"),
          peg$c39 = peg$otherExpectation("_13String Interpolation Open"),
          peg$c40 = peg$otherExpectation("_13LineEnd"),
          peg$c41 = "\r",
          peg$c42 = peg$literalExpectation("\r", false),
          peg$c43 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c44 = "\n",
          peg$c45 = peg$literalExpectation("\n", false),
          peg$c46 = function (t) {
        return false;
      },
          peg$c47 = function (first, tail) {
        return flattenArray(first, tail);
      },
          peg$c48 = function (c) {
        return c;
      },
          peg$c49 = peg$otherExpectation("_14LineEnd"),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c3.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c3.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c6.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c7);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }

        return s0;
      }

      function peg$parse_12rawMustache() {
        var s0;
        s0 = peg$parse_12rawMustacheUnescaped();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustacheEscaped();
        }

        return s0;
      }

      function peg$parse_12rawMustacheUnescaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12tripleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12tripleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c9(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_12rawMustacheEscaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12doubleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12doubleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c10(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_12hashStacheOpen();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_1start();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_11nonMustache();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_1start();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_12hashStacheClose();

                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c10(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_12doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c12) {
          s0 = peg$c12;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c11);
          }
        }

        return s0;
      }

      function peg$parse_12tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c15) {
          s0 = peg$c15;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c14);
          }
        }

        return s0;
      }

      function peg$parse_12doubleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c18) {
          s0 = peg$c18;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c19);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }

        return s0;
      }

      function peg$parse_12tripleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c21) {
          s0 = peg$c21;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c24) {
          s0 = peg$c24;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c23);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c27;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }

        return s0;
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c29);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c31);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c32(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c31);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c35(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c34);
          }
        }

        return s0;
      }

      function peg$parse_13nonMustacheUnit() {
        var s0;
        s0 = peg$parse_13tripleOpen();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_13doubleOpen();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_13hashStacheOpen();

            if (s0 === peg$FAILED) {
              s0 = peg$parse_3anyDedent();

              if (s0 === peg$FAILED) {
                s0 = peg$parse_13TERM();
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_13singleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s0 = peg$c1;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c36);
          }
        }

        return s0;
      }

      function peg$parse_13doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c12) {
          s0 = peg$c12;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        return s0;
      }

      function peg$parse_13tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c15) {
          s0 = peg$c15;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }

        return s0;
      }

      function peg$parse_13hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c24) {
          s0 = peg$c24;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }

        return s0;
      }

      function peg$parse_13TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c43(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c44;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c45);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c46(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_14start() {
        var s0;
        s0 = peg$parse_14textNodes();
        return s0;
      }

      function peg$parse_14textNodes() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_14preMustacheText();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_14preMustacheText();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_14preMustacheText();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_14TERM();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c47(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_14preMustacheText() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_14preMustacheUnit();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_14preMustacheUnit();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_14preMustacheUnit() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();
        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c48(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_14TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c43(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c44;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c45);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c46(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c49);
          }
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/whitespace-raw", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _0start: peg$parse_0start
      },
          peg$startRuleFunction = peg$parse_0start,
          peg$c0 = /^[ \t]/,
          peg$c1 = peg$classExpectation([" ", "\t"], false, false),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/whitespace-req", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _4start: peg$parse_4start
      },
          peg$startRuleFunction = peg$parse_4start,
          peg$c0 = /^[ \t]/,
          peg$c1 = peg$classExpectation([" ", "\t"], false, false),
          peg$c2 = peg$otherExpectation("_4RequiredWhitespace"),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      function peg$parse_4start() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_0start();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_0start();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/whitespace", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _1start: peg$parse_1start
      },
          peg$startRuleFunction = peg$parse_1start,
          peg$c0 = /^[ \t]/,
          peg$c1 = peg$classExpectation([" ", "\t"], false, false),
          peg$c2 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c0.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/pegjs/whitespaceable-text-node", ["exports", "./ast-builder", "./preprocessor", "./html/events", "./html/tags"], function (_exports, _astBuilder, _preprocessor, _events, _tags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.parse = _exports.ParserSyntaxError = void 0;
  _tags = _interopRequireDefault(_tags);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /*jshint newcap: false, laxbreak: true */
  var Parser =
  /*
  * Generated by PEG.js 0.10.0.
  *
  * http://pegjs.org/
  */
  function () {
    "use strict";

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function (expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function (expectation) {
          return "any character";
        },
        end: function (expectation) {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        _15start: peg$parse_15start
      },
          peg$startRuleFunction = peg$parse_15start,
          peg$c0 = peg$otherExpectation("_3ANYDEDENT"),
          peg$c1 = peg$otherExpectation("_3DEDENT"),
          peg$c2 = peg$anyExpectation(),
          peg$c3 = function (t) {
        return _preprocessor.DEDENT_SYMBOL === t;
      },
          peg$c4 = function (t) {
        return '';
      },
          peg$c5 = peg$otherExpectation("_3Unmatched DEDENT"),
          peg$c6 = function (t) {
        return _preprocessor.UNMATCHED_DEDENT_SYMBOL === t;
      },
          peg$c7 = /^[ \t]/,
          peg$c8 = peg$classExpectation([" ", "\t"], false, false),
          peg$c9 = peg$otherExpectation("_4RequiredWhitespace"),
          peg$c10 = function (s) {
        return s;
      },
          peg$c11 = peg$otherExpectation("_5INDENT"),
          peg$c12 = function (t) {
        return _preprocessor.INDENT_SYMBOL === t;
      },
          peg$c13 = peg$otherExpectation("_11mustache expression"),
          peg$c14 = "{",
          peg$c15 = peg$literalExpectation("{", false),
          peg$c16 = /^[^}]/,
          peg$c17 = peg$classExpectation(["}"], true, false),
          peg$c18 = function (text) {
        return text;
      },
          peg$c19 = peg$otherExpectation("_1OptionalWhitespace"),
          peg$c20 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), false);
      },
          peg$c21 = function (content) {
        return builder.generateMustache(prepareMustachValue(content), true);
      },
          peg$c22 = peg$otherExpectation("_12Double Mustache Open"),
          peg$c23 = "{{",
          peg$c24 = peg$literalExpectation("{{", false),
          peg$c25 = peg$otherExpectation("_12Triple Mustache Open"),
          peg$c26 = "{{{",
          peg$c27 = peg$literalExpectation("{{{", false),
          peg$c28 = peg$otherExpectation("_12Double Mustache Close"),
          peg$c29 = "}}",
          peg$c30 = peg$literalExpectation("}}", false),
          peg$c31 = peg$otherExpectation("_12Triple Mustache Close"),
          peg$c32 = "}}}",
          peg$c33 = peg$literalExpectation("}}}", false),
          peg$c34 = peg$otherExpectation("_12String Interpolation Open"),
          peg$c35 = "#{",
          peg$c36 = peg$literalExpectation("#{", false),
          peg$c37 = peg$otherExpectation("_12String Interpolation Close"),
          peg$c38 = "}",
          peg$c39 = peg$literalExpectation("}", false),
          peg$c40 = peg$otherExpectation("_13Single Mustache Open"),
          peg$c41 = peg$otherExpectation("_13Double Mustache Open"),
          peg$c42 = peg$otherExpectation("_13Triple Mustache Open"),
          peg$c43 = peg$otherExpectation("_13String Interpolation Open"),
          peg$c44 = peg$otherExpectation("_13LineEnd"),
          peg$c45 = "\r",
          peg$c46 = peg$literalExpectation("\r", false),
          peg$c47 = function (t) {
        return _preprocessor.TERM_SYMBOL == t;
      },
          peg$c48 = "\n",
          peg$c49 = peg$literalExpectation("\n", false),
          peg$c50 = function (t) {
        return false;
      },
          peg$c51 = function (first, tail) {
        return flattenArray(first, tail);
      },
          peg$c52 = function (c) {
        return c;
      },
          peg$c53 = peg$otherExpectation("_14LineEnd"),
          peg$c54 = function (nodes) {
        return nodes;
      },
          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
      }

      function error(message, location) {
        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$otherExpectation(description) {
        return {
          type: "other",
          description: description
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parse_3anyDedent() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parse_3DEDENT();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_3UNMATCHED_DEDENT();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c0);
          }
        }

        return s0;
      }

      function peg$parse_3DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c3(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        return s0;
      }

      function peg$parse_3UNMATCHED_DEDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c6(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }

        return s0;
      }

      function peg$parse_0start() {
        var s0;

        if (peg$c7.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }

        return s0;
      }

      function peg$parse_4start() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_0start();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_0start();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c9);
          }
        }

        return s0;
      }

      function peg$parse_5indentation() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parse_5INDENT();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_4start();

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c10(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_5INDENT() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c12(s1);

          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c4(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c11);
          }
        }

        return s0;
      }

      function peg$parse_11nonMustache() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c14;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }

        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];

          if (peg$c16.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c17);
            }
          }

          while (s4 !== peg$FAILED) {
            s3.push(s4);

            if (peg$c16.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c18(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }

        return s0;
      }

      function peg$parse_1start() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parse_0start();

        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parse_0start();
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c19);
          }
        }

        return s0;
      }

      function peg$parse_12rawMustache() {
        var s0;
        s0 = peg$parse_12rawMustacheUnescaped();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_12rawMustacheEscaped();
        }

        return s0;
      }

      function peg$parse_12rawMustacheUnescaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12tripleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12tripleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c20(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_12rawMustacheEscaped() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_12doubleOpen();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_1start();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_11nonMustache();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_1start();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_12doubleClose();

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c21(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_12hashStacheOpen();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_1start();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_11nonMustache();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_1start();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_12hashStacheClose();

                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c21(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parse_12doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c23) {
          s0 = peg$c23;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        return s0;
      }

      function peg$parse_12tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c26) {
          s0 = peg$c26;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c27);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        return s0;
      }

      function peg$parse_12doubleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c29) {
          s0 = peg$c29;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        return s0;
      }

      function peg$parse_12tripleClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c32) {
          s0 = peg$c32;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c33);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c31);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c35) {
          s0 = peg$c35;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c36);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c34);
          }
        }

        return s0;
      }

      function peg$parse_12hashStacheClose() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 125) {
          s0 = peg$c38;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        return s0;
      }

      function peg$parse_13nonMustacheUnit() {
        var s0;
        s0 = peg$parse_13tripleOpen();

        if (s0 === peg$FAILED) {
          s0 = peg$parse_13doubleOpen();

          if (s0 === peg$FAILED) {
            s0 = peg$parse_13hashStacheOpen();

            if (s0 === peg$FAILED) {
              s0 = peg$parse_3anyDedent();

              if (s0 === peg$FAILED) {
                s0 = peg$parse_13TERM();
              }
            }
          }
        }

        return s0;
      }

      function peg$parse_13singleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.charCodeAt(peg$currPos) === 123) {
          s0 = peg$c14;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }

        return s0;
      }

      function peg$parse_13doubleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c23) {
          s0 = peg$c23;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c41);
          }
        }

        return s0;
      }

      function peg$parse_13tripleOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 3) === peg$c26) {
          s0 = peg$c26;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c27);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }

        return s0;
      }

      function peg$parse_13hashStacheOpen() {
        var s0, s1;
        peg$silentFails++;

        if (input.substr(peg$currPos, 2) === peg$c35) {
          s0 = peg$c35;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c36);
          }
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c43);
          }
        }

        return s0;
      }

      function peg$parse_13TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c45;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c46);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c2);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c47(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c48;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c49);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c50(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c44);
          }
        }

        return s0;
      }

      function peg$parse_14textNodes() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_14preMustacheText();

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_12rawMustache();

          if (s4 !== peg$FAILED) {
            s5 = peg$parse_14preMustacheText();

            if (s5 === peg$FAILED) {
              s5 = null;
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_12rawMustache();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_14preMustacheText();

              if (s5 === peg$FAILED) {
                s5 = null;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_14TERM();

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c51(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_14preMustacheText() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_14preMustacheUnit();

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_14preMustacheUnit();
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_14preMustacheUnit() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parse_13nonMustacheUnit();
        peg$silentFails--;

        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c2);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c52(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parse_14TERM() {
        var s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c45;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c46);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c2);
            }
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c47(s2);

            if (s3) {
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c48;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c49);
                }
              }

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c50(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$silentFails--;

        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c53);
          }
        }

        return s0;
      }

      function peg$parse_15start() {
        var s0;
        s0 = peg$parse_15whitespaceableTextNodes();
        return s0;
      }

      function peg$parse_15whitespaceableTextNodes() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parse_5indentation();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_14textNodes();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_15whitespaceableTextNodes();

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_15whitespaceableTextNodes();
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_3anyDedent();

              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c54(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$parse_14textNodes();
        }

        return s0;
      }

      function prepareMustachValue(content) {
        var parts = content.split(' '),
            first,
            match; // check for '!' unbound helper

        first = parts.shift();

        if (match = first.match(/(.*)!$/)) {
          parts.unshift(match[1]);
          content = 'unbound ' + parts.join(' ');
        } else {
          parts.unshift(first);
        } // check for '?' if helper


        first = parts.shift();

        if (match = first.match(/(.*)\?$/)) {
          parts.unshift(match[1]);
          content = 'if ' + parts.join(' ');
        } else {
          parts.unshift(first);
        }

        return content;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }();

  var parse = Parser.parse,
      ParserSyntaxError = Parser.SyntaxError;
  _exports.ParserSyntaxError = ParserSyntaxError;
  _exports.parse = parse;
  var _default = parse;
  _exports.default = _default;
});
define("emblem/preprocessor", ["exports", "../string-scanner"], function (_exports, _stringScanner) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.prettyPrint = prettyPrint;
  _exports.processSync = processSync;
  _exports.default = _exports.TERM_SYMBOL = _exports.UNMATCHED_DEDENT_SYMBOL = _exports.DEDENT_SYMBOL = _exports.INDENT_SYMBOL = void 0;
  _stringScanner = _interopRequireDefault(_stringScanner);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var anyWhitespaceAndNewlinesTouchingEOF, any_whitespaceFollowedByNewlines_, processInput, ws;
  ws = '\\t\\x0B\\f \\xA0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF';
  var INDENT_SYMBOL = '\uEFEF';
  _exports.INDENT_SYMBOL = INDENT_SYMBOL;
  var DEDENT_SYMBOL = '\uEFFE';
  _exports.DEDENT_SYMBOL = DEDENT_SYMBOL;
  var UNMATCHED_DEDENT_SYMBOL = '\uEFEE';
  _exports.UNMATCHED_DEDENT_SYMBOL = UNMATCHED_DEDENT_SYMBOL;
  var TERM_SYMBOL = '\uEFFF'; // Prints an easy-to-read version of the preprocessed string for debugging

  _exports.TERM_SYMBOL = TERM_SYMBOL;

  function prettyPrint(string) {
    var indent = new RegExp(INDENT_SYMBOL, 'g');
    var dedent = new RegExp(DEDENT_SYMBOL, 'g');
    var term = new RegExp(TERM_SYMBOL, 'g');
    var unmatchedDedent = new RegExp(UNMATCHED_DEDENT_SYMBOL, 'g');
    var newLine = new RegExp('\n', 'g');
    var carriageReturn = new RegExp('\r', 'g');
    return string.replace(indent, '{INDENT}').replace(dedent, '{DEDENT}').replace(term, '{TERM}').replace(unmatchedDedent, '{UNMATCHED_DEDENT}').replace(newLine, '{\\n}').replace(carriageReturn, '{\\r}');
  }

  anyWhitespaceAndNewlinesTouchingEOF = new RegExp("[" + ws + "\\r?\\n]*$");
  any_whitespaceFollowedByNewlines_ = new RegExp("(?:[" + ws + "]*\\r?\\n)+");

  function Preprocessor() {
    this.base = null;
    this.indents = [];
    this.context = [];
    this.ss = new _stringScanner.default('');

    this.context.peek = function () {
      if (this.length) {
        return this[this.length - 1];
      } else {
        return null;
      }
    };

    this.context.err = function (c) {
      throw new Error("Unexpected " + c);
    };

    this.output = '';

    this.context.observe = function (c) {
      var top;
      top = this.peek();

      switch (c) {
        case INDENT_SYMBOL:
          this.push(c);
          break;

        case DEDENT_SYMBOL:
          if (top !== INDENT_SYMBOL) {
            this.err(c);
          }

          this.pop();
          break;

        case '\r':
          if (top !== '/') {
            this.err(c);
          }

          this.pop();
          break;

        case '\n':
          if (top !== '/') {
            this.err(c);
          }

          this.pop();
          break;

        case '/':
          this.push(c);
          break;

        case 'end-\\':
          if (top !== '\\') {
            this.err(c);
          }

          this.pop();
          break;

        default:
          throw new Error("undefined token observed: " + c);
      }

      return this;
    };
  }

  Preprocessor.prototype.appendToOutput = function (s) {
    if (s) {
      this.output += s;
    }

    return s;
  };

  Preprocessor.prototype.scan = function (r) {
    return this.appendToOutput(this.ss.scan(r));
  };

  Preprocessor.prototype.discard = function (r) {
    return this.ss.scan(r);
  };

  processInput = function (isEnd) {
    return function (data) {
      var b, d, indent, s;

      if (!isEnd) {
        this.ss.concat(data);
        this.discard(any_whitespaceFollowedByNewlines_);
      }

      while (!this.ss.eos()) {
        switch (this.context.peek()) {
          case null:
          case INDENT_SYMBOL:
            if (this.ss.bol() || this.discard(any_whitespaceFollowedByNewlines_)) {
              if (this.discard(new RegExp("[" + ws + "]*\\r?\\n"))) {
                this.appendToOutput("" + TERM_SYMBOL + "\n");
                continue;
              }

              if (this.base != null) {
                if (this.discard(this.base) == null) {
                  throw new Error("inconsistent base indentation");
                }
              } else {
                b = this.discard(new RegExp("[" + ws + "]*"));
                this.base = new RegExp("" + b);
              }

              if (this.indents.length === 0) {
                if (this.ss.check(new RegExp("[" + ws + "]*"))) {
                  this.appendToOutput(INDENT_SYMBOL);
                  this.context.observe(INDENT_SYMBOL);
                  this.indents.push(this.scan(new RegExp("([" + ws + "]*)")));
                }
              } else {
                indent = this.indents[this.indents.length - 1];

                if (d = this.ss.check(new RegExp("(" + indent + ")"))) {
                  this.discard(d);

                  if (this.ss.check(new RegExp("([" + ws + "]+)"))) {
                    this.appendToOutput(INDENT_SYMBOL);
                    this.context.observe(INDENT_SYMBOL);
                    this.indents.push(d + this.scan(new RegExp("([" + ws + "]+)")));
                  }
                } else {
                  while (this.indents.length) {
                    indent = this.indents[this.indents.length - 1];

                    if (this.discard(new RegExp("(?:" + indent + ")"))) {
                      break;
                    }

                    this.context.observe(DEDENT_SYMBOL);
                    this.appendToOutput(DEDENT_SYMBOL);
                    this.indents.pop();
                  }

                  if (s = this.discard(new RegExp("[" + ws + "]+"))) {
                    this.output = this.output.slice(0, -1);
                    this.output += UNMATCHED_DEDENT_SYMBOL;
                    this.appendToOutput(INDENT_SYMBOL);
                    this.context.observe(INDENT_SYMBOL);
                    this.indents.push(s);
                  }
                }
              }
            }

            this.scan(/[^\r\n]+/);

            if (this.discard(/\r?\n/)) {
              this.appendToOutput("" + TERM_SYMBOL + "\n");
            }

        }
      }

      if (isEnd) {
        this.scan(anyWhitespaceAndNewlinesTouchingEOF);

        while (this.context.length && INDENT_SYMBOL === this.context.peek()) {
          this.context.observe(DEDENT_SYMBOL);
          this.appendToOutput(DEDENT_SYMBOL);
        }

        if (this.context.length) {
          throw new Error('Unclosed ' + this.context.peek() + ' at EOF');
        }
      }
    };
  };

  Preprocessor.prototype.processData = processInput(false);
  Preprocessor.prototype.processEnd = processInput(true);

  function processSync(input) {
    var pre;
    input += "\n";
    pre = new Preprocessor();
    pre.processData(input);
    pre.processEnd();
    return pre.output;
  }

  var _default = Preprocessor;
  _exports.default = _default;
});
define("emblem/process-opcodes", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.processOpcodes = processOpcodes;

  function processOpcodes(compiler, opcodes) {
    for (var i = 0, l = opcodes.length; i < l; i++) {
      var method = opcodes[i][0];
      var params = opcodes[i][1];

      if (params) {
        compiler[method].apply(compiler, params);
      } else {
        compiler[method].call(compiler);
      }
    }
  }
});
define("emblem/quoting", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.escapeString = escapeString;
  _exports.string = string;
  _exports.repeat = repeat;

  function escapeString(str) {
    str = str.replace(/\\/g, "\\\\");
    str = str.replace(/"/g, '\\"');
    str = str.replace(/\n/g, "\\n");
    return str;
  }

  function string(str) {
    return '"' + escapeString(str) + '"';
  }

  function repeat(chars, times) {
    var str = "";

    while (times--) {
      str += chars;
    }

    return str;
  }
});
define("emblem/template-compiler", ["exports", "./process-opcodes", "./template-visitor", "./quoting"], function (_exports, _processOpcodes, _templateVisitor, _quoting) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.compile = compile;
  var options = {};

  function compile(ast, additionalOptions) {
    var opcodes = [];

    if (additionalOptions) {
      options = additionalOptions;
    }

    (0, _templateVisitor.visit)(ast, opcodes);
    reset(compiler);
    (0, _processOpcodes.processOpcodes)(compiler, opcodes);
    return flush(compiler);
  }

  function reset(compiler) {
    compiler._content = [];
  }

  function flush(compiler) {
    return compiler._content.join('');
  }

  function pushContent(compiler, content) {
    compiler._content.push(content);
  }
  /**
    Wrap an string in mustache
    @param {Array} names
    @return {Array}
  */


  function wrapMustacheStrings(names) {
    return names.map(function (name) {
      return '{{' + name + '}}';
    });
  }
  /**
    Map a colon syntax string to inline if syntax.
    @param {String} Name
    @return {String}
  */


  function mapColonSyntax(name) {
    var parts = name.split(':'); // First item will always be wrapped in single quotes (since we need at least one result for condition)

    parts[1] = singleQuoteString(parts[1]); // Only wrap second option if it exists

    if (parts[2]) parts[2] = singleQuoteString(parts[2]);
    parts.unshift('if');
    return parts.join(' ');
  }
  /**
    Wrap an string in single quotes
    @param {String} value
    @return {String}
  */


  function singleQuoteString(value) {
    return "'" + value + "'";
  }

  var boundClassNames, unboundClassNames;
  var compiler = {
    startProgram: function () {},
    endProgram: function () {},
    text: function (content) {
      pushContent(this, content);
    },
    attribute: function (name, content) {
      var attrString = ' ' + name;

      if (content === undefined) {// boolean attribute with a true value, this is a no-op
      } else if (typeof content === 'string') {
        // Ensure proper quoting for a string
        attrString += '=' + (0, _quoting.string)(content);
      } else {
        // Anything else (e.g. a number) is uncoerced
        attrString += '=' + content;
      }

      pushContent(this, attrString);
    },
    openElementStart: function (tagName) {
      this._insideElement = true;
      pushContent(this, '<' + tagName);
    },
    openElementEnd: function () {
      pushContent(this, '>');
      this._insideElement = false;
    },
    closeElement: function (tagName) {
      pushContent(this, '</' + tagName + '>');
    },
    openClassNameBindings: function () {
      boundClassNames = [];
      unboundClassNames = [];
    },

    /**
      Add a class name binding
      @param {String} name
    */
    classNameBinding: function (name) {
      var isBoundAttribute = name[0] !== ':';

      if (isBoundAttribute) {
        var isColonSyntax = name.indexOf(':') > -1;

        if (isColonSyntax) {
          name = mapColonSyntax(name);
        }

        boundClassNames.push(name);
      } else {
        name = name.slice(1);
        unboundClassNames.push(name);
      }
    },

    /**
      Group all unbound classes into a single string
      Wrap each binding in mustache
    */
    closeClassNameBindings: function () {
      var unboundClassString = unboundClassNames.join(' ');
      var mustacheString = wrapMustacheStrings(boundClassNames).join(' ');
      var results = [unboundClassString, mustacheString]; // Remove any blank strings

      results = results.filter(function (i) {
        return i !== "";
      });
      results = results.join(' '); // We only need to wrap the results in quotes if we have at least one unbound or more than 1 bound attributes

      var wrapInString = unboundClassString.length > 0 || boundClassNames.length > 1;
      if (wrapInString) results = (0, _quoting.string)(results);else if (results.length === 0) results = '\"\"';
      pushContent(this, ' class=' + results);
    },
    startBlock: function (content) {
      pushContent(this, '{{#' + content + '}}');
    },
    endBlock: function (content) {
      var parts = content.split(' ');
      pushContent(this, '{{/' + parts[0] + '}}');
    },
    mustache: function (content, escaped) {
      var prepend = this._insideElement ? ' ' : '';

      if (escaped) {
        pushContent(this, prepend + '{{' + content + '}}');
      } else {
        pushContent(this, prepend + '{{{' + content + '}}}');
      }
    },
    inTagText: function (content) {
      pushContent(this, ' ' + content);
    },

    /**
      Special syntax for assigning mustache to a key
      @param {String} content
      @param {String} key
    */
    assignedMustache: function (content, key) {
      var prepend = this._insideElement ? ' ' : '';

      if (key.match(/^on/) || !options.legacyAttributeQuoting) {
        pushContent(this, prepend + key + '={{' + content + '}}');
      } else {
        pushContent(this, prepend + key + '=\"{{' + content + '}}\"');
      }
    }
  };
});
define("emblem/template-visitor", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.visit = visit;

  /**
    Visit a single node
    @oaram {Object} node
    @param {Array} opcodes
  */
  function visit(node, opcodes) {
    visitor[node.type](node, opcodes);
  }
  /**
    Visit a series of nodes
    @oaram {Array} nodes
    @param {Array} opcodes
  */


  function visitArray(nodes, opcodes) {
    if (!nodes || nodes.length === 0) {
      return;
    }

    for (var i = 0, l = nodes.length; i < l; i++) {
      // Due to the structure of invertible nodes, it is possible to receive an array of arrays
      if (nodes[i] instanceof Array) visitArray(nodes[i], opcodes);else visit(nodes[i], opcodes);
    }
  }
  /**
    Process an invertible object
    @param {Object} node
    @param {Array} opcodes
  */


  function addInvertible(node, opcodes) {
    opcodes.push(['mustache', [node.name.trim(), true]]); // The content helper always returns an array

    visitArray(node.content, opcodes); // Recursion if this node has more invertible nodes

    if (node.invertibleNodes) addInvertible(node.invertibleNodes, opcodes);
  }

  var visitor = {
    program: function (node, opcodes) {
      opcodes.push(['startProgram']);
      visitArray(node.childNodes, opcodes);
      opcodes.push(['endProgram']);
    },
    text: function (node, opcodes) {
      opcodes.push(['text', [node.content]]);
    },
    attribute: function (node, opcodes) {
      opcodes.push(['attribute', [node.name, node.content]]);
    },
    classNameBinding: function (node, opcodes) {
      opcodes.push(['classNameBinding', [node.name]]);
    },
    element: function (node, opcodes) {
      opcodes.push(['openElementStart', [node.tagName]]);
      visitArray(node.attrStaches, opcodes);

      if (node.classNameBindings && node.classNameBindings.length) {
        opcodes.push(['openClassNameBindings']);
        visitArray(node.classNameBindings, opcodes);
        opcodes.push(['closeClassNameBindings']);
      }

      visitArray(node.inTagText, opcodes);
      opcodes.push(['openElementEnd']);

      if (node.isVoid) {
        if (node.childNodes.length) {
          throw new Error('Cannot nest under void element ' + node.tagName);
        }
      } else {
        visitArray(node.childNodes, opcodes);
        opcodes.push(['closeElement', [node.tagName]]);
      }
    },
    block: function (node, opcodes) {
      opcodes.push(['startBlock', [node.content]]);
      visitArray(node.childNodes, opcodes); // The root block node will have an array of invertibleNodes, but there can only ever be one

      if (node.invertibleNodes && node.invertibleNodes.length > 0) {
        addInvertible(node.invertibleNodes[0], opcodes);
      }

      opcodes.push(['endBlock', [node.content]]);
    },
    mustache: function (node, opcodes) {
      opcodes.push(['mustache', [node.content, node.escaped]]);
    },
    inTagText: function (node, opcodes) {
      opcodes.push(['inTagText', [node.content]]);
    },
    assignedMustache: function (node, opcodes) {
      opcodes.push(['assignedMustache', [node.content, node.key]]);
    }
  };
});
define("emblem/utils/void-elements", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  // http://www.w3.org/TR/html-markup/syntax.html#syntax-elements
  var voidElementTags = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];

  function isVoidElement(tagName) {
    return voidElementTags.indexOf(tagName) > -1;
  }

  var _default = isVoidElement;
  _exports.default = _default;
});
define("string-scanner", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  var module = {};

  (function () {
    (function () {
      var StringScanner;

      StringScanner = function () {
        function StringScanner(str) {
          this.str = str != null ? str : '';
          this.str = '' + this.str;
          this.pos = 0;
          this.lastMatch = {
            reset: function () {
              this.str = null;
              this.captures = [];
              return this;
            }
          }.reset();
          this;
        }

        StringScanner.prototype.bol = function () {
          return this.pos <= 0 || this.str[this.pos - 1] === "\n";
        };

        StringScanner.prototype.captures = function () {
          return this.lastMatch.captures;
        };

        StringScanner.prototype.check = function (pattern) {
          var matches;

          if (this.str.substr(this.pos).search(pattern) !== 0) {
            this.lastMatch.reset();
            return null;
          }

          matches = this.str.substr(this.pos).match(pattern);
          this.lastMatch.str = matches[0];
          this.lastMatch.captures = matches.slice(1);
          return this.lastMatch.str;
        };

        StringScanner.prototype.checkUntil = function (pattern) {
          var matches, patternPos;
          patternPos = this.str.substr(this.pos).search(pattern);

          if (patternPos < 0) {
            this.lastMatch.reset();
            return null;
          }

          matches = this.str.substr(this.pos + patternPos).match(pattern);
          this.lastMatch.captures = matches.slice(1);
          return this.lastMatch.str = this.str.substr(this.pos, patternPos) + matches[0];
        };

        StringScanner.prototype.clone = function () {
          var clone, prop, value, _ref;

          clone = new this.constructor(this.str);
          clone.pos = this.pos;
          clone.lastMatch = {};
          _ref = this.lastMatch;

          for (prop in _ref) {
            value = _ref[prop];
            clone.lastMatch[prop] = value;
          }

          return clone;
        };

        StringScanner.prototype.concat = function (str) {
          this.str += str;
          return this;
        };

        StringScanner.prototype.eos = function () {
          return this.pos === this.str.length;
        };

        StringScanner.prototype.exists = function (pattern) {
          var matches, patternPos;
          patternPos = this.str.substr(this.pos).search(pattern);

          if (patternPos < 0) {
            this.lastMatch.reset();
            return null;
          }

          matches = this.str.substr(this.pos + patternPos).match(pattern);
          this.lastMatch.str = matches[0];
          this.lastMatch.captures = matches.slice(1);
          return patternPos;
        };

        StringScanner.prototype.getch = function () {
          return this.scan(/./);
        };

        StringScanner.prototype.match = function () {
          return this.lastMatch.str;
        };

        StringScanner.prototype.matches = function (pattern) {
          this.check(pattern);
          return this.matchSize();
        };

        StringScanner.prototype.matched = function () {
          return this.lastMatch.str != null;
        };

        StringScanner.prototype.matchSize = function () {
          if (this.matched()) {
            return this.match().length;
          } else {
            return null;
          }
        };

        StringScanner.prototype.peek = function (len) {
          return this.str.substr(this.pos, len);
        };

        StringScanner.prototype.pointer = function () {
          return this.pos;
        };

        StringScanner.prototype.setPointer = function (pos) {
          pos = +pos;

          if (pos < 0) {
            pos = 0;
          }

          if (pos > this.str.length) {
            pos = this.str.length;
          }

          return this.pos = pos;
        };

        StringScanner.prototype.reset = function () {
          this.lastMatch.reset();
          this.pos = 0;
          return this;
        };

        StringScanner.prototype.rest = function () {
          return this.str.substr(this.pos);
        };

        StringScanner.prototype.scan = function (pattern) {
          var chk;
          chk = this.check(pattern);

          if (chk != null) {
            this.pos += chk.length;
          }

          return chk;
        };

        StringScanner.prototype.scanUntil = function (pattern) {
          var chk;
          chk = this.checkUntil(pattern);

          if (chk != null) {
            this.pos += chk.length;
          }

          return chk;
        };

        StringScanner.prototype.skip = function (pattern) {
          this.scan(pattern);
          return this.matchSize();
        };

        StringScanner.prototype.skipUntil = function (pattern) {
          this.scanUntil(pattern);
          return this.matchSize();
        };

        StringScanner.prototype.string = function () {
          return this.str;
        };

        StringScanner.prototype.terminate = function () {
          this.pos = this.str.length;
          this.lastMatch.reset();
          return this;
        };

        StringScanner.prototype.toString = function () {
          return "#<StringScanner " + (this.eos() ? 'fin' : "" + this.pos + "/" + this.str.length + " @ " + (this.str.length > 8 ? "" + this.str.substr(0, 5) + "..." : this.str)) + ">";
        };

        return StringScanner;
      }();

      StringScanner.prototype.beginningOfLine = StringScanner.prototype.bol;
      StringScanner.prototype.clear = StringScanner.prototype.terminate;
      StringScanner.prototype.dup = StringScanner.prototype.clone;
      StringScanner.prototype.endOfString = StringScanner.prototype.eos;
      StringScanner.prototype.exist = StringScanner.prototype.exists;
      StringScanner.prototype.getChar = StringScanner.prototype.getch;
      StringScanner.prototype.position = StringScanner.prototype.pointer;
      StringScanner.StringScanner = StringScanner;
      module.exports = StringScanner;
    }).call(this);
  })();

  var _default = module.exports;
  _exports.default = _default;
});